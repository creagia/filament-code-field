(() => {
  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string2 = this.text[i], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from, to, text);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      if (text.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i] = updated;
              return new TextNode(copy, this.length - (to - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
      let line = text[i], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let {value} = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let {done, lineBreak, value} = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
      if (extend[i] > code)
        return extend[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json2) {
      if (!Array.isArray(json2) || json2.length % 2 || json2.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json2);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index = i >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set = new ChangeSet(sections, inserted);
        total = total ? total.compose(set.map(total)) : set;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let {from, to = from, insert: insert2} = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json2) {
      if (!Array.isArray(json2))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json2.length; i++) {
        let part = json2[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert2)
              addInsert(insert2, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left = a.len;
        while (left) {
          if (b.ins == -1) {
            let piece = Math.min(left, b.len);
            len += piece;
            left -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert2 && inserted < a.i)
          addInsert(insert2, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set) {
      this.set = set;
      this.i = 0;
      this.next();
    }
    next() {
      let {sections} = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let {inserted} = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let {inserted} = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return {anchor: this.anchor, head: this.head};
    }
    static fromJSON(json2) {
      if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json2.anchor, json2.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range, main = true) {
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return {ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex};
    }
    static fromJSON(json2) {
      if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        if (range.empty ? range.from <= pos : range.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i = 1; i < ranges.length; i++) {
        let range = ranges[i], prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get)
        get = (x) => x;
      return this.compute([field], (state) => get(state.field(field)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
      let values = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({static: true});
  var StateField = class {
    constructor(id, createF, updateF, compareF, spec) {
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i) => i.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create) {
      return [this, initField.of({field: this, create})];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = {lowest: 4, low: 3, default: 2, high: 1, highest: 0};
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({compartment: this, extension: content2});
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = Object.create(null);
      let newCompartments = new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id in facets) {
        let providers = facets[id], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map) {
      this.map = map;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
      return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch = str[i];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config2, doc2, selection, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, {base: base2, compartments} = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: {from: range.from, to: range.to, insert: text},
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json2, config2 = {}, fields) {
      if (!json2 || typeof json2.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json2, prop)) {
            let field = fields[prop], value = json2[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json2.doc,
        selection: EditorSelection.fromJSON(json2.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], new Map());
      let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
          phrase2 = map[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$")
            return "$";
          let n = +(i || 1);
          return !n || n > insert2.length ? m : insert2[n - 1];
        });
      return phrase2;
    }
    languageDataAt(name2, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values.push(result[name2]);
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let {text, from, length} = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak(text, start, false);
        if (cat(text.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key of Object.keys(config2)) {
        let value = config2[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults3)
      if (result[key] === void 0)
        result[key] = defaults3[key];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return {mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos};
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let {add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length} = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i < add2.length) {
        if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
          let range = add2[i++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({add: spill, filter, filterFrom, filterTo}));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let {mapped, pos} = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
      let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let open = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open, cursor.pointRank);
          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, open);
          open = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          break;
        pos = cursor.to;
        cursor.next();
      }
      return open;
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur2 = ranges[i];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
      for (let i = 0; i < set.chunk.length; i++)
        if (set.chunk[i].maxPoint <= 0)
          inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
      for (let i = 0; i < set.chunk.length; i++) {
        let known = inA.get(set.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
          shared.add(set.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur2 = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, {value, to, rank} = this.cursor;
      while (i < this.activeRank.length && this.activeRank[i] <= rank)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            if (this.cursor.from < from && this.cursor.to > from)
              trackExtra++;
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            if (this.cursor.from < from)
              trackExtra = 1;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        let openStart = 0;
        while (openStart < trackOpen.length && trackOpen[openStart] < from)
          openStart++;
        this.openStart = openStart + trackExtra;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
      array[i] = array[i + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
      array[i + 1] = array[i];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array.length; i++)
      if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array[i];
      }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n = 0;
    for (let i = 0; i < to; ) {
      if (string2.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string2, i);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string2.length)
        break;
      n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string2, i);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let {finish} = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id = top[COUNT] || 1;
      top[COUNT] = id + 1;
      return C + id.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i = 0; i < this.modules.length; i++)
          text += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (var i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  for (var i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (var code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc")
      name2 = "Escape";
    if (name2 == "Del")
      name2 = "Delete";
    if (name2 == "Left")
      name2 = "ArrowLeft";
    if (name2 == "Up")
      name2 = "ArrowUp";
    if (name2 == "Right")
      name2 = "ArrowRight";
    if (name2 == "Down")
      name2 = "ArrowDown";
    return name2;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = {left: 0, right: 0, top: 0, bottom: 0};
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return {left: x, right: x, top: rect.top, bottom: rect.bottom};
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur2 = dom; cur2; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY;
              movedY = cur2.scrollTop - start;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX;
              movedX = cur2.scrollLeft - start;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y = "nearest";
          }
        }
        if (top2)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = {preventScroll: true};
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top2 = stack[i++], left = stack[i++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name2, code) {
    let options = {key: name2, code: name2, keyCode: code, which: code, cancelable: true};
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
      return false;
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i = from; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children);
      for (let i = 0; i < children.length; i++)
        children[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i) {
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let {children} = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let {i: toI, off: toOff} = cur2.findPos(to, 1);
    let {i: fromI, off: fromOff} = cur2.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : {userAgent: "", vendor: "", platform: ""};
  var doc = typeof document != "undefined" ? document : {documentElement: {style: {}}};
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source) {
      if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return {from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling};
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i;
        off = end;
        i++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view = top2.editorView, text = view && view.state.doc, start = this.posAtStart;
      return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return this.length ? rect : flattenRect(rect, this.side > 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let {topView, text} = this.widget;
      if (!topView)
        return new DOMPos(text, Math.min(pos, text.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), (p) => new DOMPos(text, Math.min(p, text.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let {topView, text} = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let {topView, text} = this.widget;
      if (!topView)
        return textCoords(text, pos, side);
      return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
    canReuseDOM() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view, text, enterView, fromText) {
    if (view instanceof MarkView) {
      for (let child = view.dom.firstChild; child; child = child.nextSibling) {
        let desc = ContentView.get(child);
        if (!desc)
          return fromText(pos, side);
        let hasComp = contains(child, text);
        let len = desc.length + (hasComp ? text.nodeValue.length : 0);
        if (pos < len || pos == len && desc.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);
        pos -= len;
      }
      return enterView(view, view.length, -1);
    } else if (view.dom == text) {
      return fromText(pos, side);
    } else {
      return enterView(view, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view, text) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let pos = 0, hasComp = contains(child.dom, text);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text.nodeValue.length : child.length;
      }
    } else if (view.dom == text) {
      return Math.min(offset, text.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? {left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom} : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view, side) {
    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
      if (side < 0 ? index > 0 : index < parent.children.length) {
        let next = parent.children[index + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last = parent.dom.lastChild;
        if (last && last.nodeName == "BR")
          return last.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, {children} = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
      let child = children[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j = i; j > 0; j--) {
      let prev = children[j - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
      let next = children[j];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, {children} = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
        let child = view2.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if (!after && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  function attrsEq(a, b) {
    if (a == b)
      return true;
    if (!a || !b)
      return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key of keysA) {
      if (keysB.indexOf(key) == -1 || a[key] !== b[key])
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = null;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs))
          dom.removeAttribute(changed = name2);
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2]))
          dom.setAttribute(changed = name2, attrs[name2]);
    }
    return !!changed;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let {start, end} = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let {start, end} = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let {inclusiveStart: start, inclusiveEnd: end} = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return {start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block};
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
      ranges[last] = Math.max(ranges[last], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let {i, off} = this.childPos(at);
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({class: cls}, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, type) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer([]);
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (!openEnd)
        this.flushBuffer([]);
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let {value, lineBreak, done} = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer([]);
            this.curLine = null;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(0, openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let {type} = deco;
          if (type == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to ? 1 : 2;
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var ScrollTarget = class {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({map: (t2, ch) => t2.map(ch)});
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({combine: (values) => values.length ? values[0] : true});
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id, create, domEventHandlers, buildExtensions) {
      this.id = id;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const {eventHandlers, provide, decorations: deco} = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e) {
            logException(update.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
      let i = set.length, me = this;
      for (; i > 0; i--) {
        let range = set[i - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set.splice(i - 1, 1);
      }
      set.splice(i, 0, me);
      return set;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
    static create(view, state, transactions) {
      return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span = order[i];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i = 0; i < len; i++) {
      if (types[i] == 256) {
        let end = i + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i ? types[i - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] != 1;
        while (i < len && rtl == (types[i] != 1))
          i++;
        if (rtl) {
          for (let j = i; j > start; ) {
            let end = j, l = types[--j] != 2;
            while (j > start && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i, 0));
        }
      }
    } else {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] == 2;
        while (i < len && rtl == (types[i] == 2))
          i++;
        order.push(new BidiSpan(start, i, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re.exec(text)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update) {
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({fromA, toA}) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let {observer} = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? {node: observer.selectionRange.focusNode, written: false} : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i = changes.length - 1; ; i--) {
        let next = i >= 0 ? changes[i] : null;
        if (!next)
          break;
        let {fromA, toA, fromB, toB} = next;
        let {content: content2, breakAtStart, openStart, openEnd} = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let {i: toI, off: toOff} = cursor.findPos(toA, 1);
        let {i: fromI, off: fromOff} = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({preventScroll: true});
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let {view} = this, cursor = view.state.selection.main;
      let sel = getSelection(view.root);
      let {anchorNode, anchorOffset} = view.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    mayControlSelection() {
      let active = this.view.root.activeElement;
      return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let {i, off} = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i = this.children.length - 1; ; i--) {
        let child = this.children[i], start = off - child.breakAfter - child.length;
        if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start, side);
        off = start;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], {from, to} = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let {i} = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return {lineHeight, charWidth};
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d, i) => {
        let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      for (let i = allDeco.length; i < allDeco.length + 3; i++)
        this.dynamicDecorationMap[i] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let {range} = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let {left, right, top: top2, bottom} = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return {from: pos, to: pos, node: topNode, text: textNode};
    } else {
      for (; ; ) {
        let {parent} = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from = cView.posAtStart;
      return {from, to: from + cView.length, node: cView.dom, text: textNode};
    }
  }
  function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding)
      return Decoration.none;
    let {from, to, node, text: textNode} = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let {state} = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
      if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
        newTo = newFrom + text.length;
      else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
        newFrom = newTo - text.length;
      else
        return Decoration.none;
    } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({widget: new CompositionWidget(node, textNode, topView), inclusive: true}).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text, topView) {
      super();
      this.top = top2;
      this.text = text;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? {top: top2, left: rect.left, right: rect.right, bottom: rect.bottom} : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? {top: rect.top, left: rect.left, right: rect.right, bottom} : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return {node: parent, offset: 0};
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {node: parent, offset};
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return {node, offset: i + (after ? 1 : 0)};
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return {node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0};
  }
  function posAtCoords(view, {x, y}, precise, bias = -1) {
    var _a2;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, {docHeight} = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
    if (!element) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element = root.elementFromPoint(x, y);
      if (element && !view.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          ({offsetNode: node, offset} = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          ({startContainer: node, startOffset: offset} = range);
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({node, offset} = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
      return false;
    for (let cur2 = node; ; ) {
      let parent = cur2.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur2 = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view, {x: resolvedGoal, y: curY}, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start.assoc, void 0, goal);
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let atoms = view.state.facet(atomicRanges).map((f) => f(view));
    for (; ; ) {
      let moved = false;
      for (let set of atoms) {
        set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
          if (pos.from > from && pos.from < to) {
            pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.mouseSelection = null;
      for (let type in handlers) {
        let handler = handlers[type];
        view.contentDOM.addEventListener(type, (event) => {
          if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
            return;
          if (type == "keydown" && this.keydown(view, event))
            return;
          if (this.mustFlushObserver(event))
            view.observer.forceFlush();
          if (this.runCustomHandlers(type, view, event))
            event.preventDefault();
          else
            handler(view, event);
        }, handlerOptions[type]);
        this.registeredEvents.push(type);
      }
      if (browser.chrome && browser.chrome_version == 102) {
        view.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view.contentDOM.style.pointerEvents = "";
          }, 100);
        }, {passive: true});
      }
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
      var _a2;
      let handlers2;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers2 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({plugin: plugin.value, handlers: handlers2});
          for (let type in handlers2)
            if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
              this.registeredEvents.push(type);
              view.contentDOM.addEventListener(type, (event) => {
                if (!eventBelongsToEditor(view, event))
                  return;
                if (this.runCustomHandlers(type, view, event))
                  event.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type, view, event) {
      for (let set of this.customHandlers) {
        let handler = set.handlers[type];
        if (handler) {
          try {
            if (handler.call(set.plugin, event, view) || event.defaultPrevented)
              return true;
          } catch (e) {
            logException(view.state, e);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      this.lastScrollTop = view.scrollDOM.scrollTop;
      this.lastScrollLeft = view.scrollDOM.scrollLeft;
      for (let set of this.customHandlers) {
        let handler = set.handlers.scroll;
        if (handler) {
          try {
            handler.call(set.plugin, event, view);
          } catch (e) {
            logException(view.state, e);
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    {key: "Backspace", keyCode: 8, inputType: "deleteContentBackward"},
    {key: "Enter", keyCode: 13, inputType: "insertParagraph"},
    {key: "Delete", keyCode: 46, inputType: "deleteContentForward"}
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.style = style;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      let selection = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
      this.mustSelect = false;
    }
    update(update) {
      if (update.docChanged && this.dragging)
        this.dragging = this.dragging.map(update.changes);
      if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let {main} = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var handlerOptions = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let {state} = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return {range};
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
        return {
          changes: {from: line.from, insert: insert2},
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text.line(i++);
        return {
          changes: {from: range.from, to: range.to, insert: line.text},
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
      view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      view.inputState.lastEscPress = 0;
  };
  handlers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlerOptions.touchstart = handlerOptions.touchmove = {passive: true};
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3)
      return;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view, event);
    if (style) {
      let mustFocus = view.root.activeElement != view.contentDOM;
      if (mustFocus)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
  var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
      return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    return {pos, bias: findPositionSide(view, pos, event.clientX, event.clientY)};
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start, lastEvent = event;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
          lastEvent = null;
        }
      },
      get(event2, extend2, multiple) {
        let cur2;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur2 = last;
        else {
          cur2 = last = queryPos(view, event2);
          lastEvent = event2;
        }
        let range = rangeForClick(view, cur2.pos, cur2.bias, type);
        if (start.pos != cur2.pos && !extend2) {
          let startRange = rangeForClick(view, start.pos, start.bias, type);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend2)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range)))
          return removeRange(startSel, range);
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  function removeRange(sel, range) {
    for (let i = 0; ; i++) {
      if (sel.ranges[i].eq(range))
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
  }
  handlers.dragstart = (view, event) => {
    let {selection: {main}} = view.state;
    let {mouseSelection} = view.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    event.preventDefault();
    let {mouseSelection} = view.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {from: mouseSelection.dragging.from, to: mouseSelection.dragging.to} : null;
    let ins = {from: dropPos, insert: text};
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: {anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1)},
      userEvent: del ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = (view, event) => {
    if (!event.dataTransfer)
      return;
    if (view.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly)
      return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let {from} of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({from: line.from, to: Math.min(state.doc.length, line.to + 1)});
        }
        upto = line.number;
      }
      linewise = true;
    }
    return {text: content2.join(state.lineBreak), ranges, linewise};
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    let {text, ranges, linewise} = copiedRange(view.state);
    if (!text && !linewise)
      return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text);
    } else {
      captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  function updateForFocusChange(view) {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused)
        view.update([]);
    }, 10);
  }
  handlers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  handlers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  handlers.compositionstart = handlers.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android)
      view.observer.flushSoon();
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
        view.update([]);
    }, 50);
  };
  handlers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h = knownHeights[i];
          if (h < 0)
            i++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length, top2, height, type) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i = changes.length - 1; i >= 0; i--) {
        let {fromA, toA, fromB, toB} = changes[i];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split = nodes[i - 1];
            if (split.break)
              nodes.splice(--i, 1, split.left, null, split.right);
            else
              nodes.splice(--i, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, type) {
      super(length, height);
      this.type = type;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      if (from <= offset + this.length && to >= offset)
        f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    lines(doc2, offset) {
      let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
      return {firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1)};
    }
    blockAt(height, doc2, top2, offset) {
      let {firstLine, lastLine, lineHeight} = this.lines(doc2, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let {from, length} = doc2.line(firstLine + line);
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc2, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, doc2, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let {from: from2, to} = doc2.lineAt(value);
        return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
      }
      let {firstLine, lineHeight} = this.lines(doc2, offset);
      let {from, length, number: number2} = doc2.lineAt(value);
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let {firstLine, lineHeight} = this.lines(doc2, offset);
      for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        let line = doc2.lineAt(pos);
        if (pos == from)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        let wasChanged = oracle.heightChanged;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc2, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, doc2, top2, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let {left, right} = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let {from, to} = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size) {
      this.from = from;
      this.to = to;
      this.size = size;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA = a[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({widget: new LineGapWidget(this.size, wrapping)}).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = {left: 0, right: window.innerWidth, top: 0, bottom: 0};
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], {main} = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main.head : main.anchor;
        if (!viewports.some(({from, to}) => pos >= from && pos <= to)) {
          let {from, to} = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
      this.contentDOMHeight = dom.clientHeight;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = dom.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let {lineHeight, charWidth} = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map = this.heightMap, doc2 = this.state.doc, {visibleTop, visibleBottom} = this;
      let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTarget) {
        let {head} = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({from, to}, bias = 0) {
      if (!this.inView)
        return true;
      let {top: top2} = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
      let {bottom} = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
      let {visibleTop, visibleBottom} = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
        }
        gaps.push(gap);
      };
      for (let line of this.viewportLines) {
        if (line.length < doubleMargin)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          continue;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (this.pixelViewport.left - marginWidth) / totalWidth;
            right = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({from, to});
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({from: pos, to: from2});
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({from: pos, to});
      total += to - pos;
    }
    return {total, ranges};
  }
  function findPosition({total, ranges}, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let {from, to} = ranges[i], size = to - from;
      if (dist <= size)
        return from + dist;
      dist -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let {from, to} of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc2, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({from, to}) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return {from, to, top: top2, bottom, domTop: 0, domBottom: 0};
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({combine: (strs) => strs.join(" ")});
  var darkTheme = /* @__PURE__ */ Facet.define({combine: (values) => values.indexOf(true) > -1});
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = {"&light": "." + baseLightID, "&dark": "." + baseDarkID};
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&.cm-editor": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {caretColor: "black"},
    "&dark .cm-content": {caretColor: "white"},
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
      zIndex: -1,
      contain: "size style"
    },
    ".cm-selectionBackground": {
      position: "absolute"
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      zIndex: 100,
      contain: "size style",
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {"0%": {}, "50%": {opacity: 0}, "100%": {}},
    "@keyframes cm-blink2": {"0%": {}, "50%": {opacity: 0}, "100%": {}},
    ".cm-cursor, .cm-dropCursor": {
      position: "absolute",
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": {backgroundColor: "#cceeff44"},
    "&dark .cm-activeLine": {backgroundColor: "#99eeff33"},
    "&light .cm-specialChar": {color: "red"},
    "&dark .cm-specialChar": {color: "#f78"},
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var DOMChange = class {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      let {impreciseHead: iHead, impreciseAnchor: iAnchor} = view.docView;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view, domChange) {
    let change;
    let {newSel} = domChange, sel = view.state.selection.main;
    if (domChange.bounds) {
      let {from, to} = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus || !view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = {from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to)};
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString())) {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {from: sel.from, to: sel.to, insert: Text.of([" "])};
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {from: sel.from, to: sel.to, insert: Text.of([" "])};
    }
    if (change) {
      let startState = view.state;
      if (browser.ios && view.inputState.flushIOSKey(view))
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
        return true;
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          let replaced = view.state.sliceDoc(change.from, change.to);
          let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
          let offset = sel.to - change.to, size = sel.to - sel.from;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return {changes, range: mainSel || range.map(changes)};
            let to = range.to - offset, from = to - replaced.length;
            if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
              return {range};
            let rangeChanges = startState.changes({from, to, insert: change.insert}), selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, {scrollIntoView: true, userEvent});
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({selection: newSel, scrollIntoView: scrollIntoView3, userEvent});
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return {from, toA, toB};
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let {anchorNode, anchorOffset, focusNode, focusOffset} = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resize = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resize = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resize.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runScrollHandlers(this.view, e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let {view} = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let {view} = this;
      let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
      if (!range || this.selectionRange.eq(range))
        return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            if (!this.flush() && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({from, to} = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return {from, to, typeOver};
    }
    readChange() {
      let {from, to, typeOver} = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      return new DOMChange(this.view, from, to, typeOver);
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange)
        return false;
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return {from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue};
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return {anchorNode, anchorOffset, focusNode, focusOffset};
  }
  var EditorView = class {
    constructor(config2 = {}) {
      this.plugins = [];
      this.pluginMap = new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config2.parent)
        config2.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let {main} = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e of tr.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value;
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update);
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force)
          dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let {scrollHeight, scrollTop, clientHeight} = this.scrollDOM;
      let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
      try {
        for (let i = 0; ; i++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let refBlock = this.viewState.lineBlockAtHeight(refHeight);
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m = measuring[i2];
                if (m.write)
                  m.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrolled = true;
            } else {
              let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
              if (diff > 1 || diff < -1) {
                this.scrollDOM.scrollTop += diff;
                scrolled = true;
              }
            }
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom};
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), {eventHandlers: handlers2});
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({class: "cm-lineWrapping"});
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty)
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        let entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source = sources[i], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift2) {
    if (event.altKey)
      name2 = "Alt-" + name2;
    if (event.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({enables: handleKeyEvents});
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
      Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is;
      else if (current != is)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key, command2, preventDefault) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            run: [(view) => {
              let ourObj = storedPrefix = {view, prefix, scope};
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []});
      if (command2)
        binding.run.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = {preventDefault: false, run: []};
          for (let key in scopeObj)
            scopeObj[key].run.push(b.any);
        }
      let name2 = b[platform] || b.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add2(scope, name2, b.run, b.preventDefault);
        if (b.shift)
          add2(scope, "Shift-" + name2, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map, event, view, scope) {
    let name2 = keyName(event);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let ran = new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view, event))
              return true;
          }
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
        return true;
      if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
          return true;
        else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
          return true;
      }
      if (runFor(scopeObj._any))
        return true;
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      drawSelectionPlugin,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  var Piece = class {
    constructor(left, top2, width, height, className) {
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
      this.className = className;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width >= 0)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
  };
  var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.rangePieces = [];
      this.cursors = [];
      this.measureReq = {read: this.readPos.bind(this), write: this.drawSel.bind(this)};
      this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.selectionLayer.className = "cm-selectionLayer";
      this.selectionLayer.setAttribute("aria-hidden", "true");
      this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.cursorLayer.className = "cm-cursorLayer";
      this.cursorLayer.setAttribute("aria-hidden", "true");
      view.requestMeasure(this.measureReq);
      this.setBlinkRate();
    }
    setBlinkRate() {
      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
      let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
      if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
        this.view.requestMeasure(this.measureReq);
      if (update.transactions.some((tr) => tr.scrollIntoView))
        this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      if (confChanged)
        this.setBlinkRate();
    }
    readPos() {
      let {state} = this.view, conf = state.facet(selectionConfig);
      let rangePieces = state.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
      let cursors = [];
      for (let r of state.selection.ranges) {
        let prim = r == state.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(this.view, r, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return {rangePieces, cursors};
    }
    drawSel({rangePieces, cursors}) {
      if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
        this.selectionLayer.textContent = "";
        for (let p of rangePieces)
          this.selectionLayer.appendChild(p.draw());
        this.rangePieces = rangePieces;
      }
      if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
        let oldCursors = this.cursorLayer.children;
        if (oldCursors.length !== cursors.length) {
          this.cursorLayer.textContent = "";
          for (const c of cursors)
            this.cursorLayer.appendChild(c.draw());
        } else {
          cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
        }
        this.cursors = cursors;
      }
    }
    destroy() {
      this.selectionLayer.remove();
      this.cursorLayer.remove();
    }
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": {backgroundColor: "transparent !important"},
      "&::selection": {backgroundColor: "transparent !important"}
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return {left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop};
  }
  function wrappedLine(view, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
      return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new Piece(left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01, "cm-selectionBackground");
    }
    function pieces({top: top2, bottom, horizontal}) {
      let pieces2 = [];
      for (let i = 0; i < horizontal.length; i += 2)
        pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r of view.visibleRanges)
        if (r.to > start && r.from < end) {
          for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start, from2 == null, end, to2 == null, view.textDirection);
      return {top: top2, bottom, horizontal};
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return {top: y, bottom: y, horizontal: []};
    }
  }
  function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view);
    return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
  }
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = {read: this.readPos.bind(this), write: this.drawCursor.bind(this)};
    }
    update(update) {
      var _a2;
      let cursorPos = update.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let pos = this.view.state.field(dropCursorPos);
      let rect = pos != null && this.view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = this.view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        if (pos) {
          this.cursor.style.left = pos.left + "px";
          this.cursor.style.top = pos.top + "px";
          this.cursor.style.height = pos.height + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({effects: setDropCursorPos.of(pos)});
    }
  }, {
    eventHandlers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({x: event.clientX, y: event.clientY}));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m = re.exec(cursor.value))
          f(pos + m.index, m);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let {from, to} of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from)
        result[result.length - 1].to = to;
      else
        result.push({from, to});
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config2) {
      const {regexp, decoration, decorate, boundary, maxLength = 1e3} = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view, from, add2) => {
          let deco = decoration(match, view, from);
          if (deco)
            add2(from, from + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder(), add2 = build.add.bind(build);
      for (let {from, to} of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add2));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f, _t, from, to) => {
          if (to > update.view.viewport.from && from < update.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start = from;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m;
          let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
              this.addMatch(m, view, m.index + fromLine.from, add2);
          } else {
            iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add2));
          }
          deco = deco.update({filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges});
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let {doc: doc2} = view.state;
            let code = codePointAt(m[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)});
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({widget: new SpecialCharWidget(conf, code)}));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({class: "cm-activeLine"});
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
      let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        let start = findColumn(line.text, startCol, state.tabSize, true);
        if (start < 0) {
          ranges.push(EditorSelection.cursor(line.to));
        } else {
          let end = findColumn(line.text, endCol, state.tabSize);
          ranges.push(EditorSelection.range(line.from + start, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
  }
  function getPos(view, event) {
    let offset = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return {line: line.number, col, off};
  }
  function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
      return null;
    return {
      update(update) {
        if (update.docChanged) {
          let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
          let newLine = update.state.doc.lineAt(newStart);
          start = {line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length)};
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view.state, start, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
  }
  var keys = {
    Alt: [18, (e) => e.altKey],
    Control: [17, (e) => e.ctrlKey],
    Shift: [16, (e) => e.shiftKey],
    Meta: [91, (e) => e.metaKey]
  };
  var showCrosshair = {style: "cursor: crosshair"};
  function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventHandlers: {
        keydown(e) {
          this.set(e.keyCode == code || getter(e));
        },
        keyup(e) {
          if (e.keyCode == code || !getter(e))
            this.set(false);
        },
        mousemove(e) {
          this.set(getter(e));
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view) => {
        var _a2;
        return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips = input.filter((x) => x);
      if (input === this.input) {
        for (let t2 of this.tooltipViews)
          if (t2.update)
            t2.update(update);
        return false;
      }
      let tooltipViews = [];
      for (let i = 0; i < tooltips.length; i++) {
        let tip = tooltips[i], known = -1;
        if (!tip)
          continue;
        for (let i2 = 0; i2 < this.tooltips.length; i2++) {
          let other = this.tooltips[i2];
          if (other && other.create == tip.create)
            known = i2;
        }
        if (known < 0) {
          tooltipViews[i] = this.createTooltipView(tip);
        } else {
          let tooltipView = tooltipViews[i] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t2 of this.tooltipViews)
        if (tooltipViews.indexOf(t2) < 0) {
          t2.dom.remove();
          (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
        }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace(view) {
    let {win} = view;
    return {top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth};
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.inView = true;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = {read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this};
      this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, {threshold: [1]}) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update) {
      if (update.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews)
          t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews)
          this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip) {
      let tooltipView = tooltip.create(this.view);
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      this.container.appendChild(tooltipView.dom);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      return tooltipView;
    }
    destroy() {
      var _a2, _b;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor = this.view.dom.getBoundingClientRect();
      return {
        editor,
        parent: this.parent ? this.container.getBoundingClientRect() : editor,
        pos: this.manager.tooltips.map((t2, i) => {
          let tv = this.manager.tooltipViews[i];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({dom}) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
      };
    }
    writeMeasure(measured) {
      let {editor, space} = measured;
      let others = [];
      for (let i = 0; i < this.manager.tooltips.length; i++) {
        let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], {dom} = tView;
        let pos = measured.pos[i], size = measured.size[i];
        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = size.bottom - size.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = !!tooltip.above;
        if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
          above = !above;
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others)
            if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
              top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = top2 - measured.parent.top + "px";
          dom.style.left = left - measured.parent.left + "px";
        } else {
          dom.style.top = top2 + "px";
          dom.style.left = left + "px";
        }
        if (arrow)
          arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
        if (tView.overlap !== true)
          others.push({left, top: top2, right, bottom: top2 + height});
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventHandlers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = {x: 0, y: 0};
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class {
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
    static create(view) {
      return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned(space) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space);
      }
    }
    update(update) {
      this.manager.update(update);
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    let tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = {x: 0, y: 0, target: view.dom, time: 0};
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let {lastMove} = this;
      let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null)
        return;
      let posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
        return;
      let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = {pos};
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result)
              this.view.dispatch({effects: this.setHover.of(result)});
          }
        }, (e) => logException(this.view.state, e, "hover tooltip"));
      } else if (open) {
        this.view.dispatch({effects: this.setHover.of(open)});
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = {x: event.clientX, y: event.clientY, target: event.target, time: Date.now()};
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let tooltip = this.active;
      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
        let {pos} = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({effects: this.setHover.of(null)});
          this.pending = null;
        }
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active && !isInTooltip(e.relatedTarget))
        this.view.dispatch({effects: this.setHover.of(null)});
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  function isInTooltip(elt) {
    for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
      if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
        return true;
    return false;
  }
  function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
      if (dist <= margin)
        return true;
    }
    return false;
  }
  function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
          return null;
        if (value && tr.docChanged) {
          let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null)
            return null;
          let copy = Object.assign(Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null)
            copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = null;
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
      showHoverTooltipHost
    ];
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c of configs) {
        topContainer = topContainer || c.topContainer;
        bottomContainer = bottomContainer || c.bottomContainer;
      }
      return {topContainer, bottomContainer};
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      } else {
        for (let p of this.panels)
          if (p.update)
            p.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && {top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin()};
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels)
        if (p.destroy && panels.indexOf(p) < 0)
          p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        let text;
        if (Array.isArray(line.type)) {
          for (let b of line.type)
            if (b.type == BlockType.Text) {
              text = b;
              break;
            }
        } else {
          text = line.type == BlockType.Text ? line : void 0;
        }
        if (!text)
          continue;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text, classSet);
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0)
            g.destroy();
        }
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? {left: value.dom.offsetWidth} : {right: value.dom.offsetWidth};
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c = marker.elementClass;
          if (c)
            cls += " " + c;
          for (let i = iOld; i < this.markers.length; i++)
            if (this.markers[i].compare(marker)) {
              skipTo = i;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].compare(b[i]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, {formatNumber: String, domEventHandlers: {}}, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event in b) {
            let exists = result[event], add2 = b[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.openedBy = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.group = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.contextHash = new NodeProp({perNode: true});
  NodeProp.lookAhead = new NodeProp({perNode: true});
  NodeProp.mounted = new NodeProp({perNode: true});
  var noProps = Object.create(null);
  var NodeType = class {
    constructor(name2, props, id, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map) {
      let direct = Object.create(null);
      for (let prop in map)
        for (let name2 of prop.split(" "))
          direct[name2] = map[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", Object.create(null), 0, 8);
  var NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i = 0; i < types2.length; i++)
        if (types2[i].id != i)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add2 = source(type);
          if (add2) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add2[0].id] = add2[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  var CachedNode = new WeakMap();
  var CachedInnerNode = new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let {enter, leave, from = 0, to = this.length} = spec;
      for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c.type.isAnonymous)
            leave(c);
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id in this.props)
          result.push([+id, this.props[id]]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set) {
      this.buffer = buffer;
      this.length = length;
      this.set = set;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let {buffer} = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i = startI, j = 0; i < endI; ) {
        copy[j++] = b[i++];
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - startI;
      }
      return new TreeBuffer(copy, to - from, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from, index, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let {children, positions} = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start = positions[i] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start, i, parent);
            let inner = new TreeNode(next, start, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let {from, to} of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null) {
      while (!cur2.type.is(before))
        if (!cur2.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  };
  var BufferNode = class {
    constructor(context, _parent, index) {
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let {buffer} = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let {buffer} = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let {buffer} = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let {buffer} = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let {buffer} = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  var TreeCursor = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let {start, buffer} = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let {buffer} = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let {buffer} = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, {buffer} = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({index, parent} = buffer);
      } else {
        ({index, _parent: parent} = this._tree);
      }
      for (; parent; {index, _parent: parent} = parent) {
        if (index > -1)
          for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan:
          for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let {buffer} = this.buffer, {types: types2} = buffer.set;
      for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context, i);
        let type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context[i] && context[i] != type.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let {buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length} = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let {id, start, end, size} = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id >= minRepeatType ? id : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = {size: 0, start: 0, skip: 0};
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size;
            result.start = start;
            result.skip = skip;
            skip += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start = nodeStart2;
          size += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let {id, start, end, size} = cursor;
      cursor.next();
      if (size >= 0 && id < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(balanceType, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var stoppedInner = new NodeProp({perNode: true});

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set, base2, modified) {
      this.set = set;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set = [], tag = new Tag(set, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config2 of configs)
            set.push(Modifier.get(parent, config2));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map = Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map[tag.id] = style.class;
    }
    let {scope, all = null} = options || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
      let {type, from: start, to: end} = cursor;
      if (start >= to || end <= from)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(cursor.from, cls);
      if (rule.opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i = 0, pos = start; ; i++) {
          let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(to, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from)
            continue;
          if (cursor.from >= to)
            break;
          this.highlightRange(cursor, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    {tag: tags.link, class: "tok-link"},
    {tag: tags.heading, class: "tok-heading"},
    {tag: tags.emphasis, class: "tok-emphasis"},
    {tag: tags.strong, class: "tok-strong"},
    {tag: tags.keyword, class: "tok-keyword"},
    {tag: tags.atom, class: "tok-atom"},
    {tag: tags.bool, class: "tok-bool"},
    {tag: tags.url, class: "tok-url"},
    {tag: tags.labelName, class: "tok-labelName"},
    {tag: tags.inserted, class: "tok-inserted"},
    {tag: tags.deleted, class: "tok-deleted"},
    {tag: tags.literal, class: "tok-literal"},
    {tag: tags.string, class: "tok-string"},
    {tag: tags.number, class: "tok-number"},
    {tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2"},
    {tag: tags.variableName, class: "tok-variableName"},
    {tag: tags.local(tags.variableName), class: "tok-variableName tok-local"},
    {tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition"},
    {tag: tags.special(tags.variableName), class: "tok-variableName2"},
    {tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition"},
    {tag: tags.typeName, class: "tok-typeName"},
    {tag: tags.namespace, class: "tok-namespace"},
    {tag: tags.className, class: "tok-className"},
    {tag: tags.macroName, class: "tok-macroName"},
    {tag: tags.propertyName, class: "tok-propertyName"},
    {tag: tags.operator, class: "tok-operator"},
    {tag: tags.comment, class: "tok-comment"},
    {tag: tags.meta, class: "tok-meta"},
    {tag: tags.invalid, class: "tok-invalid"},
    {tag: tags.punctuation, class: "tok-punctuation"}
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  }
  var Language = class {
    constructor(data, parser2, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", {get() {
          return syntaxTree(this);
        }});
      this.parser = parser2;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return languageDataFacetAt(state, pos, side) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{from: 0, to: state.doc.length}];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({from, to: from + tree.length});
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({from: r.from + from, to: r.to + from});
            else
              result.push({from, to: from + tree.length});
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch = tree.children[i];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state, pos, side) {
    let topLang = state.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  var LRLanguage = class extends Language {
    constructor(data, parser2, name2) {
      super(data, parser2, [], name2);
      this.parser = parser2;
    }
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
      }), spec.name);
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2, length = doc2.length) {
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser2;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser2, state, viewport) {
      return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let {fragments, tree, treeLen, viewport, skipped} = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({fromA, toA, fromB, toB}));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = {from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1)};
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to)
              skipped.push({from, to});
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let {from, to} = this.skipped[i];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({from, to});
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser2 = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser2;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{fromA: from, toA: to, fromB: from, toB: to}]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, {from: 0, to: vpTo});
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(() => {
        idle = requestIdleCallback(callback, {timeout: 500 - 100});
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let {state} = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let {state, viewport: {to: vpTo}} = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({effects: Language.setState.of(new LanguageState(field.context))});
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: {focus() {
      this.scheduleWork();
    }}
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? {"data-language": lang.name} : {};
      })
    ]
  });
  var LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      if (!/^(?: +|\t+)$/.test(values[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return values[0];
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (let i = 0; i < cols; i++)
      result += " ";
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let {simulateBreak, simulateDoubleBreak} = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return {text: "", from: pos};
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return {text: line.text.slice(simulateBreak - line.from), from: simulateBreak};
        else
          return {text: line.text.slice(0, simulateBreak - line.from), from: line.from};
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let {text, from} = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let {text, from} = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let {text, from} = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  function continuedIndent({except, units = 1} = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc2 = tr.newDoc, {head} = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr;
      let {state} = tr, last = -1, changes = [];
      for (let {head: head2} of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last)
          continue;
        last = line2.from;
        let indent = getIndentation(state, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state, indent);
        if (cur2 != norm)
          changes.push({from: line2.from, to: line2.from + cur2.length, insert: norm});
      }
      return changes.length ? [tr, {changes, sequential: true}] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? {from: first.to, to: last.type.isError ? node.to : last.from} : null;
  }
  function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
      return null;
    let inner = tree.resolveInner(end, 1);
    let found = null;
    for (let cur2 = inner; cur2; cur2 = cur2.parent) {
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state);
        if (value && value.from <= end && value.from >= start && value.to > end)
          found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
      let result = service(state, lineStart, lineEnd);
      if (result)
        return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
  }
  function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? void 0 : {from, to};
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
  function selectedLines(view) {
    let lines = [];
    for (let {head} of view.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head))
        continue;
      lines.push(view.lineBlockAt(head));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e of tr.effects) {
        if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
          folded = folded.update({add: [foldWidget.range(e.value.from, e.value.to)]});
        else if (e.is(unfoldEffect))
          folded = folded.update({
            filter: (from, to) => e.value.from != from || e.value.to != to,
            filterFrom: e.value.from,
            filterTo: e.value.to
          });
      }
      if (tr.selection) {
        let onSelection = false, {head} = tr.selection.main;
        folded.between(head, head, (a, b) => {
          if (a < head && b > head)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head,
            filterTo: head,
            filter: (a, b) => b <= head || a >= head
          });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f),
    toJSON(folded, state) {
      let ranges = [];
      folded.between(0, state.doc.length, (from, to) => {
        ranges.push(from, to);
      });
      return ranges;
    },
    fromJSON(value) {
      if (!Array.isArray(value) || value.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let ranges = [];
      for (let i = 0; i < value.length; ) {
        let from = value[i++], to = value[i++];
        if (typeof from != "number" || typeof to != "number")
          throw new RangeError("Invalid JSON for fold state");
        ranges.push(foldWidget.range(from, to));
      }
      return Decoration.set(ranges, true);
    }
  });
  function findFold(state, from, to) {
    var _a2;
    let found = null;
    (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
      if (!found || found.from > from2)
        found = {from: from2, to: to2};
    });
    return found;
  }
  function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => {
      if (a == from && b == to)
        found = true;
    });
    return found;
  }
  function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view) => {
    for (let line of selectedLines(view)) {
      let range = foldable(view.state, line.from, line.to);
      if (range) {
        view.dispatch({effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])});
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view) => {
    if (!view.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view)) {
      let folded = findFold(view.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
      view.dispatch({effects});
    return effects.length > 0;
  };
  function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view) => {
    let {state} = view, effects = [];
    for (let pos = 0; pos < state.doc.length; ) {
      let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
      if (range)
        effects.push(foldEffect.of(range));
      pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
      view.dispatch({effects: maybeEnable(view.state, effects)});
    return !!effects.length;
  };
  var unfoldAll = (view) => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => {
      effects.push(unfoldEffect.of({from, to}));
    });
    view.dispatch({effects});
    return true;
  };
  var foldKeymap = [
    {key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode},
    {key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode},
    {key: "Ctrl-Alt-[", run: foldAll},
    {key: "Ctrl-Alt-]", run: unfoldAll}
  ];
  var defaultConfig = {
    placeholderDOM: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view) {
      let {state} = view, conf = state.facet(foldConfig);
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          view.dispatch({effects: unfoldEffect.of(folded)});
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick);
      let element = document.createElement("span");
      element.textContent = conf.placeholderText;
      element.setAttribute("aria-label", state.phrase("folded code"));
      element.title = state.phrase("unfold");
      element.className = "cm-foldPlaceholder";
      element.onclick = onclick;
      return element;
    }
  }()});
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view) {
        this.from = view.viewport.from;
        this.markers = this.buildMarkers(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
          this.markers = this.buildMarkers(update.view);
      }
      buildMarkers(view) {
        let builder = new RangeSetBuilder();
        for (let line of view.viewportLineBlocks) {
          let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let {domEventHandlers} = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view) {
          var _a2;
          return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({effects: unfoldEffect.of(folded)});
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({effects: foldEffect.of(range)});
            return true;
          }
          return false;
        }})
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, {tag: null}))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update.changes);
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let {from, to} of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({class: style})));
        }, from, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {backgroundColor: "#328c8252"},
    "&.cm-focused .cm-nonmatchingBracket": {backgroundColor: "#bb555544"}
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({class: "cm-matchingBracket"});
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({class: "cm-nonmatchingBracket"});
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end)
      decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty)
          continue;
        let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match)
          decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index + dir]];
    }
    return null;
  }
  function matchBrackets(state, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches = matchingNodes(cur2.type, dir, brackets);
      if (matches && cur2.from < cur2.to)
        return matchMarkedBrackets(state, pos, dir, cur2, matches, brackets);
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = {from: token.from, to: token.to};
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            return {start: firstToken, end: {from: cursor.from, to: cursor.to}, matched: true};
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            if (depth == 0)
              return {
                start: firstToken,
                end: cursor.from == cursor.to ? void 0 : {from: cursor.from, to: cursor.to},
                matched: false
              };
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return {start: firstToken, matched: false};
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = {from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos};
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0)
        distance += text.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return {start: startToken, end: {from: basePos + pos2, to: basePos + pos2 + 1}, matched: found >> 1 == bracket2 >> 1};
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text.length;
    }
    return iter.done ? {start: startToken, matched: false} : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({[name2]: tag})]
    });
    typeArray.push(type);
    return type.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let config2 = getConfig(target.state);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({state, dispatch}) => {
      if (state.readOnly)
        return false;
      let tr = f(option, state);
      if (!tr)
        return false;
      dispatch(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos = state.selection.main.head) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, {open, close}, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: {pos: from - spaceBefore, margin: spaceBefore && 1},
        close: {pos: to + spaceAfter, margin: spaceAfter && 1}
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last].to > fromLine.from)
        ranges[last].to = toLine.to;
      else
        ranges.push({from: fromLine.from, to: toLine.to});
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c) => c))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 && !comments.every((c) => c)) {
      return {changes: state.changes(ranges.map((range, i) => {
        if (comments[i])
          return [];
        return [{from: range.from, insert: tokens[i].open + " "}, {from: range.to, insert: " " + tokens[i].close}];
      }))};
    } else if (option != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token = tokens[i], {open, close} = comment2;
          changes.push({from: open.pos - token.open.length, to: open.pos + open.margin}, {from: close.pos - close.margin, to: close.pos + token.close.length});
        }
      return {changes};
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let {from, to} of ranges) {
      let startI = lines.length, minIndent = 1e9;
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let token = getConfig(state, pos).line;
          if (!token)
            continue;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({line, comment: comment2, token, indent, empty: empty2, single: false});
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let {line, token, indent, empty: empty2, single} of lines)
        if (single || !empty2)
          changes.push({from: line.from + indent, insert: token + " "});
      let changeSet = state.changes(changes);
      return {changes: changeSet, selection: state.selection.map(changeSet, 1)};
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let {line, comment: comment2, token} of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to = from + token.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({from, to});
        }
      return {changes};
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500
      }, {minDepth: Math.max, newGroupDelay: Math.min});
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to) => end = to);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
        let other = from == 0 ? state.undone : state.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false)
        return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event)
        state = state.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
      else if (tr.selection)
        state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state = state.isolate();
      return state;
    },
    toJSON(value) {
      return {done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON())};
    },
    fromJSON(json2) {
      return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e, view) {
          let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({state, dispatch}) {
      if (!selection && state.readOnly)
        return false;
      let historyState = state.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state, selection);
      if (!tr)
        return false;
      dispatch(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json2) {
      return new HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from = ranges[i++], to = ranges[i++];
        if (t2 >= from && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
        return this;
      return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1];
      if (selection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({side, rest: popSelection(branch)}),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({side, rest}),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    {key: "Mod-z", run: undo, preventDefault: true},
    {key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true},
    {linux: "Ctrl-Shift-z", run: redo, preventDefault: true},
    {key: "Mod-u", run: undoSelection, preventDefault: true},
    {key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true}
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection) {
    return state.update({selection, scrollIntoView: true, userEvent: "select"});
  }
  function moveSel({state, dispatch}, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection))
      return false;
    dispatch(setSel(state, selection));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
      newPos = forward ? match.end.to : match.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function pageHeight(view) {
    return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
  }
  function cursorByPage(view, forward) {
    let {state} = view, selection = updateSel(state.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
      return false;
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
      effect = EditorView.scrollIntoView(selection.main.head, {y: "start", yMargin: startPos.top - scrollRect.top});
    view.dispatch(setSel(state, selection), {effects: effect});
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state, dispatch, extend2) {
    let found = false, selection = updateSel(state.selection, (range) => {
      let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
      if (!matching || !matching.end)
        return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch(setSel(state, selection));
    return true;
  }
  var cursorMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, false);
  function extendSel(view, how) {
    let selection = updateSel(view.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, pageHeight(view)));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  var cursorDocStart = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: 0}));
    return true;
  };
  var cursorDocEnd = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.doc.length}));
    return true;
  };
  var selectDocStart = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.selection.main.anchor, head: 0}));
    return true;
  };
  var selectDocEnd = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.selection.main.anchor, head: state.doc.length}));
    return true;
  };
  var selectAll = ({state, dispatch}) => {
    dispatch(state.update({selection: {anchor: 0, head: state.doc.length}, userEvent: "select"}));
    return true;
  };
  var selectLine = ({state, dispatch}) => {
    let ranges = selectedLineBlocks(state).map(({from, to}) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({selection: EditorSelection.create(ranges), userEvent: "select"}));
    return true;
  };
  var selectParentSyntax = ({state, dispatch}) => {
    let selection = updateSel(state.selection, (range) => {
      var _a2;
      let context = syntaxTree(state).resolveInner(range.head, 1);
      while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context = context.parent;
      return EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state, selection));
    return true;
  };
  var simplifySelection = ({state, dispatch}) => {
    let cur2 = state.selection, selection = null;
    if (cur2.ranges.length > 1)
      selection = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection)
      return false;
    dispatch(setSel(state, selection));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event = "delete.selection", {state} = target;
    let changes = state.changeByRange((range) => {
      let {from, to} = range;
      if (from == to) {
        let towards = by(from);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? {range} : {changes: {from, to}, range: EditorSelection.cursor(from)};
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let {state} = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return targetPos;
  });
  var deleteCharBackward = (view) => deleteByChar(view, false);
  var deleteCharForward = (view) => deleteByChar(view, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
    let pos = start, {state} = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != start)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
    let lineEnd = view.lineBlockAt(pos).to;
    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
  });
  var deleteToLineStart = (view) => deleteBy(view, (pos) => {
    let lineStart = view.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
  });
  var splitLine = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: {from: range.from, to: range.to, insert: Text.of(["", ""])},
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, {scrollIntoView: true, userEvent: "input"}));
    return true;
  };
  var transposeChars = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length)
        return {range};
      let pos = range.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: {from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))},
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state.update(changes, {scrollIntoView: true, userEvent: "move.character"}));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
      let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from)
        endLine = state.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({from: startLine.from, to: endLine.to, ranges: [range]});
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size = nextLine.length + 1;
      if (forward) {
        changes.push({from: block.to, to: nextLine.to}, {from: block.from, insert: nextLine.text + state.lineBreak});
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      } else {
        changes.push({from: nextLine.from, to: block.from}, {from: block.to, insert: state.lineBreak + nextLine.text});
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({state, dispatch}) => moveLine(state, dispatch, false);
  var moveLineDown = ({state, dispatch}) => moveLine(state, dispatch, true);
  function copyLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward)
        changes.push({from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak});
      else
        changes.push({from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to)});
    }
    dispatch(state.update({changes, scrollIntoView: true, userEvent: "input.copyline"}));
    return true;
  }
  var copyLineUp = ({state, dispatch}) => copyLine(state, dispatch, false);
  var copyLineDown = ({state, dispatch}) => copyLine(state, dispatch, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let {state} = view, changes = state.changes(selectedLineBlocks(state).map(({from, to}) => {
      if (from > 0)
        from--;
      else if (to < state.doc.length)
        to++;
      return {from, to};
    }));
    let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
    view.dispatch({changes, selection, scrollIntoView: true, userEvent: "delete.line"});
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return {from: pos, to: pos};
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
      return {from: before.to, to: after.from};
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({state, dispatch}) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        let {from, to} = range, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, {simulateBreak: from, simulateDoubleBreak: !!explode});
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({from, to} = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state, indent)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: {from, to, insert: Text.of(insert2)},
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, {scrollIntoView: true, userEvent: "input"}));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  var indentSelection = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let updated = Object.create(null);
    let context = new IndentContext(state, {overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    }});
    let changes = changeBySelectedLine(state, (line, changes2, range) => {
      let indent = getIndentation(context, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm || range.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({from: line.from, to: line.from + cur2.length, insert: norm});
      }
    });
    if (!changes.changes.empty)
      dispatch(state.update(changes, {userEvent: "indent"}));
    return true;
  };
  var indentMore = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({from: line.from, insert: state.facet(indentUnit)});
    }), {userEvent: "input.indent"}));
    return true;
  };
  var indentLess = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep)});
    }), {userEvent: "delete.dedent"}));
    return true;
  };
  var emacsStyleKeymap = [
    {key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true},
    {key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight},
    {key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp},
    {key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown},
    {key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart},
    {key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd},
    {key: "Ctrl-d", run: deleteCharForward},
    {key: "Ctrl-h", run: deleteCharBackward},
    {key: "Ctrl-k", run: deleteToLineEnd},
    {key: "Ctrl-Alt-h", run: deleteGroupBackward},
    {key: "Ctrl-o", run: splitLine},
    {key: "Ctrl-t", run: transposeChars},
    {key: "Ctrl-v", run: cursorPageDown}
  ];
  var standardKeymap = /* @__PURE__ */ [
    {key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true},
    {key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true},
    {mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true},
    {key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true},
    {key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true},
    {mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true},
    {key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true},
    {mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart},
    {mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp},
    {key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true},
    {mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd},
    {mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown},
    {key: "PageUp", run: cursorPageUp, shift: selectPageUp},
    {key: "PageDown", run: cursorPageDown, shift: selectPageDown},
    {key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true},
    {key: "Mod-Home", run: cursorDocStart, shift: selectDocStart},
    {key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true},
    {key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd},
    {key: "Enter", run: insertNewlineAndIndent},
    {key: "Mod-a", run: selectAll},
    {key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward},
    {key: "Delete", run: deleteCharForward},
    {key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward},
    {key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward},
    {mac: "Mod-Backspace", run: deleteToLineStart},
    {mac: "Mod-Delete", run: deleteToLineEnd}
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({mac: b.key, run: b.run, shift: b.shift})));
  var defaultKeymap = /* @__PURE__ */ [
    {key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft},
    {key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight},
    {key: "Alt-ArrowUp", run: moveLineUp},
    {key: "Shift-Alt-ArrowUp", run: copyLineUp},
    {key: "Alt-ArrowDown", run: moveLineDown},
    {key: "Shift-Alt-ArrowDown", run: copyLineDown},
    {key: "Escape", run: simplifySelection},
    {key: "Mod-Enter", run: insertBlankLine},
    {key: "Alt-l", mac: "Ctrl-l", run: selectLine},
    {key: "Mod-i", run: selectParentSyntax, preventDefault: true},
    {key: "Mod-[", run: indentLess},
    {key: "Mod-]", run: indentMore},
    {key: "Mod-Alt-\\", run: indentSelection},
    {key: "Shift-Mod-k", run: deleteLine},
    {key: "Shift-Mod-\\", run: cursorMatchingBracket},
    {key: "Mod-/", run: toggleComment},
    {key: "Alt-A", run: toggleBlockComment}
  ].concat(standardKeymap);
  var indentWithTab = {key: "Tab", run: indentMore, shift: indentLess};

  // node_modules/crelt/index.es.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
      elt = document.createElement(elt);
    var i = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next)
        if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string")
            elt.setAttribute(name2, value);
          else if (value != null)
            elt[name2] = value;
        }
      i++;
    }
    for (; i < arguments.length; i++)
      add(elt, arguments[i]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++)
        add(elt, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  var SearchCursor = class {
    constructor(text, query, from = 0, to = text.length, normalize, test) {
      this.test = test;
      this.value = {from: 0, to: 0};
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from, to);
      this.bufferStart = from;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        for (let i = 0, pos = start; ; i++) {
          let code = norm.charCodeAt(i);
          let match = this.match(code, pos);
          if (match) {
            this.value = match;
            return this;
          }
          if (i == norm.length - 1)
            break;
          if (pos == start && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
      }
    }
    match(code, pos) {
      let match = null;
      for (let i = 0; i < this.matches.length; i += 2) {
        let index = this.matches[i], keep = false;
        if (this.query.charCodeAt(index) == code) {
          if (index == this.query.length - 1) {
            match = {from: this.matches[i + 1], to: pos + 1};
          } else {
            this.matches[i]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i, 2);
          i -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code) {
        if (this.query.length == 1)
          match = {from: pos, to: pos + 1};
        else
          this.matches.push(1, pos);
      }
      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
        match = null;
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = {from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("")};
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text, query, options, from = 0, to = text.length) {
      this.text = text;
      this.to = to;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text, query, options, from, to);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.iter = text.iter();
      let startLine = text.lineAt(from);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text, from);
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from = this.curLineStart + match.index, to = from + match[0].length;
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          if (from == this.curLineStart + this.curLine.length)
            this.nextLine();
          if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
            this.value = {from, to, match};
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from, text) {
      this.from = from;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from, to) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to || cached.to <= from) {
        let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from && cached.to == to)
        return cached;
      let {text, from: cachedFrom} = cached;
      if (cachedFrom > from) {
        text = doc2.sliceString(from, cachedFrom) + text;
        cachedFrom = from;
      }
      if (cached.to < to)
        text += doc2.sliceString(cached.to, to);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text, query, options, from, to) {
      this.text = text;
      this.to = to;
      this.done = false;
      this.value = empty;
      this.matchPos = toCharEnd(text, from);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match) {
          let from = this.flat.from + match.index, to = from + match[0].length;
          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
            this.value = {from, to, match};
            this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function toCharEnd(text, pos) {
    if (pos >= text.length)
      return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
      pos++;
    return pos;
  }
  function createLineDialog(view) {
    let input = crelt("input", {class: "cm-textfield", name: "line"});
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view.dispatch({effects: dialogEffect.of(false)});
          view.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {class: "cm-button", type: "submit"}, view.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match)
        return;
      let {state} = view, startLine = state.doc.lineAt(state.selection.main.head);
      let [, sign, ln, cl, percent] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line / 100;
        if (sign)
          pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
        line = Math.round(state.doc.lines * pc);
      } else if (ln && sign) {
        line = line * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
      view.dispatch({
        effects: dialogEffect.of(false),
        selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
        scrollIntoView: true
      });
      view.focus();
    }
    return {dom};
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(dialogEffect))
          value = e.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view.dispatch({effects});
      panel = getPanel(view, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": {fontSize: "80%"}
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options) {
      return combineConfig(options, defaultHighlightOptions, {
        highlightWordAroundCursor: (a, b) => a || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
      ext.push(highlightConfig.of(options));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch"});
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch cm-selectionMatch-main"});
  function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
  }
  function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.selectionSet || update.docChanged || update.viewportChanged)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let {state} = view, sel = state.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range = sel.main, query, check = null;
      if (range.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state.wordAt(range.head);
        if (!word)
          return Decoration.none;
        check = state.charCategorizer(range.head);
        query = state.sliceDoc(word.from, word.to);
      } else {
        let len = range.to - range.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state.sliceDoc(range.from, range.to);
          check = state.charCategorizer(range.head);
          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
            return Decoration.none;
        } else {
          query = state.sliceDoc(range.from, range.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor = new SearchCursor(state.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let {from, to} = cursor.value;
          if (!check || insideWordBoundaries(check, state, from, to)) {
            if (range.empty && from <= range.from && to >= range.to)
              deco.push(mainMatchDeco.range(from, to));
            else if (from >= range.to || to <= range.from)
              deco.push(matchDeco.range(from, to));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": {backgroundColor: "#99ff7780"},
    ".cm-searchMatch .cm-selectionMatch": {backgroundColor: "transparent"}
  });
  var selectWord = ({state, dispatch}) => {
    let {selection} = state;
    let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
      return false;
    dispatch(state.update({selection: newSel}));
    return true;
  };
  function findNextOccurrence(state, query) {
    let {main, ranges} = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({state, dispatch}) => {
    let {ranges} = state.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({state, dispatch});
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
      return false;
    dispatch(state.update({
      selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        wholeWord: false,
        createPanel: (view) => new SearchPanel(view)
      });
    }
  });
  var SearchQuery = class {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.literal = !!config2.literal;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config2.wholeWord;
    }
    unquote(text) {
      return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from = 0, to) {
      let st = state.doc ? state : EditorState.create({doc: state});
      if (to == null)
        to = st.doc.length;
      return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
  }
  function stringWordTest(doc2, categorizer) {
    return (from, to, buf, bufPos) => {
      if (bufPos > from || bufPos + buf.length < to) {
        bufPos = Math.max(0, from - 2);
        buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
      }
      return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
    };
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state, curFrom, curTo) {
      let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
      if (cursor.done)
        cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
      for (let pos = to; ; ) {
        let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, state, start, pos), range = null;
        while (!cursor.nextOverlapping().done)
          range = cursor.value;
        if (range)
          return range;
        if (start == from)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state, limit) {
      let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
    }, from, to);
  }
  function charBefore(str, index) {
    return str.slice(findClusterBreak(str, index, false), index);
  }
  function charAfter(str, index) {
    return str.slice(index, findClusterBreak(str, index));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(state, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, state, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
      for (let size = 1; ; size++) {
        let start = Math.max(from, to - size * 1e4);
        let cursor = regexpCursor(this.spec, state, start, to), range = null;
        while (!cursor.next().done)
          range = cursor.value;
        if (range && (start == from || range.from > start + 10))
          return range;
        if (start == from)
          return null;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
    }
    matchAll(state, limit) {
      let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state) {
      return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch"});
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch cm-searchMatch-selected"});
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
      let state = update.state.field(searchState);
      if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
        this.decorations = this.highlight(state);
    }
    highlight({query, panel}) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let {view} = this;
      let builder = new RangeSetBuilder();
      for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
        let {from, to} = ranges[i];
        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
          to = ranges[++i].to;
        query.highlight(view.state, from, to, (from2, to2) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
          builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state = view.state.field(searchState, false);
      return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {to} = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
      return false;
    view.dispatch({
      selection: {anchor: next.from, head: next.to},
      scrollIntoView: true,
      effects: announceMatch(view, next),
      userEvent: "select.search"
    });
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {state} = view, {from} = state.selection.main;
    let range = query.prevMatch(state, from, from);
    if (!range)
      return false;
    view.dispatch({
      selection: {anchor: range.from, head: range.to},
      scrollIntoView: true,
      effects: announceMatch(view, range),
      userEvent: "select.search"
    });
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view, {query}) => {
    let ranges = query.matchAll(view.state, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({state, dispatch}) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let {from, to} = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch(state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {state} = view, {from, to} = state.selection.main;
    if (state.readOnly)
      return false;
    let next = query.nextMatch(state, from, from);
    if (!next)
      return false;
    let changes = [], selection, replacement;
    let announce = [];
    if (next.from == from && next.to == to) {
      replacement = state.toText(query.getReplacement(next));
      changes.push({from: next.from, to: next.to, insert: replacement});
      next = query.nextMatch(state, next.from, next.to);
      announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection = {anchor: next.from - off, head: next.to - off};
      announce.push(announceMatch(view, next));
    }
    view.dispatch({
      changes,
      selection,
      scrollIntoView: !!selection,
      effects: announce,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view, {query}) => {
    if (view.state.readOnly)
      return false;
    let changes = query.matchAll(view.state, 1e9).map((match) => {
      let {from, to} = match;
      return {from, to, insert: query.getReplacement(match)};
    });
    if (!changes.length)
      return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state, fallback) {
    var _a2, _b, _c, _d;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
      return fallback;
    let config2 = state.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
      literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
      wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config2.wholeWord
    });
  }
  var openSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
      let panel = getPanel(view, createSearchPanel);
      if (!panel)
        return false;
      let searchInput = panel.dom.querySelector("[main-field]");
      if (searchInput && searchInput != view.root.activeElement) {
        let query = defaultQuery(view.state, state.query.spec);
        if (query.valid)
          view.dispatch({effects: setSearchQuery.of(query)});
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view.dispatch({effects: [
        togglePanel.of(true),
        state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ]});
    }
    return true;
  };
  var closeSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
      return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
      view.focus();
    view.dispatch({effects: togglePanel.of(false)});
    return true;
  };
  var searchKeymap = [
    {key: "Mod-f", run: openSearchPanel, scope: "editor search-panel"},
    {key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true},
    {key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true},
    {key: "Escape", run: closeSearchPanel, scope: "editor search-panel"},
    {key: "Mod-Shift-l", run: selectSelectionMatches},
    {key: "Alt-g", run: gotoLine},
    {key: "Mod-d", run: selectNextOccurrence, preventDefault: true}
  ];
  var SearchPanel = class {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button(name2, onclick, content2) {
        return crelt("button", {class: "cm-button", name: name2, onclick, type: "button"}, content2);
      }
      this.dom = crelt("div", {onkeydown: (e) => this.keydown(e), class: "cm-search"}, [
        this.searchField,
        button("next", () => findNext(view), [phrase(view, "next")]),
        button("prev", () => findPrevious(view), [phrase(view, "previous")]),
        button("select", () => selectMatches(view), [phrase(view, "all")]),
        crelt("label", null, [this.caseField, phrase(view, "match case")]),
        crelt("label", null, [this.reField, phrase(view, "regexp")]),
        crelt("label", null, [this.wordField, phrase(view, "by word")]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [phrase(view, "replace")]),
          button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, ["\xD7"])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({effects: setSearchQuery.of(query)});
      }
    }
    keydown(e) {
      if (runScopeHandlers(this.view, e, "search-panel")) {
        e.preventDefault();
      } else if (e.keyCode == 13 && e.target == this.searchField) {
        e.preventDefault();
        (e.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e.keyCode == 13 && e.target == this.replaceField) {
        e.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update) {
      for (let tr of update.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view, {from, to}) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
      for (let i = 0; i < AnnounceMargin; i++)
        if (!Break.test(text[i + 1]) && Break.test(text[i])) {
          text = text.slice(i);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
        if (!Break.test(text[i - 1]) && Break.test(text[i])) {
          text = text.slice(0, i);
          break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": {backgroundColor: "#ffff0054"},
    "&dark .cm-searchMatch": {backgroundColor: "#00ffff8a"},
    "&light .cm-searchMatch-selected": {backgroundColor: "#ff6a0054"},
    "&dark .cm-searchMatch-selected": {backgroundColor: "#ff00ff8a"}
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.lowest(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    constructor(state, pos, explicit) {
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      this.abortListeners = [];
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : {from: start + found, to: this.pos, text: str.slice(found)};
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type, listener) {
      if (type == "abort" && this.abortListeners)
        this.abortListeners.push(listener);
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let {label} of options) {
      first[label[0]] = true;
      for (let i = 1; i < label.length; i++)
        rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  function completeFromList(list) {
    let options = list.map((o) => typeof o == "string" ? {label: o} : o);
    let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
      let token = context.matchBefore(match);
      return token || context.explicit ? {from: token ? token.from : context.pos, options, validFor} : null;
    };
  }
  var Option = class {
    constructor(completion, source, match) {
      this.completion = completion;
      this.source = source;
      this.match = match;
    }
  };
  function cur(state) {
    return state.selection.main.head;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let {source} = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  var pickedCompletion = /* @__PURE__ */ Annotation.define();
  function insertCompletionText(state, text, from, to) {
    return Object.assign(Object.assign({}, state.changeByRange((range) => {
      if (range == state.selection.main)
        return {
          changes: {from, to, insert: text},
          range: EditorSelection.cursor(from + text.length)
        };
      let len = to - from;
      if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to))
        return {range};
      return {
        changes: {from: range.from - len, to: range.from, insert: text},
        range: EditorSelection.cursor(range.from - len + text.length)
      };
    })), {userEvent: "input.complete"});
  }
  function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string")
      view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {annotations: pickedCompletion.of(option.completion)}));
    else
      apply(view, option.completion, result.from, result.to);
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source))
      return source;
    let known = SourceCache.get(source);
    if (!known)
      SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      for (let p = 0; p < pattern.length; ) {
        let char = codePointAt(pattern, p), size = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p, p + size), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    match(word) {
      if (this.pattern.length == 0)
        return [0];
      if (word.length < this.pattern.length)
        return null;
      let {chars, folded, any, precise, byWord} = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0);
        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return [0, 0, this.pattern.length];
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
          let next = codePointAt(word, i);
          if (next == chars[anyTo] || next == folded[anyTo])
            any[anyTo++] = i;
          i += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
        let next = codePointAt(word, i);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i;
              adjacentEnd = i + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type;
        i += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return [-200 - word.length, 0, adjacentEnd];
      if (direct > -1)
        return [-700 - word.length, direct, direct + this.pattern.length];
      if (adjacentTo == len)
        return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [score2 - word.length], i = 1;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i > 1 && result[i - 1] == pos)
          result[i - 1] = to;
        else {
          result[i++] = pos;
          result[i++] = to;
        }
      }
      return result;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        compareCompletions: (a, b) => a.label.localeCompare(b.label),
        interactionDelay: 75
      }, {
        defaultKeymap: (a, b) => a && b,
        closeOnBlur: (a, b) => a && b,
        icons: (a, b) => a && b,
        optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
        addToOptions: (a, b) => a.concat(b)
      });
    }
  });
  function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let {label} = completion, off = 0;
        for (let j = 1; j < match.length; ) {
          let from = match[j++], to = match[j++];
          if (from > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
  }
  function rangeAroundSelected(total, selected, max) {
    if (total <= max)
      return {from: 0, to: total};
    if (selected < 0)
      selected = 0;
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max);
      return {from: off2 * max, to: (off2 + 1) * max};
    }
    let off = Math.floor((total - selected) / max);
    return {from: total - (off + 1) * max, to: total - off * max};
  }
  var CompletionTooltip = class {
    constructor(view, stateField) {
      this.view = view;
      this.stateField = stateField;
      this.info = null;
      this.placeInfo = {
        read: () => this.measureInfo(),
        write: (pos) => this.positionInfo(pos),
        key: this
      };
      this.space = null;
      let cState = view.state.field(stateField);
      let {options, selected} = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.dom.addEventListener("mousedown", (e) => {
        for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
            applyCompletion(view, options[+match[1]]);
            e.preventDefault();
            return;
          }
        }
      });
      this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    mount() {
      this.updateSel();
    }
    update(update) {
      var _a2, _b, _c;
      let cState = update.state.field(this.stateField);
      let prevState = update.startState.field(this.stateField);
      if (cState != prevState) {
        this.updateSel();
        if (((_a2 = cState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
      }
    }
    positioned(space) {
      this.space = space;
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        });
      }
      if (this.updateSelectedOption(open.selected)) {
        if (this.info) {
          this.info.remove();
          this.info = null;
        }
        let {completion} = open.options[open.selected];
        let {info} = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((node) => {
            if (node && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(node);
          }).catch((e) => logException(this.view.state, e, "completion info"));
        } else {
          this.addInfoPane(infoResult);
        }
      }
    }
    addInfoPane(content2) {
      let dom = this.info = document.createElement("div");
      dom.className = "cm-tooltip cm-completionInfo";
      dom.appendChild(content2);
      this.dom.appendChild(dom);
      this.view.requestMeasure(this.placeInfo);
    }
    updateSelectedOption(selected) {
      let set = null;
      for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
        if (i == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set)
        scrollIntoView2(this.list, set);
      return set;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space = this.space;
      if (!space) {
        let win = this.dom.ownerDocument.defaultView || window;
        space = {left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight};
      }
      if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
        return null;
      let rtl = this.view.textDirection == Direction.RTL, left = rtl, narrow = false, maxWidth;
      let top2 = "", bottom = "";
      let spaceLeft = listRect.left - space.left, spaceRight = space.right - listRect.right;
      if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
        left = true;
      if (infoRect.width <= (left ? spaceLeft : spaceRight)) {
        top2 = Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top + "px";
        maxWidth = Math.min(400, left ? spaceLeft : spaceRight) + "px";
      } else {
        narrow = true;
        maxWidth = Math.min(400, (rtl ? listRect.right : space.right - listRect.left) - 30) + "px";
        let spaceBelow = space.bottom - listRect.bottom;
        if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
          top2 = selRect.bottom - listRect.top + "px";
        else
          bottom = listRect.bottom - selRect.top + "px";
      }
      return {
        top: top2,
        bottom,
        maxWidth,
        class: narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right"
      };
    }
    positionInfo(pos) {
      if (this.info) {
        if (pos) {
          this.info.style.top = pos.top;
          this.info.style.bottom = pos.bottom;
          this.info.style.maxWidth = pos.maxWidth;
          this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
        } else {
          this.info.style.top = "-1e6px";
        }
      }
    }
    createListBox(options, id, range) {
      const ul = document.createElement("ul");
      ul.id = id;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      for (let i = range.from; i < range.to; i++) {
        let {completion, match} = options[i];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id + "-" + i;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, match);
          if (node)
            li.appendChild(node);
        }
      }
      if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
  };
  function completionTooltip(stateField) {
    return (view) => new CompletionTooltip(view, stateField);
  }
  function scrollIntoView2(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top)
      container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom)
      container.scrollTop += self.bottom - parent.bottom;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    let options = [], i = 0;
    for (let a of active)
      if (a.hasResult()) {
        if (a.result.filter === false) {
          let getMatch = a.result.getMatch;
          for (let option of a.result.options) {
            let match = [1e9 - i++];
            if (getMatch)
              for (let n of getMatch(option))
                match.push(n);
            options.push(new Option(option, a, match));
          }
        } else {
          let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;
          for (let option of a.result.options)
            if (match = matcher.match(option.label)) {
              if (option.boost != null)
                match[0] += option.boost;
              options.push(new Option(option, a, match));
            }
        }
      }
    let result = [], prev = null;
    let compare2 = state.facet(completionConfig).compareCompletions;
    for (let opt of options.sort((a, b) => b.match[0] - a.match[0] || compare2(a.completion, b.completion))) {
      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
      this.options = options;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    setSelected(selected, id) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf) {
      let options = sortOptions(active, state);
      if (!options.length) {
        return prev && active.some((a) => a.state == 1) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
      }
      let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i = 0; i < options.length; i++)
          if (options[i].completion == selectedValue) {
            selected = i;
            break;
          }
      }
      return new CompletionDialog(options, makeAttrs(id, selected), {
        pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
        create: completionTooltip(completionState),
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {pos: changes.mapPos(this.tooltip.pos)}), this.timestamp, this.selected, this.disabled);
    }
  };
  var CompletionState = class {
    constructor(active, id, open) {
      this.active = active;
      this.id = id;
      this.open = open;
    }
    static start() {
      return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let {state} = tr, conf = state.facet(completionConfig);
      let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a) => a.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
        active = this.active;
      let open = this.open;
      if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active))
        open = CompletionDialog.build(active, state, this.id, this.open, conf);
      else if (open && tr.docChanged)
        open = open.map(tr.changes);
      if (!open && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
        active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : baseAttrs;
    }
  };
  function sameResults(a, b) {
    if (a == b)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a.length && !a[iA].hasResult)
        iA++;
      while (iB < b.length && !b[iB].hasResult)
        iB++;
      let endA = iA == a.length, endB = iB == b.length;
      if (endA || endB)
        return endA == endB;
      if (a[iA++].result != b[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id, selected) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id
    };
    if (selected > -1)
      result["aria-activedescendant"] = id + "-" + selected;
    return result;
  }
  var none3 = [];
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = class {
    constructor(source, state, explicitPos = -1) {
      this.source = source;
      this.state = state;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let event = getUserEvent(tr), value = this;
      if (event)
        value = value.handleUserEvent(tr, event, conf);
      else if (tr.docChanged)
        value = value.handleChange(tr);
      else if (tr.selection && value.state != 0)
        value = new ActiveSource(value.source, 0);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    handleUserEvent(tr, type, conf) {
      return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
  };
  var ActiveResult = class extends ActiveSource {
    constructor(source, explicitPos, result, from, to) {
      super(source, 2, explicitPos);
      this.result = result;
      this.from = from;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    handleUserEvent(tr, type, conf) {
      var _a2;
      let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
        return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
      if (checkValid(this.result.validFor, tr.state, from, to))
        return new ActiveResult(this.source, explicitPos, this.result, from, to);
      if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(mapping) {
      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
  };
  function checkValid(validFor, state, from, to) {
    if (!validFor)
      return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state) => state.attrs)
    ]
  });
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let {length} = cState.open.options;
      let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
      if (selected < 0)
        selected = by == "page" ? 0 : length - 1;
      else if (selected >= length)
        selected = by == "page" ? length - 1 : 0;
      view.dispatch({effects: setSelectedEffect.of(selected)});
      return true;
    };
  }
  var acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    if (!cState.open.disabled)
      applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
  };
  var startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
      return false;
    view.dispatch({effects: startCompletionEffect.of(true)});
    return true;
  };
  var closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a) => a.state != 0))
      return false;
    view.dispatch({effects: closeCompletionEffect.of(null)});
    return true;
  };
  var RunningQuery = class {
    constructor(active, context) {
      this.active = active;
      this.context = context;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var DebounceTime = 50;
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0;
      for (let active of view.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update) {
      let cState = update.state.field(completionState);
      if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
        return;
      let doesReset = update.transactions.some((tr) => {
        return (tr.selection || tr.docChanged) && !getUserEvent(tr);
      });
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e) {
              logException(this.view.state, e);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i--, 1);
        } else {
          query.updates.push(...update.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
      if (this.composing != 0)
        for (let tr of update.transactions) {
          if (getUserEvent(tr) == "input")
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      let {state} = this.view, cState = state.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
          this.startQuery(active);
      }
    }
    startQuery(active) {
      let {state} = this.view, pos = cur(state);
      let context = new CompletionContext(state, pos, active.explicitPos == pos);
      let pending = new RunningQuery(active, context);
      this.running.push(pending);
      Promise.resolve(active.source(context)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({effects: closeCompletionEffect.of(null)});
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig);
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (query.done === void 0)
          continue;
        this.running.splice(i--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length)
        this.view.dispatch({effects: setActiveEffect.of(updated)});
    }
  }, {
    eventHandlers: {
      blur() {
        let state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
          this.view.dispatch({effects: closeCompletionEffect.of(null)});
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({effects: startCompletionEffect.of(false)}), 20);
        }
        this.composing = 0;
      }
    }
  });
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer",
          padding: "1px 3px",
          lineHeight: 1.2
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": {right: "100%"},
    ".cm-completionInfo.cm-completionInfo-right": {left: "100%"},
    ".cm-completionInfo.cm-completionInfo-left-narrow": {right: `${30}px`},
    ".cm-completionInfo.cm-completionInfo-right-narrow": {left: `${30}px`},
    "&light .cm-snippetField": {backgroundColor: "#00000022"},
    "&dark .cm-snippetField": {backgroundColor: "#ffffff22"},
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {content: "'\u0192'"}
    },
    ".cm-completionIcon-class": {
      "&:after": {content: "'\u25CB'"}
    },
    ".cm-completionIcon-interface": {
      "&:after": {content: "'\u25CC'"}
    },
    ".cm-completionIcon-variable": {
      "&:after": {content: "'\u{1D465}'"}
    },
    ".cm-completionIcon-constant": {
      "&:after": {content: "'\u{1D436}'"}
    },
    ".cm-completionIcon-type": {
      "&:after": {content: "'\u{1D461}'"}
    },
    ".cm-completionIcon-enum": {
      "&:after": {content: "'\u222A'"}
    },
    ".cm-completionIcon-property": {
      "&:after": {content: "'\u25A1'"}
    },
    ".cm-completionIcon-keyword": {
      "&:after": {content: "'\u{1F511}\uFE0E'"}
    },
    ".cm-completionIcon-namespace": {
      "&:after": {content: "'\u25A2'"}
    },
    ".cm-completionIcon-text": {
      "&:after": {content: "'abc'", fontSize: "50%", verticalAlign: "middle"}
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      return mapping.mapPos(value);
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      if (tr.selection) {
        let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1))
          value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(closeBracketEffect))
          value = value.update({add: [closedBracket.range(effect.value, effect.value + 1)]});
        else if (effect.is(skipBracketEffect))
          value = value.update({filter: (from) => from != effect.value});
      }
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
      if (definedClosing.charCodeAt(i) == ch)
        return definedClosing.charAt(i + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
      return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
      return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr)
      return false;
    view.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty) {
        let before = prevChar(state.doc, range.head);
        for (let token of tokens) {
          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
            return {
              changes: {from: range.head - token.length, to: range.head + token.length},
              range: EditorSelection.cursor(range.head - token.length)
            };
        }
      }
      return {range: dont = range};
    });
    if (!dont)
      dispatch(state.update(changes, {scrollIntoView: true, userEvent: "delete.backward"}));
    return !dont;
  };
  var closeBracketsKeymap = [
    {key: "Backspace", run: deleteBracketPair}
  ];
  function insertBracket(state, bracket2) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
        return handleClose(state, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, (from) => {
      if (from == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{insert: open, from: range.from}, {insert: close, from: range.to}],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
      let next = nextChar(state.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: {insert: open + close, from: range.head},
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
      return {range: dont = range};
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    let dont = null, moved = state.selection.ranges.map((range) => {
      if (range.empty && nextChar(state.doc, range.head) == close)
        return EditorSelection.cursor(range.head + close.length);
      return dont = range;
    });
    return dont ? null : state.update({
      selection: EditorSelection.create(moved, state.selection.mainIndex),
      scrollIntoView: true,
      effects: state.selection.ranges.map(({from}) => skipBracketEffect.of(from))
    });
  }
  function handleSame(state, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{insert: token, from: range.from}, {insert: token, from: range.to}],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
      let pos = range.head, next = nextChar(state.doc, pos), start;
      if (next == token) {
        if (nodeStart(state, pos)) {
          return {
            changes: {insert: token + token, from: pos},
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state, pos)) {
          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          return {
            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
            effects: skipBracketEffect.of(pos)
          };
        }
      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
        return {
          changes: {insert: token + token + token + token, from: pos},
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
          return {
            changes: {insert: token + token, from: pos},
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return {range: dont = range};
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    let tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    let node = syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i = 0; i < 5; i++) {
      let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
            return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
      return pos;
    for (let prefix of prefixes) {
      let start = pos - prefix.length;
      if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
        return start;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    {key: "Ctrl-Space", run: startCompletion},
    {key: "Escape", run: closeCompletion},
    {key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true)},
    {key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false)},
    {key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page")},
    {key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page")},
    {key: "Enter", run: acceptCompletion}
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics);
      let ranges = Decoration.set(markedDiagnostics.map((d) => {
        return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
          widget: new DiagnosticWidget(d),
          diagnostic: d
        }).range(d.from) : Decoration.mark({
          attributes: {class: "cm-lintRange cm-lintRange-" + d.severity},
          diagnostic: d
        }).range(d.from, d.to);
      }), true);
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, {spec}) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
      lintState,
      EditorView.decorations.compute([lintState], (state2) => {
        let {selected, panel} = state2.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      hoverTooltip(lintTooltip, {hideOn: hideTooltip}),
      baseTheme5
    ]));
  }
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        let mapped = value.diagnostics.map(tr.changes), selected = null;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          value = LintState.init(effect.value, value.panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({class: "cm-lintRange cm-lintRange-active"});
  function lintTooltip(view, pos, side) {
    let {diagnostics} = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, {spec}) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return {dom: diagnosticsTooltip(view, found)};
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", {class: "cm-tooltip-lint"}, diagnostics.map((d) => renderDiagnostic(view, d, false)));
  }
  var openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      view.dispatch({effects: maybeEnableLint(view.state, [togglePanel2.of(true)])});
    let panel = getPanel(view, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({effects: togglePanel2.of(false)});
    return true;
  };
  var nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view.dispatch({selection: {anchor: next.from, head: next.to}, scrollIntoView: true});
    return true;
  };
  var lintKeymap = [
    {key: "Mod-Shift-m", run: openLintPanel, preventDefault: true},
    {key: "F8", run: nextDiagnostic}
  ];
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let {delay} = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    run() {
      let now = Date.now();
      if (now < this.lintTime - 10) {
        setTimeout(this.run, this.lintTime - now);
      } else {
        this.set = false;
        let {state} = this.view, {sources} = state.facet(lintConfig);
        Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
          let all = annotations.reduce((a, b) => a.concat(b));
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, all));
        }, (error) => {
          logException(this.view.state, error);
        });
      }
    }
    update(update) {
      let config2 = update.state.facet(lintConfig);
      if (update.docChanged || config2 != update.startState.facet(lintConfig)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({sources: input.map((i) => i.source)}, combineConfig(input.map((i) => i.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null
      }));
    },
    enables: lintPlugin
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions:
        for (let {name: name2} of actions) {
          for (let i = 0; i < name2.length; i++) {
            let ch = name2[i];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", {class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity}, crelt("span", {class: "cm-diagnosticText"}, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i) => {
      let click = (e) => {
        e.preventDefault();
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view, found.from, found.to);
      };
      let {name: name2} = action, keyIndex = keys2[i] ? name2.indexOf(keys2[i]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", {class: "cm-diagnosticSource"}, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", {class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity});
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let {diagnostic} = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
          for (let i = 0; i < keys2.length; i++)
            if (keys2[i].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i = 0; i < this.items.length; i++) {
          if (this.items[i].dom.contains(event.target))
            this.moveSelection(i);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", {class: "cm-panel-lint"}, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i = 0; i < this.items.length; i++)
        if (this.items[i].diagnostic == selected.diagnostic)
          return i;
      return -1;
    }
    update() {
      let {diagnostics, selected} = this.view.state.field(lintState);
      let i = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, {spec}) => {
        let found = -1, item;
        for (let j = i; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i) {
            this.items.splice(i, found - i);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i++;
      });
      while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect()}),
          write: ({sel, panel}) => {
            if (sel.top < panel.top)
              this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += sel.bottom - panel.bottom;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: {anchor: selection.from, head: selection.to},
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {borderLeft: "5px solid #d11"},
    ".cm-diagnostic-warning": {borderLeft: "5px solid orange"},
    ".cm-diagnostic-info": {borderLeft: "5px solid #999"},
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {backgroundImage: /* @__PURE__ */ underline("#d11")},
    ".cm-lintRange-warning": {backgroundImage: /* @__PURE__ */ underline("orange")},
    ".cm-lintRange-info": {backgroundImage: /* @__PURE__ */ underline("#999")},
    ".cm-lintRange-active": {backgroundColor: "#ffdd9980"},
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {borderBottomColor: "orange"}
    },
    ".cm-lintPoint-info": {
      "&:after": {borderBottomColor: "#999"}
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {textDecoration: "underline"}
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {textDecoration: "none"},
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });

  // node_modules/codemirror/dist/index.js
  var basicSetup = /* @__PURE__ */ (() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    syntaxHighlighting(defaultHighlightStyle, {fallback: true}),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ])();

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class {
    constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score2;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    toString() {
      return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p, state, pos = 0) {
      let cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action) {
      let depth = action >> 19, type = action & 65535;
      let {parser: parser2} = this.p;
      let dPrec = parser2.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
        if (type < parser2.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start = this.stack[base2 - 2];
      let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser2.minRepeatTerm || action & 131072) {
        let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser2.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start);
    }
    storeNode(term, start, end, size = 4, isReduce = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur2 = this, top2 = this.buffer.length;
        if (top2 == 0 && cur2.parent) {
          top2 = cur2.bufferBase - cur2.parent.bufferBase;
          cur2 = cur2.parent;
        }
        if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
          if (start == end)
            return;
          if (cur2.buffer[top2 - 2] >= start) {
            cur2.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        let index = this.buffer.length;
        if (index > 0 && this.buffer[index - 4] != 0)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index] = term;
        this.buffer[index + 1] = start;
        this.buffer[index + 2] = end;
        this.buffer[index + 3] = size;
      }
    }
    shift(action, next, nextEnd) {
      let start = this.pos;
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, {parser: parser2} = this.p;
        if (nextEnd > this.pos || next <= parser2.maxNode) {
          this.pos = nextEnd;
          if (!parser2.stateFlag(nextState, 1))
            this.reducePos = nextEnd;
        }
        this.pushState(nextState, start);
        this.shiftContext(next, start);
        if (next <= parser2.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      } else {
        this.pos = nextEnd;
        this.shiftContext(next, start);
        if (next <= this.p.parser.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      }
    }
    apply(action, next, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextEnd);
    }
    useNode(value, next) {
      let index = this.p.reused.length - 1;
      if (index < 0 || this.p.reused[index] != value) {
        this.p.reused.push(value);
        index++;
      }
      let start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(index, start, this.reducePos, -1);
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if ((action & 65536) == 0)
          return true;
        if (action == 0)
          return false;
        sim.reduce(action);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
            best.push(nextStates[i], s);
        }
        if (this.stack.length < 120)
          for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i2) => i2 & 1 && v == s))
              best.push(nextStates[i], s);
          }
        nextStates = best;
      }
      let result = [];
      for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
        let s = nextStates[i + 1];
        if (s == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i], this.pos);
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      let reduce = this.p.parser.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0)
        return false;
      let {parser: parser2} = this.p;
      if (!parser2.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
          return false;
        this.storeNode(0, this.reducePos, this.reducePos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2)) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let {parser: parser2} = this.p;
      return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
    }
    restart() {
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i = 0; i < this.stack.length; i += 3)
        if (this.stack[i] != other.stack[i])
          return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    emitContext() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3)
        this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4)
        this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var Recover;
  (function(Recover2) {
    Recover2[Recover2["Insert"] = 200] = "Insert";
    Recover2[Recover2["Delete"] = 190] = "Delete";
    Recover2[Recover2["Reduce"] = 100] = "Reduce";
    Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
    Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
  })(Recover || (Recover = {}));
  var SimulatedStack = class {
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class {
    constructor(stack, pos, index) {
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    resolveOffset(offset, assoc) {
      let range = this.range, index = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range.from) {
        if (!index)
          return null;
        let next = this.ranges[--index];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range of this.ranges)
        if (range.to > pos)
          return Math.max(pos, range.from);
      return this.end;
    }
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let {chunk, chunkPos} = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n = 1) {
      this.chunkOff += n;
      while (this.pos + n >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
      if (from >= this.range.from && to <= this.range.to)
        return this.input.read(from, to);
      let result = "";
      for (let r of this.ranges) {
        if (r.from >= to)
          break;
        if (r.to > from)
          result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id) {
      this.data = data;
      this.id = id;
    }
    token(input, stack) {
      readToken(this.data, input, stack, this.id);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, {parser: parser2} = stack.p, {dialect} = parser2;
    scan:
      for (; ; ) {
        if ((groupMask & data[state]) == 0)
          break;
        let accEnd = data[state + 1];
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data[i + 1] & groupMask) > 0) {
            let term = data[i];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
              input.acceptToken(term);
              break;
            }
          }
        let next = input.next, low = 0, high = data[state + 2];
        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
          state = data[accEnd + high * 3 - 1];
          continue scan;
        }
        for (; low < high; ) {
          let mid = low + high >> 1;
          let index = accEnd + mid + (mid << 1);
          let from = data[index], to = data[index + 1] || 65536;
          if (next < from)
            high = mid;
          else if (next >= to)
            low = mid + 1;
          else {
            state = data[index + 2];
            input.advance();
            continue scan;
          }
        }
        break;
      }
  }
  function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array)
        array[out++] = value;
      else
        array = new Type(value);
    }
    return array;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function(Safety2) {
    Safety2[Safety2["Margin"] = 25] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last], index = this.index[last];
        if (index == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index];
        let start = this.start[last] + top2.positions[index];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom)
              return null;
            let end = start + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser2, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser2.tokenizers.map((_) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let {parser: parser2} = stack.p, {tokenizers} = parser2;
      let mask = parser2.stateSlot(stack.state, 3);
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i = 0; i < tokenizers.length; i++) {
        if ((1 << i & mask) == 0)
          continue;
        let tokenizer = tokenizers[i], token = this.tokens[i];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), {pos, p} = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        let {parser: parser2} = stack.p;
        for (let i = 0; i < parser2.specialized.length; i++)
          if (parser2.specialized[i] == token.value) {
            let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index) {
      for (let i = 0; i < index; i += 3)
        if (this.actions[i] == action)
          return index;
      this.actions[index++] = action;
      this.actions[index++] = token;
      this.actions[index++] = end;
      return index;
    }
    addActions(stack, token, end, index) {
      let {state} = stack, {parser: parser2} = stack.p, {data} = parser2;
      for (let set = 0; set < 2; set++) {
        for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
          if (data[i] == 65535) {
            if (data[i + 1] == 1) {
              i = pair(data, i + 2);
            } else {
              if (index == 0 && data[i + 1] == 2)
                index = this.putAction(pair(data, i + 2), token, end, index);
              break;
            }
          }
          if (data[i] == token)
            index = this.putAction(pair(data, i + 1), token, end, index);
        }
      }
      return index;
    }
  };
  var Rec;
  (function(Rec2) {
    Rec2[Rec2["Distance"] = 5] = "Distance";
    Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
    Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
  })(Rec || (Rec = {}));
  var Parse = class {
    constructor(parser2, input, fragments, ranges) {
      this.parser = parser2;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser2, this.stream);
      this.topTerm = parser2.top[1];
      let {from} = ranges[0];
      this.stacks = [Stack.start(this, parser2.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished)
          return this.stackToTree(finished);
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished)
          return this.stackToTree(finished.forceAll());
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a, b) => b.score - a.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer:
          for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
      }
      this.minStackPos = newStacks[0].pos;
      for (let i = 1; i < newStacks.length; i++)
        if (newStacks[i].pos < this.minStackPos)
          this.minStackPos = newStacks[i].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      let start = stack.pos, {parser: parser2} = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser2.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
        return true;
      }
      if (stack.stack.length >= 15e3) {
        while (stack.stack.length > 9e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i = 0; i < actions.length; ) {
        let action = actions[i++], term = actions[i++], end = actions[i++];
        let last = i == actions.length || !split;
        let localStack = last ? stack : stack.split();
        localStack.apply(action, term, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
        if (last)
          return true;
        else if (localStack.pos > start)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j = 0; force.forceReduce() && j < 10; j++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
      if (!id)
        stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
      return id + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
      let other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score)
          newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var LRParser = class extends Parser {
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i = 0; i < spec.repeatNodeCount; i++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
      let nodeProps = [];
      for (let i = 0; i < nodeNames.length; i++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i = 1; i < propSpec.length; ) {
            let next = propSpec[i++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i++]);
            } else {
              let value = propSpec[i + -next];
              for (let j = -next; j > 0; j--)
                setProp(propSpec[i++], prop, value);
              i++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
        name: i >= this.minRepeatTerm ? void 0 : name2,
        id: i,
        props: nodeProps[i],
        top: topTerms.indexOf(i) > -1,
        error: i == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i = 0; i < this.specializerSpecs.length; i++)
        this.specialized[i] = this.specializerSpecs[i].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse = new Parse(this, input, fragments, ranges);
      for (let w of this.wrappers)
        parse = w(parse, input, fragments, ranges);
      return parse;
    }
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last = groupTag & 1;
        let target = table[pos++];
        if (last && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last)
          return -1;
      }
    }
    hasAction(state, terminal) {
      let data = this.data;
      for (let set = 0; set < 2; set++) {
        for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
          if ((next = data[i]) == 65535) {
            if (data[i + 1] == 1)
              next = data[i = pair(data, i + 2)];
            else if (data[i + 1] == 2)
              return pair(data, i + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action) {
      if (action == this.stateSlot(state, 4))
        return true;
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            return false;
        }
        if (action == pair(this.data, i + 1))
          return true;
      }
    }
    nextStates(state) {
      let result = [];
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        if ((this.data[i + 2] & 65536 >> 16) == 0) {
          let value = this.data[i + 1];
          if (!result.some((v, i2) => i2 & 1 && v == value))
            result.push(this.data[i], value);
        }
      }
      return result;
    }
    overrides(token, prev) {
      let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
      return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config2) {
      let copy = Object.assign(Object.create(LRParser.prototype), this);
      if (config2.props)
        copy.nodeSet = this.nodeSet.extend(...config2.props);
      if (config2.top) {
        let info = this.topRules[config2.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config2.top}`);
        copy.top = info;
      }
      if (config2.tokenizers)
        copy.tokenizers = this.tokenizers.map((t2) => {
          let found = config2.tokenizers.find((r) => r.from == t2);
          return found ? found.to : t2;
        });
      if (config2.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
          let found = config2.specializers.find((r) => r.from == s.external);
          if (!found)
            return s;
          let spec = Object.assign(Object.assign({}, s), {external: found.to});
          copy.specializers[i] = getSpecializer(spec);
          return spec;
        });
      }
      if (config2.contextTracker)
        copy.context = config2.contextTracker;
      if (config2.dialect)
        copy.dialect = this.parseDialect(config2.dialect);
      if (config2.strict != null)
        copy.strict = config2.strict;
      if (config2.wrap)
        copy.wrappers = copy.wrappers.concat(config2.wrap);
      if (config2.bufferLength != null)
        copy.bufferLength = config2.bufferLength;
      return copy;
    }
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      let values = Object.keys(this.dialects), flags = values.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id = values.indexOf(part);
          if (id >= 0)
            flags[id] = true;
        }
      let disabled = null;
      for (let i = 0; i < values.length; i++)
        if (!flags[i]) {
          for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535; i++)
      if (next == term)
        return i - start;
    return -1;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/@lezer/json/dist/index.es.js
  var jsonHighlighting = styleTags({
    String: tags.string,
    Number: tags.number,
    "True False": tags.bool,
    PropertyName: tags.propertyName,
    Null: tags.null,
    ",": tags.separator,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace
  });
  var parser = LRParser.deserialize({
    version: 14,
    states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
    stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
    goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
    nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
    maxTerm: 25,
    nodeProps: [
      ["openedBy", 7, "{", 12, "["],
      ["closedBy", 8, "}", 13, "]"]
    ],
    propSources: [jsonHighlighting],
    skippedNodes: [0],
    repeatNodeCount: 2,
    tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
    tokenizers: [0],
    topRules: {JsonText: [0, 1]},
    tokenPrec: 0
  });

  // node_modules/@codemirror/lang-json/dist/index.js
  var jsonLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "json",
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          Object: /* @__PURE__ */ continuedIndent({except: /^\s*\}/}),
          Array: /* @__PURE__ */ continuedIndent({except: /^\s*\]/})
        }),
        /* @__PURE__ */ foldNodeProp.add({
          "Object Array": foldInside
        })
      ]
    }),
    languageData: {
      closeBrackets: {brackets: ["[", "{", '"']},
      indentOnInput: /^\s*[\}\]]$/
    }
  });
  function json() {
    return new LanguageSupport(jsonLanguage);
  }

  // resources/js/components/json-field.js
  var json_field_default = (Alpine) => {
    Alpine.data("filamentJsonField", ({state, disabled}) => {
      return {
        state,
        init() {
          console.log("disabled: " + disabled ? 1 : 0);
          new EditorView({
            doc: this.state,
            extensions: this.buildExtensionsArray(),
            parent: this.$refs.jsonBlock
          });
        },
        buildExtensionsArray() {
          let extensions = [
            basicSetup,
            json(),
            keymap.of([indentWithTab]),
            EditorView.lineWrapping,
            EditorView.updateListener.of((v) => {
              if (v.docChanged) {
                this.state = v.state.doc.toString();
              }
            }),
            EditorView.contentAttributes.of({contenteditable: !disabled})
          ];
          return extensions;
        }
      };
    });
  };

  // resources/js/plugin.js
  document.addEventListener("alpine:init", () => {
    window.Alpine.plugin(json_field_default);
  });
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvanNvbi9kaXN0L2luZGV4LmVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWpzb24vZGlzdC9pbmRleC5qcyIsICIuLi9qcy9jb21wb25lbnRzL2pzb24tZmllbGQuanMiLCAiLi4vanMvcGx1Z2luLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcblRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLiBAbm9uYWJzdHJhY3RcbiovXG5jbGFzcyBUZXh0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0ZXh0LmRlY29tcG9zZSgwLCB0ZXh0Lmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovIHwgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoZnJvbSwgdG8sIHBhcnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20ocGFydHMsIHRvIC0gZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIHRleHQgaXMgZXF1YWwgdG8gYW5vdGhlciBpbnN0YW5jZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggIT0gdGhpcy5sZW5ndGggfHwgb3RoZXIubGluZXMgIT0gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAxKSwgZW5kID0gdGhpcy5sZW5ndGggLSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIC0xKTtcbiAgICAgICAgbGV0IGEgPSBuZXcgUmF3VGV4dEN1cnNvcih0aGlzKSwgYiA9IG5ldyBSYXdUZXh0Q3Vyc29yKG90aGVyKTtcbiAgICAgICAgZm9yIChsZXQgc2tpcCA9IHN0YXJ0LCBwb3MgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICBhLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBiLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBza2lwID0gMDtcbiAgICAgICAgICAgIGlmIChhLmxpbmVCcmVhayAhPSBiLmxpbmVCcmVhayB8fCBhLmRvbmUgIT0gYi5kb25lIHx8IGEudmFsdWUgIT0gYi52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gYS52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5kb25lIHx8IHBvcyA+PSBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0ZXh0LiBXaGVuIGBkaXJgIGlzIGAtMWAsIGl0ZXJhdGlvbiBoYXBwZW5zXG4gICAgZnJvbSBlbmQgdG8gc3RhcnQuIFRoaXMgd2lsbCByZXR1cm4gbGluZXMgYW5kIHRoZSBicmVha3MgYmV0d2VlblxuICAgIHRoZW0gYXMgc2VwYXJhdGUgc3RyaW5ncy5cbiAgICAqL1xuICAgIGl0ZXIoZGlyID0gMSkgeyByZXR1cm4gbmV3IFJhd1RleHRDdXJzb3IodGhpcywgZGlyKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHRoZSB0ZXh0LiBXaGVuIGBmcm9tYCA+IGB0b2AsIHRoZVxuICAgIGl0ZXJhdG9yIHdpbGwgcnVuIGluIHJldmVyc2UuXG4gICAgKi9cbiAgICBpdGVyUmFuZ2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gbmV3IFBhcnRpYWxUZXh0Q3Vyc29yKHRoaXMsIGZyb20sIHRvKTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGN1cnNvciB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhlIGdpdmVuIHJhbmdlIG9mIGxpbmVzLFxuICAgIF93aXRob3V0XyByZXR1cm5pbmcgdGhlIGxpbmUgYnJlYWtzIGJldHdlZW4sIGFuZCB5aWVsZGluZyBlbXB0eVxuICAgIHN0cmluZ3MgZm9yIGVtcHR5IGxpbmVzLlxuICAgIFxuICAgIFdoZW4gYGZyb21gIGFuZCBgdG9gIGFyZSBnaXZlbiwgdGhleSBzaG91bGQgYmUgMS1iYXNlZCBsaW5lIG51bWJlcnMuXG4gICAgKi9cbiAgICBpdGVyTGluZXMoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGlubmVyO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSB0aGlzLmxpbmVzICsgMTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMubGluZShmcm9tKS5mcm9tO1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXJSYW5nZShzdGFydCwgTWF0aC5tYXgoc3RhcnQsIHRvID09IHRoaXMubGluZXMgKyAxID8gdGhpcy5sZW5ndGggOiB0byA8PSAxID8gMCA6IHRoaXMubGluZSh0byAtIDEpLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ3Vyc29yKGlubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuc2xpY2VTdHJpbmcoMCk7IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoZSBkb2N1bWVudCB0byBhbiBhcnJheSBvZiBsaW5lcyAod2hpY2ggY2FuIGJlXG4gICAgZGVzZXJpYWxpemVkIGFnYWluIHZpYSBbYFRleHQub2ZgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHReb2YpKS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuZmxhdHRlbihsaW5lcyk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGxpbmVzLCBuZXdMZW4pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdChsaW5lcywgW10pLCBuZXdMZW4pO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuc2xpY2VTdHJpbmcoZnJvbSAtIHBvcywgdG8gLSBwb3MsIGxpbmVTZXApO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKG90aGVyLCBkaXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgOiBbdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxLCBvdGhlci5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKDs7IGlBICs9IGRpciwgaUIgKz0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaEEgPSB0aGlzLmNoaWxkcmVuW2lBXSwgY2hCID0gb3RoZXIuY2hpbGRyZW5baUJdO1xuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGNoQS5zY2FuSWRlbnRpY2FsKGNoQiwgZGlyKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaEEubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ucmVkdWNlKChsLCBjaCkgPT4gbCArIGNoLmxlbmd0aCArIDEsIC0xKSkge1xuICAgICAgICBsZXQgbGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGxpbmVzICs9IGNoLmxpbmVzO1xuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGZsYXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xuICAgICAgICBsZXQgY2h1bmtlZCA9IFtdLCBjdXJyZW50TGluZXMgPSAwLCBjdXJyZW50TGVuID0gLTEsIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxpbmVzID4gbWF4Q2h1bmsgJiYgY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmxpbmVzID4gbWluQ2h1bmsgJiYgKGN1cnJlbnRMaW5lcyA+IG1pbkNodW5rIHx8ICFjdXJyZW50TGluZXMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjaHVua2VkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9IGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgVGV4dExlYWYgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5saW5lcyArIGxhc3QubGluZXMgPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dExlYWYobGFzdC50ZXh0LmNvbmNhdChjaGlsZC50ZXh0KSwgbGFzdC5sZW5ndGggKyAxICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgKyBjaGlsZC5saW5lcyA+IGNodW5rKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xuICAgICAgICAgICAgY3VycmVudExlbiA9IC0xO1xuICAgICAgICAgICAgY3VycmVudExpbmVzID0gY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBhZGQoY2hpbGQpO1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgICByZXR1cm4gY2h1bmtlZC5sZW5ndGggPT0gMSA/IGNodW5rZWRbMF0gOiBuZXcgVGV4dE5vZGUoY2h1bmtlZCwgbGVuZ3RoKTtcbiAgICB9XG59XG5UZXh0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSAvKkBfX1BVUkVfXyovXCJsYywzNCw3biw3LDdiLDE5LCwsLDIsLDIsLCwyMCxiLDFjLGwsZywsMnQsNywyLDYsMiwyLCw0LHosLHUsciwyaixiLDFtLDksOSwsbyw0LCw5LCwzLCw1LDE3LDMsM2IsZiwsdywxaiwsLCw0LDgsNCwsMyw3LGEsMix0LCwxbSwsLCwyLDQsOCwsOSwsYSwyLHEsLDIsMiwxbCwsNCwyLDQsMiwyLDMsMywsdSwyLDMsLGIsMiwxbCwsNCw1LCwyLDQsLGssMixtLDYsLCwxbSwsLDIsLDQsOCwsNywzLGEsMix1LCwxbiwsLCxjLCw5LCwxNCwsMywsMWwsMyw1LDMsLDQsNywyLGIsMix0LCwxbSwsMiwsMiwsMywsNSwyLDcsMixiLDIscywyLDFsLDIsLCwyLDQsOCwsOSwsYSwyLHQsLDIwLCw0LCwyLDMsLCw4LCwyOSwsMiw3LGMsOCwycSwsMiw5LGIsNiwyMiwyLHIsLCwsLCwxaixlLCw1LCwyLDUsYiwsMTAsOSwsMnUsNCwsNiwsMiwyLDIscCwyLDQsMyxnLDQsZCwsMiwyLDYsLGYsLGpqLDMscWEsMyx0LDMsdCwyLHUsMiwxcywyLCw3LDgsLDIsYiw5LCwxOSwzLDNiLDIseSwsM2EsMyw0LDIsOSwsNiwzLDYzLDIsMiwsMW0sLCw3LCwsLCwyLDgsNixhLDIsLDFjLGgsMXIsNCwxYyw3LCwsNSwsMTQsOSxjLDIsdyw0LDIsMiwsMywxaywsLDIsMywsLDMsMW0sOCwyLDIsNDgsMywsZCwsNyw0LCw2LCwzLDIsNWksMW0sLDUsZWssLDVmLHgsMmRhLDMsM3gsLDJvLHcsZmUsNiwyeCwyLG45dyw0LCxhLHcsMiwyOCwyLDdrLCwzLCw0LCxwLDIsNSwsNDcsMixxLGksZCwsMTIsOCxwLGIsMWEsMywxYywsMiw0LDIsMiwxMywsMXYsNiwyLDIsMiwyLGMsLDgsLDFiLCwxZiwsLDMsMiwyLDUsMiwsLDE2LDIsOCwsNm0sLDIsLDQsLGZuNCwsa2gsZyxnLGcsYTYsMixndCwsNmEsLDQ1LDUsMWFlLDMsLDIsNSw0LDE0LDMsNCwsNGwsMixmeCw0LGFyLDIsNDksYiw0dywsMWksZiwxaywzLDFkLDQsMiwyLDF4LDMsMTAsNSwsOCwxcSwsYywyLDFnLDksYSw0LDIsLDJuLDMsMiwsLDIsNiwsNGcsLDMsOCxsLDIsMWwsMiwsLCwsbSwsZSw3LDMsNSw1Ziw4LDIsMywsLG4sLDI5LCwyLDYsLCwyLCwsMiwsMiw2aiwsMiw0LDYsMiwsMixyLDIsMmQsOCwyLCwsMiwyeSwsLCwyLDYsLCwydCwzLDIsNCwsNSw3Nyw5LCwyLDZ0LCxhLDIsLCw0LCw0MCw0LDIsMiw0LCx3LGEsMTQsNiwyLDQsOCwsOSw2LDIsMywxYSxkLCwyLGJhLDcsLDYsLCwyYSxtLDIsNywsMiwsMiwzZSw2LDMsLCwyLCw3LCwsMjAsMiwzLCwsLDluLDIsZjBiLDUsMW4sNyx0NCwsMXIsNCwyOSwsZjVrLDIsNDNxLCwsMyw0LDUsOCw4LDIsNyx1LDQsNDQsMywxaXosMWosNCwxZSw4LCxlLCxtLDUsLGYsMTFzLDcsLGgsMiw3LCwyLCw1LDc5LDcsYzUsNCwxNXMsNywzMSw3LDI0MCw1LGd4N2ssMm8sM2ssNm9cIi5zcGxpdChcIixcIikubWFwKHMgPT4gcyA/IHBhcnNlSW50KHMsIDM2KSA6IDEpO1xuLy8gQ29udmVydCBvZmZzZXRzIGludG8gYWJzb2x1dGUgdmFsdWVzXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcbiAgICBleHRlbmRbaV0gKz0gZXh0ZW5kW2kgLSAxXTtcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChleHRlbmRbaV0gPiBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFtpIC0gMV0gPD0gY29kZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcbn1cbmNvbnN0IFpXSiA9IDB4MjAwZDtcbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIC8vIElmIHBvcyBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgc3Vycm9nYXRlIHBhaXIsIG1vdmUgdG8gaXRzIHN0YXJ0XG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXG4gICAgICAgIHBvcy0tO1xuICAgIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xuICAgIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgICAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDI7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudEJlZm9yZSsrO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudEJlZm9yZSAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZvdW5kID0gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcyAtIDIsIGluY2x1ZGVFeHRlbmRpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIHBvcy0tO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgb3RoZXJgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgdGhpc2AuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCBcdTIxOTIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIFx1MjE5MiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIFx1MjE5MiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIC8vIFByb2R1Y2UgYSBjb3B5IG9mIHNldEEgdGhhdCBhcHBsaWVzIHRvIHRoZSBkb2N1bWVudCBhZnRlciBzZXRCXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcbiAgICAvLyBpbiBBIHRoYXQgaGF2ZSB0byBiZSBwcm9jZXNzZWQgcGllY2UtYnktcGllY2UsIHdoZXRoZXIgdGhlaXJcbiAgICAvLyBjb250ZW50IGhhcyBiZWVuIGluc2VydGVkIGFscmVhZHksIGFuZCByZWZlcnMgdG8gdGhlIHNlY3Rpb25cbiAgICAvLyBpbmRleC5cbiAgICBmb3IgKGxldCBpbnNlcnRlZCA9IC0xOzspIHtcbiAgICAgICAgaWYgKGEuaW5zID09IC0xICYmIGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4sIGIubGVuKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIEIgdGhhdCBjb21lcyBiZWZvcmUgdGhlIG5leHQgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyBBIChvcmRlcmVkIGJ5IHN0YXJ0IHBvcywgdGhlbiBsZW4sIHRoZW4gYmVmb3JlIGZsYWcpLCBza2lwXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXG4gICAgICAgICAgICBsZXQgbGVuID0gYi5sZW47XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGEubGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIGlmIChhLmlucyA+PSAwICYmIGluc2VydGVkIDwgYS5pICYmIGEubGVuIDw9IHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBwYXJ0IG9mIGEgY2hhbmdlIGluIEEgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSAwLCBsZWZ0ID0gYS5sZW47XG4gICAgICAgICAgICB3aGlsZSAobGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihsZWZ0LCBiLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBiLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc2VydGVkIDwgYS5pID8gYS5pbnMgOiAwKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gVGV4dC5lbXB0eSA6IGluc2VydGVkW2luZGV4XTtcbiAgICB9XG4gICAgdGV4dEJpdChsZW4pIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XG4gICAgICAgICAgICA6IGluc2VydGVkW2luZGV4XS5zbGljZSh0aGlzLm9mZiwgbGVuID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm9mZiArIGxlbik7XG4gICAgfVxuICAgIGZvcndhcmQobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZDIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPT0gdGhpcy5pbnMpXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucyAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXG5bYGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbmlzIGVuYWJsZWQsIGEgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24pIG1heSBob2xkXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdlXHUyMDE0dGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLmZyb20gOiB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgY2hhcmFjdGVyIG9uIG9uZSBvZiBpdHMgc2lkZXMsIHRoaXMgcmV0dXJucyB0aGUgc2lkZS4gLTEgbWVhbnNcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcbiAgICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgICAqL1xuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA0IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiAzIC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gMyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICAgIGluc3RhbmNlLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBTZWxlY3Rpb25SYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCBmbGFncykge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCBmbGFncyk7XG4gICAgfVxufVxuLyoqXG5BbiBlZGl0b3Igc2VsZWN0aW9uIGhvbGRzIG9uZSBvciBtb3JlIHNlbGVjdGlvbiByYW5nZXMuXG4qL1xuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24sIHNvcnRlZCBieSBwb3NpdGlvbi4gUmFuZ2VzIGNhbm5vdFxuICAgIG92ZXJsYXAgKGJ1dCB0aGV5IG1heSB0b3VjaCwgaWYgdGhleSBhcmVuJ3QgZW1wdHkpLlxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgaW5kZXggb2YgdGhlIF9tYWluXyByYW5nZSBpbiB0aGUgc2VsZWN0aW9uICh3aGljaCBpc1xuICAgIHVzdWFsbHkgdGhlIHJhbmdlIHRoYXQgd2FzIGFkZGVkIGxhc3QpLlxuICAgICovXG4gICAgbWFpbkluZGV4KSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLm1haW5JbmRleCA9IG1haW5JbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgc2VsZWN0aW9uIHRocm91Z2ggYSBjaGFuZ2UuIFVzZWQgdG8gYWRqdXN0IHRoZSBzZWxlY3Rpb25cbiAgICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAociA9PiByLm1hcChjaGFuZ2UsIGFzc29jKSksIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHNlbGVjdGlvbiB0byBhbm90aGVyIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gb3RoZXIucmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5tYWluSW5kZXggIT0gb3RoZXIubWFpbkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lcShvdGhlci5yYW5nZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gMyA6IE1hdGgubWluKDIsIGJpZGlMZXZlbCkpIHxcbiAgICAgICAgICAgICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIGxldCBnb2FsID0gKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDMzNTU0NDMxIC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiBoZWFkIDwgYW5jaG9yID8gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGhlYWQsIGFuY2hvciwgMTYgLyogUmFuZ2VGbGFnLkludmVydGVkICovIHwgZ29hbCB8IDggLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8pXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIGdvYWwgfCAoaGVhZCA+IGFuY2hvciA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVkKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBsZXQgbWFpbiA9IHJhbmdlc1ttYWluSW5kZXhdO1xuICAgICAgICByYW5nZXMuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgbWFpbkluZGV4ID0gcmFuZ2VzLmluZGV4T2YobWFpbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwcmV2LnRvIDogcmFuZ2UuZnJvbSA8IHByZXYudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHByZXYuZnJvbSwgdG8gPSBNYXRoLm1heChyYW5nZS50bywgcHJldi50byk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPD0gbWFpbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICBtYWluSW5kZXgtLTtcbiAgICAgICAgICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSkgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NMZW5ndGgpIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAocmFuZ2UudG8gPiBkb2NMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwb2ludHMgb3V0c2lkZSBvZiBkb2N1bWVudFwiKTtcbn1cblxubGV0IG5leHRJRCA9IDA7XG4vKipcbkEgZmFjZXQgaXMgYSBsYWJlbGVkIHZhbHVlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIGVkaXRvclxuc3RhdGUuIEl0IHRha2VzIGlucHV0cyBmcm9tIGFueSBudW1iZXIgb2YgZXh0ZW5zaW9ucywgYW5kIGNvbWJpbmVzXG50aG9zZSBpbnRvIGEgc2luZ2xlIG91dHB1dCB2YWx1ZS5cblxuRXhhbXBsZXMgb2YgdXNlcyBvZiBmYWNldHMgYXJlIHRoZSBbdGFiXG5zaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpLCBbZWRpdG9yXG5hdHRyaWJ1dGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0b3JBdHRyaWJ1dGVzKSwgYW5kIFt1cGRhdGVcbmxpc3RlbmVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedXBkYXRlTGlzdGVuZXIpLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgc3RhdGljOiB0cnVlIH0pO1xuLyoqXG5GaWVsZHMgY2FuIHN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW4gYW4gZWRpdG9yIHN0YXRlLCBhbmRcbmtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSByZXN0IG9mIHRoZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGF0ZUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcbiAgICAgICAgdGhpcy51cGRhdGVGID0gdXBkYXRlRjtcbiAgICAgICAgdGhpcy5jb21wYXJlRiA9IGNvbXBhcmVGO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0YXRlIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gbmV3IFN0YXRlRmllbGQobmV4dElEKyssIGNvbmZpZy5jcmVhdGUsIGNvbmZpZy51cGRhdGUsIGNvbmZpZy5jb21wYXJlIHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcucHJvdmlkZSlcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCkuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcyk7XG4gICAgICAgIHJldHVybiAoKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVwZGF0ZUYob2xkVmFsLCB0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW3RoaXMuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRTdGF0ZS5maWVsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgICB3YXkgaXQgaXMgaW5pdGlhbGl6ZWQuIENhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBwcm92aWRlIGFcbiAgICBub24tZGVmYXVsdCBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpZWxkLlxuICAgICovXG4gICAgaW5pdChjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLCBpbml0RmllbGQub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlIH0pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxuICAgIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmNvbnN0IFByZWNfID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xuICAgIHJldHVybiAoZXh0KSA9PiBuZXcgUHJlY0V4dGVuc2lvbihleHQsIHZhbHVlKTtcbn1cbi8qKlxuQnkgZGVmYXVsdCBleHRlbnNpb25zIGFyZSByZWdpc3RlcmVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZFxuaW4gdGhlIGZsYXR0ZW5lZCBmb3JtIG9mIG5lc3RlZCBhcnJheSB0aGF0IHdhcyBwcm92aWRlZC5cbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXG5vdmVycmlkZSB0aGlzLiBFeHRlbnNpb25zIHRoYXQgZG8gbm90IGhhdmUgYSBwcmVjZWRlbmNlIHNldCBnZXRcbnRoZSBwcmVjZWRlbmNlIG9mIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIGEgcHJlY2VkZW5jZSwgb3JcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXG5maW5hbCBvcmRlcmluZyBvZiBleHRlbnNpb25zIGlzIGRldGVybWluZWQgYnkgZmlyc3Qgc29ydGluZyBieVxucHJlY2VkZW5jZSBhbmQgdGhlbiBieSBvcmRlciB3aXRoaW4gZWFjaCBwcmVjZWRlbmNlLlxuKi9cbmNvbnN0IFByZWMgPSB7XG4gICAgLyoqXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgc3RhcnQgb2YgdGhlIHByZWNlZGVuY2Ugb3JkZXJpbmcuXG4gICAgKi9cbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcbiAgICAvKipcbiAgICBBIGhpZ2hlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZSwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGRcbiAgICBjb21lIGJlZm9yZSB0aG9zZSB3aXRoIGRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGhpZ2g6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmRlZmF1bHQpLFxuICAgIC8qKlxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBsb3c6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvdyksXG4gICAgLyoqXG4gICAgVGhlIGxvd2VzdCBwcmVjZWRlbmNlIGxldmVsLiBNZWFudCBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAgICovXG4gICAgbG93ZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3dlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnRzID0gY29tcGFydG1lbnRzO1xuICAgICAgICB0aGlzLmR5bmFtaWNTbG90cyA9IGR5bmFtaWNTbG90cztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0aWNWYWx1ZXMgPSBzdGF0aWNWYWx1ZXM7XG4gICAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWNGYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCBvbGRTdGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBmYWNldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbmV3Q29tcGFydG1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKGZhY2V0c1tleHQuZmFjZXQuaWRdIHx8IChmYWNldHNbZXh0LmZhY2V0LmlkXSA9IFtdKSkucHVzaChleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0YXRpY1ZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY1Nsb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgYWRkcmVzc1tmaWVsZC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGZpZWxkLnNsb3QoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRGYWNldHMgPSBvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuY29uZmlnLmZhY2V0cztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZmFjZXRzKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkRmFjZXRzICYmIG9sZEZhY2V0c1tpZF0gfHwgW107XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzLmV2ZXJ5KHAgPT4gcC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIGlmIChzYW1lQXJyYXkob2xkUHJvdmlkZXJzLCBwcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlLmZhY2V0KGZhY2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmYWNldC5jb21iaW5lKHByb3ZpZGVycy5tYXAocCA9PiBwLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKHAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gcC5keW5hbWljU2xvdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGJhc2UsIG5ld0NvbXBhcnRtZW50cywgZHluYW1pYywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oZXh0ZW5zaW9uLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBbW10sIFtdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA8PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBQcmVjXy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi87XG4gICAgbGV0IGlkeCA9IGFkZHIgPj4gMTtcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XG4gICAgaWYgKHN0YXR1cyA9PSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovO1xuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XG4gICAgcmV0dXJuIHN0YXRlLnN0YXR1c1tpZHhdID0gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogZmFsc2Vcbn0pO1xuXG4vKipcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXG50cmFuc2FjdGlvbnMgaW4gYW4gZXh0ZW5zaWJsZSB3YXkuIFRoZXkgc2hvdWxkIGJlIHVzZWQgdG8gbW9kZWxcbnRoaW5ncyB0aGF0IGVmZmVjdCB0aGUgZW50aXJlIHRyYW5zYWN0aW9uIChzdWNoIGFzIGl0cyBbdGltZVxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXG5bb3JpZ2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkpLiBGb3IgZWZmZWN0cyB0aGF0IGhhcHBlblxuX2Fsb25nc2lkZV8gdGhlIG90aGVyIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24sIFtzdGF0ZVxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXG4qL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYW5ub3RhdGlvbiB0eXBlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHR5cGUgb2YgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxufVxuLyoqXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uVHlwZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXG5bYFN0YXRlRWZmZWN0LmRlZmluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReZGVmaW5lKS5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGBhbnlgIHR5cGVzIGluIHRoZXNlIGZ1bmN0aW9uIHR5cGVzIGFyZSB0aGVyZSB0byB3b3JrXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxuICAgIC8vIGBTdGF0ZUVmZmVjdC5pc2AgbXlzdGVyaW91c2x5IHN0b3BzIHdvcmtpbmcgd2hlbiB0aGVzZSBwcm9wZXJseVxuICAgIC8vIGhhdmUgdHlwZSBgVmFsdWVgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbc3RhdGUgZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBpbnN0YW5jZSBvZiB0aGlzXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgU3RhdGVFZmZlY3QodGhpcywgdmFsdWUpOyB9XG59XG4vKipcblN0YXRlIGVmZmVjdHMgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGFkZGl0aW9uYWwgZWZmZWN0c1xuYXNzb2NpYXRlZCB3aXRoIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmVmZmVjdHMpLiBUaGV5XG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxuZmllbGRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpLCB3aGVuIHRob3NlIGNoYW5nZXMgYXJlbid0IGltcGxpY2l0IGluXG5kb2N1bWVudCBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxuICAgIGB1bmRlZmluZWRgIHdoZW4gdGhhdCBlbmRzIHVwIGRlbGV0aW5nIHRoZSBlZmZlY3QuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy50eXBlLm1hcCh0aGlzLnZhbHVlLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWFwcGVkID09IHRoaXMudmFsdWUgPyB0aGlzIDogbmV3IFN0YXRlRWZmZWN0KHRoaXMudHlwZSwgbWFwcGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxuICAgICovXG4gICAgaXModHlwZSkgeyByZXR1cm4gdGhpcy50eXBlID09IHR5cGU7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZWZmZWN0IHR5cGUuIFRoZSB0eXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIHR5cGVcbiAgICBvZiB2YWx1ZXMgdGhhdCBoaXMgZWZmZWN0IGhvbGRzLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdFR5cGUoc3BlYy5tYXAgfHwgKHYgPT4gdikpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYW4gYXJyYXkgb2YgZWZmZWN0cyB0aHJvdWdoIGEgY2hhbmdlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXBFZmZlY3RzKGVmZmVjdHMsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhpcyBlZmZlY3QgY2FuIGJlIHVzZWQgdG8gcmVjb25maWd1cmUgdGhlIHJvb3QgZXh0ZW5zaW9ucyBvZlxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcblthcHBlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5hcHBlbmRDb25maWcpLCBidXQgZG9lcyBub3QgcmVzZXRcbnRoZSBjb250ZW50IG9mIFtyZWNvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpXG5jb21wYXJ0bWVudHMuXG4qL1xuU3RhdGVFZmZlY3QucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XG5kaXNwYXRjaCBvbmUgYnkgY2FsbGluZ1xuW2BFZGl0b3JWaWV3LmRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb250cmFyeSB0b1xuICAgIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcbiAgICByZWNvbW1lbmRlZCB0aGF0IFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBuZXdEb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcbiAgICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgICB0aGlzIHdpbGwgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ubWFwKSB0aGUgc3RhcnQgc3RhdGUnc1xuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgbmV3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gICAgKGJ1dCByZXRhaW5lZCBmb3Igc3Vic2VxdWVudCBhY2Nlc3MpLCBzbyBpdCBpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSBbdXNlclxuICAgIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cbiAgICBoYXMgYFwic2VsZWN0LnBvaW50ZXJcImAgYXMgdXNlciBldmVudCwgYFwic2VsZWN0XCJgIGFuZFxuICAgIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICAgKi9cbiAgICBpc1VzZXJFdmVudChldmVudCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XG4gICAgfVxufVxuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gc3RvcmUgdHJhbnNhY3Rpb24gdGltZXN0YW1wcy4gQXV0b21hdGljYWxseVxuYWRkZWQgdG8gZXZlcnkgdHJhbnNhY3Rpb24sIGhvbGRpbmcgYERhdGUubm93KClgLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIGFzc29jaWF0ZSBhIHRyYW5zYWN0aW9uIHdpdGggYSB1c2VyIGludGVyZmFjZVxuZXZlbnQuIEhvbGRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBldmVudCwgdXNpbmcgYVxuZG90LXNlcGFyYXRlZCBmb3JtYXQgdG8gc3VwcG9ydCBhdHRhY2hpbmcgbW9yZSBzcGVjaWZpY1xuaW5mb3JtYXRpb24uIFRoZSBldmVudHMgdXNlZCBieSB0aGUgY29yZSBsaWJyYXJpZXMgYXJlOlxuXG4gLSBgXCJpbnB1dFwiYCB3aGVuIGNvbnRlbnQgaXMgZW50ZXJlZFxuICAgLSBgXCJpbnB1dC50eXBlXCJgIGZvciB0eXBlZCBpbnB1dFxuICAgICAtIGBcImlucHV0LnR5cGUuY29tcG9zZVwiYCBmb3IgY29tcG9zaXRpb25cbiAgIC0gYFwiaW5wdXQucGFzdGVcImAgZm9yIHBhc3RlZCBpbnB1dFxuICAgLSBgXCJpbnB1dC5kcm9wXCJgIHdoZW4gYWRkaW5nIGNvbnRlbnQgd2l0aCBkcmFnLWFuZC1kcm9wXG4gICAtIGBcImlucHV0LmNvbXBsZXRlXCJgIHdoZW4gYXV0b2NvbXBsZXRpbmdcbiAtIGBcImRlbGV0ZVwiYCB3aGVuIHRoZSB1c2VyIGRlbGV0ZXMgY29udGVudFxuICAgLSBgXCJkZWxldGUuc2VsZWN0aW9uXCJgIHdoZW4gZGVsZXRpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuZm9yd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGZvcndhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5iYWNrd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuY3V0XCJgIHdoZW4gY3V0dGluZyB0byB0aGUgY2xpcGJvYXJkXG4gLSBgXCJtb3ZlXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZFxuICAgLSBgXCJtb3ZlLmRyb3BcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkIHdpdGhpbiB0aGUgZWRpdG9yIHRocm91Z2ggZHJhZy1hbmQtZHJvcFxuIC0gYFwic2VsZWN0XCJgIHdoZW4gZXhwbGljaXRseSBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcInNlbGVjdC5wb2ludGVyXCJgIHdoZW4gc2VsZWN0aW5nIHdpdGggYSBtb3VzZSBvciBvdGhlciBwb2ludGluZyBkZXZpY2VcbiAtIGBcInVuZG9cImAgYW5kIGBcInJlZG9cImAgZm9yIGhpc3RvcnkgYWN0aW9uc1xuXG5Vc2UgW2Bpc1VzZXJFdmVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uaXNVc2VyRXZlbnQpIHRvIGNoZWNrXG53aGV0aGVyIHRoZSBhbm5vdGF0aW9uIG1hdGNoZXMgYSBnaXZlbiBldmVudC5cbiovXG5UcmFuc2FjdGlvbi51c2VyRXZlbnQgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG9cbnRoZSB1bmRvIGhpc3Rvcnkgb3Igbm90LlxuKi9cblRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgKHdoZW4gcHJlc2VudCBhbmQgdHJ1ZSkgdGhhdCBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXG5pcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gdGFnIG90aGVyIHBlb3BsZSdzIGNoYW5nZXMgaW5cbmNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiovXG5UcmFuc2FjdGlvbi5yZW1vdGUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGpvaW5SYW5nZXMoYSwgYikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xuICAgICAgICAgICAgZnJvbSA9IGFbaUErK107XG4gICAgICAgICAgICB0byA9IGFbaUErK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaUIgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbSA9IGJbaUIrK107XG4gICAgICAgICAgICB0byA9IGJbaUIrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2FjdGlvbihhLCBiLCBzZXF1ZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xuICAgIGlmIChzZXF1ZW50aWFsKSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXM7XG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShiLmNoYW5nZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcy5tYXAoYS5jaGFuZ2VzKTtcbiAgICAgICAgbWFwRm9yQiA9IGEuY2hhbmdlcy5tYXBEZXNjKGIuY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiBiLnNlbGVjdGlvbiA/IGIuc2VsZWN0aW9uLm1hcChtYXBGb3JCKSA6IChfYSA9IGEuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1hcEZvckEpLFxuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGEuZWZmZWN0cywgbWFwRm9yQSkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYi5lZmZlY3RzLCBtYXBGb3JCKSksXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IGEuc2Nyb2xsSW50b1ZpZXcgfHwgYi5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlYywgZG9jU2l6ZSkge1xuICAgIGxldCBzZWwgPSBzcGVjLnNlbGVjdGlvbiwgYW5ub3RhdGlvbnMgPSBhc0FycmF5KHNwZWMuYW5ub3RhdGlvbnMpO1xuICAgIGlmIChzcGVjLnVzZXJFdmVudClcbiAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKHNwZWMudXNlckV2ZW50KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogc3BlYy5jaGFuZ2VzIGluc3RhbmNlb2YgQ2hhbmdlU2V0ID8gc3BlYy5jaGFuZ2VzXG4gICAgICAgICAgICA6IENoYW5nZVNldC5vZihzcGVjLmNoYW5nZXMgfHwgW10sIGRvY1NpemUsIHN0YXRlLmZhY2V0KGxpbmVTZXBhcmF0b3IpKSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWwgJiYgKHNlbCBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IHNlbCA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoc2VsLmFuY2hvciwgc2VsLmhlYWQpKSxcbiAgICAgICAgZWZmZWN0czogYXNBcnJheShzcGVjLmVmZmVjdHMpLFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc3BlYy5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIHNwZWNzLCBmaWx0ZXIpIHtcbiAgICBsZXQgcyA9IHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjcy5sZW5ndGggPyBzcGVjc1swXSA6IHt9LCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICBpZiAoc3BlY3MubGVuZ3RoICYmIHNwZWNzWzBdLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcSA9ICEhc3BlY3NbaV0uc2VxdWVudGlhbDtcbiAgICAgICAgcyA9IG1lcmdlVHJhbnNhY3Rpb24ocywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzW2ldLCBzZXEgPyBzLmNoYW5nZXMubmV3TGVuZ3RoIDogc3RhdGUuZG9jLmxlbmd0aCksIHNlcSk7XG4gICAgfVxuICAgIGxldCB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgcy5jaGFuZ2VzLCBzLnNlbGVjdGlvbiwgcy5lZmZlY3RzLCBzLmFubm90YXRpb25zLCBzLnNjcm9sbEludG9WaWV3KTtcbiAgICByZXR1cm4gZXh0ZW5kVHJhbnNhY3Rpb24oZmlsdGVyID8gZmlsdGVyVHJhbnNhY3Rpb24odHIpIDogdHIpO1xufVxuLy8gRmluaXNoIGEgdHJhbnNhY3Rpb24gYnkgYXBwbHlpbmcgZmlsdGVycyBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGU7XG4gICAgLy8gQ2hhbmdlIGZpbHRlcnNcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoY2hhbmdlRmlsdGVyKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIodHIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdHJ1ZSA/IHZhbHVlIDogam9pblJhbmdlcyhyZXN1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICBsZXQgY2hhbmdlcywgYmFjaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhY2sgPSB0ci5jaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICAgICAgICAgIGNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkoc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0ci5jaGFuZ2VzLmZpbHRlcihyZXN1bHQpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGZpbHRlcmVkLmNoYW5nZXM7XG4gICAgICAgICAgICBiYWNrID0gZmlsdGVyZWQuZmlsdGVyZWQubWFwRGVzYyhmaWx0ZXJlZC5jaGFuZ2VzKS5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHNwZWMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBleHRlbnNpb24sIHRyLmNoYW5nZXMubmV3TGVuZ3RoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGVjID09IHRyID8gdHIgOiBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHRyLmNoYW5nZXMsIHRyLnNlbGVjdGlvbiwgc3BlYy5lZmZlY3RzLCBzcGVjLmFubm90YXRpb25zLCBzcGVjLnNjcm9sbEludG9WaWV3KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5vbmUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLyoqXG5UaGUgY2F0ZWdvcmllcyBwcm9kdWNlZCBieSBhIFtjaGFyYWN0ZXJcbmNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikuIFRoZXNlIGFyZSB1c2VkXG5kbyB0aGluZ3MgbGlrZSBzZWxlY3RpbmcgYnkgd29yZC5cbiovXG52YXIgQ2hhckNhdGVnb3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2hhckNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgV29yZCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xuICAgIC8qKlxuICAgIFdoaXRlc3BhY2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiU3BhY2VcIl0gPSAxXSA9IFwiU3BhY2VcIjtcbiAgICAvKipcbiAgICBBbnl0aGluZyBlbHNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIk90aGVyXCJdID0gMl0gPSBcIk90aGVyXCI7XG5yZXR1cm4gQ2hhckNhdGVnb3J5fSkoQ2hhckNhdGVnb3J5IHx8IChDaGFyQ2F0ZWdvcnkgPSB7fSkpO1xuY29uc3Qgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG5sZXQgd29yZENoYXI7XG50cnkge1xuICAgIHdvcmRDaGFyID0gLypAX19QVVJFX18qL25ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuZnVuY3Rpb24gaGFzV29yZENoYXIoc3RyKSB7XG4gICAgaWYgKHdvcmRDaGFyKVxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaCA9IHN0cltpXTtcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yaXplcih3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGFyLmluZGV4T2Yod29yZENoYXJzW2ldKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5PdGhlcjtcbiAgICB9O1xufVxuXG4vKipcblRoZSBlZGl0b3Igc3RhdGUgY2xhc3MgaXMgYSBwZXJzaXN0ZW50IChpbW11dGFibGUpIGRhdGEgc3RydWN0dXJlLlxuVG8gdXBkYXRlIGEgc3RhdGUsIHlvdSBbY3JlYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkgYVxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxuaW5zdGFuY2UsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxuanVzdCBicmVhayB0aGluZ3MuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgY29tcHV0ZVNsb3QsIHRyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gY29tcHV0ZVNsb3Q7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYgPSBDb25maWd1cmF0aW9uLnJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGVTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0aGlzLmRvYywgdGhpcy5zZWxlY3Rpb24sIGNvbmYuZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LnJlY29uZmlndXJlKHN0YXRlLCB0aGlzKSwgbnVsbCk7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdHIubmV3RG9jLCB0ci5uZXdTZWxlY3Rpb24sIHN0YXJ0VmFsdWVzLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QudXBkYXRlKHN0YXRlLCB0ciksIHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSB0aGF0XG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy50b1RleHQodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4gKHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgICBmdW5jdGlvbiBmb3IgZWFjaCByYW5nZSBpbiB0aGUgYWN0aXZlIHNlbGVjdGlvbi4gVGhlIGZ1bmN0aW9uXG4gICAgY2FuIHJldHVybiBhbiBvcHRpb25hbCBzZXQgb2YgY2hhbmdlcyAoaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gICAgc3BhY2Ugb2YgdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSBjYWxsJ3Mgb3duIGNoYW5nZXMpLiBUaGlzXG4gICAgbWV0aG9kIHdpbGwgbWVyZ2UgYWxsIHRoZSBjaGFuZ2VzIGFuZCByYW5nZXMgaW50byBhIHNpbmdsZVxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gICAgc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpLCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B1cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4gICAgKi9cbiAgICBjaGFuZ2VCeVJhbmdlKGYpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdDEuY2hhbmdlcyksIHJhbmdlcyA9IFtyZXN1bHQxLnJhbmdlXTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBhc0FycmF5KHJlc3VsdDEuZWZmZWN0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYoc2VsLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICBsZXQgbmV3Q2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksIG5ld01hcHBlZCA9IG5ld0NoYW5nZXMubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLm1hcChuZXdNYXBwZWQpO1xuICAgICAgICAgICAgbGV0IG1hcEJ5ID0gY2hhbmdlcy5tYXBEZXNjKG5ld0NoYW5nZXMsIHRydWUpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29tcG9zZShuZXdNYXBwZWQpO1xuICAgICAgICAgICAgZWZmZWN0cyA9IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZWZmZWN0cywgbmV3TWFwcGVkKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhc0FycmF5KHJlc3VsdC5lZmZlY3RzKSwgbWFwQnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxuICAgICAgICAgICAgZWZmZWN0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpIGZyb20gdGhlIGdpdmVuIGNoYW5nZVxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXG4gICAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KVxuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcbiAgICBzZXBhcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvciksIGNyZWF0ZSBhXG4gICAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBUZXh0Lm9mKHN0cmluZy5zcGxpdCh0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgICAqL1xuICAgIHNsaWNlRG9jKGZyb20gPSAwLCB0byA9IHRoaXMuZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIHRoaXMubGluZUJyZWFrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHN0YXRlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldCkuXG4gICAgKi9cbiAgICBmYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0LmRlZmF1bHQ7XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgICBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIChpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxuICAgICovXG4gICAgdG9KU09OKGZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9jOiB0aGlzLnNsaWNlRG9jKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbdmFsdWUuaWRdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zZWxlY3Rpb24pLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogY29uZmlnLmV4dGVuc2lvbnMgPyBmaWVsZEluaXQuY29uY2F0KFtjb25maWcuZXh0ZW5zaW9uc10pIDogZmllbGRJbml0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cbiAgICBpbml0aWFsaXppbmcgYW4gZWRpdG9yXHUyMDE0dXBkYXRlZCBzdGF0ZXMgYXJlIGNyZWF0ZWQgYnkgYXBwbHlpbmdcbiAgICB0cmFuc2FjdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGNvbmZpZy5leHRlbnNpb25zIHx8IFtdLCBuZXcgTWFwKTtcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xuICAgICAgICAgICAgOiBUZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbiwgY29uZmlndXJhdGlvbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QuY3JlYXRlKHN0YXRlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICBcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cbiAgICBwbGFjZSBvZiBtYXJrZXJzIGxpa2UgYCQxYCAoZm9yIHRoZSBmaXJzdCB2YWx1ZSkgYW5kIGAkMmAsIGV0Yy5cbiAgICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXG4gICAgKi9cbiAgICBwaHJhc2UocGhyYXNlLCAuLi5pbnNlcnQpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSkge1xuICAgICAgICAgICAgICAgIHBocmFzZSA9IG1hcFtwaHJhc2VdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW4gfHwgbiA+IGluc2VydC5sZW5ndGggPyBtIDogaW5zZXJ0W24gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXG4gICAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICAgIFxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxuICAgIFxuICAgIC0gW2BcImNvbW1lbnRUb2tlbnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgZm9yIHNwZWNpZnlpbmdcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxuICAgIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgICAgZm9yIHByb3ZpZGluZyBsYW5ndWFnZS1zcGVjaWZpYyBjb21wbGV0aW9uIHNvdXJjZXMuXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xuICAgICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgICAgbGFuZ3VhZ2UuXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xuICAgICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAgICovXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm92aWRlciBvZiB0aGlzLmZhY2V0KGxhbmd1YWdlRGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyZXN1bHRbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXG4gICAgaW50byBvbmUgb2Y6XG4gICAgXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxuICAgICAgIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBsb2NhbCBsYW5ndWFnZSdzIGBcIndvcmRDaGFyc1wiYFxuICAgICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxuICAgICAtIE90aGVyIChhbnl0aGluZyBlbHNlKVxuICAgICovXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIodGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCkuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICAgIGNvbnRhaW5pbmcgYWxsIFt3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSBjaGFyYWN0ZXJzXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcbiAgICB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAqL1xuICAgIHdvcmRBdChwb3MpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCA9PSBlbmQgPyBudWxsIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSk7XG4gICAgfVxufVxuLyoqXG5BIGZhY2V0IHRoYXQsIHdoZW4gZW5hYmxlZCwgY2F1c2VzIHRoZSBlZGl0b3IgdG8gYWxsb3cgbXVsdGlwbGVcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcbmVkaXRvciByZWxpZXMgb24gdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uLCB3aGljaCBjYW5ub3QgaGFuZGxlXG5tdWx0aXBsZSBzZWxlY3Rpb25zLiBBbiBleHRlbnNpb24gbGlrZVxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2VcbnNlY29uZGFyeSBzZWxlY3Rpb25zIHZpc2libGUgdG8gdGhlIHVzZXIuXG4qL1xuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcbi8qKlxuQ29uZmlndXJlcyB0aGUgdGFiIHNpemUgdG8gdXNlIGluIHRoaXMgc3RhdGUuIFRoZSBmaXJzdFxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXG5naXZlbiwgdGhpcyBkZWZhdWx0cyB0byA0LlxuKi9cbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblRoaXMgZmFjZXQgY29udHJvbHMgdGhlIHZhbHVlIG9mIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcbmNvbnN1bHRlZCBieSBjb21tYW5kcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGltcGxlbWVudCBlZGl0aW5nXG5mdW5jdGlvbmFsaXR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgc2hvdWxkIGFwcGx5LiBJdFxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcbmB0cnVlYCwgc3VjaCBmdW5jdGlvbmFsaXR5IGRpc2FibGVzIGl0c2VsZi5cblxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcbltgRWRpdG9yVmlldy5lZGl0YWJsZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRhYmxlKSwgd2hpY2hcbmNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvcidzIERPTSBpcyBzZXQgdG8gYmUgZWRpdGFibGUgKGFuZFxudGh1cyBmb2N1c2FibGUpLlxuKi9cbkVkaXRvclN0YXRlLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLyoqXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcbm9iamVjdCBmcm9tIGFuIGFycmF5IG9mIHByb3ZpZGVkIGNvbmZpZ3MuIGBkZWZhdWx0c2Agc2hvdWxkIGhvbGRcbmRlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgZmllbGRzIGluIGBDb25maWdgLlxuXG5UaGUgZnVuY3Rpb24gd2lsbCwgYnkgZGVmYXVsdCwgZXJyb3JcbndoZW4gYSBmaWVsZCBnZXRzIHR3byB2YWx1ZXMgdGhhdCBhcmVuJ3QgYD09PWAtZXF1YWwsIGJ1dCB5b3UgY2FuXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cbiovXG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIGRlZmF1bHRzLCAvLyBTaG91bGQgaG9sZCBvbmx5IHRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIENvbmZpZywgYnV0IEkgaGF2ZW4ndCBtYW5hZ2VkIHRvIGV4cHJlc3MgdGhhdFxuY29tYmluZSA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29uZmlnW2tleV0sIGN1cnJlbnQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPT09IHZhbHVlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIDsgLy8gTm8gY29uZmxpY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbWJpbmUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZyBtZXJnZSBjb25mbGljdCBmb3IgZmllbGQgXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKVxuICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFVzZWQgd2hlbiBjb21wYXJpbmdcbiAgICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xuICAgIG9mIHlvdXIgdmFsdWUgdHlwZSwgaXQgaXMgYSBnb29kIGlkZWEgdG8gaW1wbGVtZW50IHRoaXNcbiAgICBwcm9wZXJseS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzID09IG90aGVyOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXG4gICAgKi9cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIFJhbmdlLmNyZWF0ZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xuLyoqXG5BIHJhbmdlIGFzc29jaWF0ZXMgYSB2YWx1ZSB3aXRoIGEgcmFuZ2Ugb2YgcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcFJhbmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyBDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcbiAgICAvLyBDaHVua3MgYXJlIG1hcmtlZCB3aXRoIHRoZSBsYXJnZXN0IHBvaW50IHRoYXQgb2NjdXJzXG4gICAgLy8gaW4gdGhlbSAob3IgLTEgZm9yIG5vIHBvaW50cyksIHNvIHRoYXQgc2NhbnMgdGhhdCBhcmVcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxuICAgIC8vIGhlaWdodG1hcC1yZWxhdGVkIGxvZ2ljKSBjYW4gc2tpcCByYW5nZS1vbmx5IGNodW5rcy5cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50b1t0aGlzLnRvLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcbiAgICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICAgIGZpbmRJbmRleChwb3MsIHNpZGUsIGVuZCwgc3RhcnRBdCA9IDApIHtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XG4gICAgICAgIGZvciAobGV0IGxvID0gc3RhcnRBdCwgaGkgPSBhcnIubGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFyclttaWRdIC0gcG9zIHx8IChlbmQgPyB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSA6IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUpIC0gc2lkZTtcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPj0gMCA/IGxvIDogaGk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZXR3ZWVuKG9mZnNldCwgZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5zdGFydFNpZGUgIT0gdmFsLmVuZFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vKipcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxud2F5IHRoYXQgbWFrZXMgdGhlbSBlZmZpY2llbnQgdG8gW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC5tYXApIGFuZFxuW3VwZGF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC51cGRhdGUpLiBUaGlzIGlzIGFuIGltbXV0YWJsZSBkYXRhXG5zdHJ1Y3R1cmUuXG4qL1xuY2xhc3MgUmFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2h1bmsubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubmV4dExheWVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXG4gICAgICAgICAgICBzaXplICs9IGNodW5rLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHJhbmdlIHNldCwgb3B0aW9uYWxseSBhZGRpbmcgbmV3IHJhbmdlcyBvciBmaWx0ZXJpbmdcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cbiAgICBcbiAgICAoTm90ZTogVGhlIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXG4gICAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgICBgWWAuKVxuICAgICovXG4gICAgdXBkYXRlKHVwZGF0ZVNwZWMpIHtcbiAgICAgICAgbGV0IHsgYWRkID0gW10sIHNvcnQgPSBmYWxzZSwgZmlsdGVyRnJvbSA9IDAsIGZpbHRlclRvID0gdGhpcy5sZW5ndGggfSA9IHVwZGF0ZVNwZWM7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcbiAgICAgICAgaWYgKGFkZC5sZW5ndGggPT0gMCAmJiAhZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChzb3J0KVxuICAgICAgICAgICAgYWRkID0gYWRkLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xuICAgICAgICBsZXQgY3VyID0gbmV3IExheWVyQ3Vyc29yKHRoaXMsIG51bGwsIC0xKS5nb3RvKDApLCBpID0gMCwgc3BpbGwgPSBbXTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYWRkLmxlbmd0aCAmJiAoY3VyLmZyb20gLSBhZGRbaV0uZnJvbSB8fCBjdXIuc3RhcnRTaWRlIC0gYWRkW2ldLnZhbHVlLnN0YXJ0U2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGFkZFtpKytdO1xuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChpID09IGFkZC5sZW5ndGggfHwgdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgPCBhZGRbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgfHwgZmlsdGVyVG8gPCB0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSkgJiZcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjdXIubmV4dENodW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gY3VyLnRvIHx8IGZpbHRlclRvIDwgY3VyLmZyb20gfHwgZmlsdGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2hJbm5lcih0aGlzLm5leHRMYXllci5pc0VtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxuICAgICovXG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxuICAgIGNhbGxpbmcgYGZgIGZvciBlYWNoLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2VzIHdpbGxcbiAgICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXG4gICAgKi9cbiAgICBiZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIHRoaXMgc2V0LCBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXG4gICAgKi9cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gdGhpcy5uZXh0TGF5ZXIgPT0gdGhpczsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIGEgY29sbGVjdGlvbiBvZiBzZXRzLCBpbiBvcmRlcixcbiAgICBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpdGVyKHNldHMsIGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oc2V0cykuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHR3byBncm91cHMgb2Ygc2V0cywgY2FsbGluZyBtZXRob2RzIG9uIGBjb21wYXJhdG9yYFxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlKG9sZFNldHMsIG5ld1NldHMsIFxuICAgIC8qKlxuICAgIFRoaXMgaW5kaWNhdGVzIGhvdyB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZWQgYmV0d2VlbiB0aGVzZVxuICAgIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLiBgZnJvbWAgYW5kXG4gICAgYHRvYCBhcmUgY29vcmRpbmF0ZXMgaW4gdGhlIF9uZXdfIHNwYWNlLCBhZnRlciB0aGVzZSBjaGFuZ2VzLlxuICAgICovXG4gICAgdGV4dERpZmYsIGNvbXBhcmF0b3IsIFxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIHRoZSBnaXZlbiBzaXplLiBXaGVuIC0xLCBhbGwgcmFuZ2VzIGFyZSBjb21wYXJlZC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgdGV4dERpZmYuaXRlckdhcHMoKGZyb21BLCBmcm9tQiwgbGVuZ3RoKSA9PiBjb21wYXJlKHNpZGVBLCBmcm9tQSwgc2lkZUIsIGZyb21CLCBsZW5ndGgsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgaWYgKHRleHREaWZmLmVtcHR5ICYmIHRleHREaWZmLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXG4gICAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovIC0gMTtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBvbGRTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKSwgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxuICAgICAgICAgICAgICAgICFzYW1lVmFsdWVzKHNpZGVBLmFjdGl2ZSwgc2lkZUIuYWN0aXZlKSB8fFxuICAgICAgICAgICAgICAgIHNpZGVBLnBvaW50ICYmICghc2lkZUIucG9pbnQgfHwgIXNpZGVBLnBvaW50LmVxKHNpZGVCLnBvaW50KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XG4gICAgICAgICAgICBzaWRlQi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxuICAgIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIG9mIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgc3BhbnMoc2V0cywgZnJvbSwgdG8sIGl0ZXJhdG9yLCBcbiAgICAvKipcbiAgICBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICBzaXplIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlbiA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byksIG9wZW4sIGN1cnNvci5wb2ludFJhbmspO1xuICAgICAgICAgICAgICAgIG9wZW4gPSBjdXJzb3Iub3BlbkVuZChjdXJUbykgKyAoY3Vyc29yLnRvID4gY3VyVG8gPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3Blbik7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuayhuZXdBcnJheXMpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgQ2h1bmsodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnZhbHVlLCB0aGlzLm1heFBvaW50KSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIHRoaXMubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIGlmIChuZXdBcnJheXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHJhbmdlLiBSYW5nZXMgc2hvdWxkIGJlIGFkZGVkIGluIHNvcnRlZCAoYnkgYGZyb21gIGFuZFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICAqL1xuICAgIGFkZChmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXG4gICAgICAgICAgICAodGhpcy5uZXh0TGF5ZXIgfHwgKHRoaXMubmV4dExheWVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcikpLmFkZChmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYW5nZVNldC5jcmVhdGUodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnb3RvSW5uZXIocG9zLCBzaWRlLCBmb3J3YXJkKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoISh0aGlzLnNraXAgJiYgdGhpcy5za2lwLmhhcyhuZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIuY2h1bmtFbmQodGhpcy5jaHVua0luZGV4KSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWZvcndhcmQgfHwgdGhpcy5yYW5nZUluZGV4IDwgcmFuZ2VJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgocmFuZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2h1bmtQb3MgKyBjaHVuay5mcm9tW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaHVuay52YWx1ZVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSBvdGhlci50byB8fCB0aGlzLmVuZFNpZGUgLSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbn1cbmNsYXNzIEhlYXBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYXApIHtcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0cywgc2tpcCA9IG51bGwsIG1pblBvaW50ID0gLTEpIHtcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBzZXRzW2ldOyAhY3VyLmlzRW1wdHk7IGN1ciA9IGN1ci5uZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBoZWFwLnB1c2gobmV3IExheWVyQ3Vyc29yKGN1ciwgc2tpcCwgbWluUG9pbnQsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT0gMSA/IGhlYXBbMF0gOiBuZXcgSGVhcEN1cnNvcihoZWFwKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRvcC5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHRvcC50bztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSB0b3AucmFuaztcbiAgICAgICAgICAgIGlmICh0b3AudmFsdWUpXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhlYXBCdWJibGUoaGVhcCwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gKGluZGV4IDw8IDEpICsgMTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPj0gaGVhcC5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGNoaWxkID0gaGVhcFtjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggKyAxIDwgaGVhcC5sZW5ndGggJiYgY2hpbGQuY29tcGFyZShoZWFwW2NoaWxkSW5kZXggKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFwW2NoaWxkSW5kZXhdID0gY3VyO1xuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBpbmRleCA9IGNoaWxkSW5kZXg7XG4gICAgfVxufVxuY2xhc3MgU3BhbkN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc2V0cywgc2tpcCwgbWluUG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICAvLyBBIGN1cnJlbnRseSBhY3RpdmUgcG9pbnQgcmFuZ2UsIGlmIGFueVxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludEZyb20gPSAwO1xuICAgICAgICB0aGlzLnBvaW50UmFuayA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIHRoaXMuYWN0aXZlUmFua1tpXSA8PSByYW5rKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG8sIHdhc1BvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFja09wZW4gPSB0aGlzLm9wZW5TdGFydCA8IDAgPyBbXSA6IG51bGwsIHRyYWNrRXh0cmEgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvci5mcm9tIDwgZnJvbSAmJiB0aGlzLmN1cnNvci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0V4dHJhKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IuZnJvbSA8IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0V4dHJhID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG9wZW5TdGFydCA8IHRyYWNrT3Blbi5sZW5ndGggJiYgdHJhY2tPcGVuW29wZW5TdGFydF0gPCBmcm9tKVxuICAgICAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQgKyB0cmFja0V4dHJhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvICsgZFBvcyksIGIuYWN0aXZlRm9yUG9pbnQoYi50bykpKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVQb2ludChwb3MsIGNsaXBFbmQsIGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaXBFbmQgPiBwb3MgJiYgIXNhbWVWYWx1ZXMoYS5hY3RpdmUsIGIuYWN0aXZlKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IGVuZEIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICBpZiAoZGlmZiA8PSAwKVxuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lVmFsdWVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0gJiYgIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBlID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA8IGU7IGkrKylcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgYXJyYXkucG9wKCk7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pXG4gICAgICAgIGFycmF5W2kgKyAxXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZE1pbkluZGV4KHZhbHVlLCBhcnJheSkge1xuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKChhcnJheVtpXSAtIGZvdW5kUG9zIHx8IHZhbHVlW2ldLmVuZFNpZGUgLSB2YWx1ZVtmb3VuZF0uZW5kU2lkZSkgPCAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBmb3VuZFBvcyA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkNvdW50IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbnRvIHRoZSBzdHJpbmcsXG50YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC5cbiovXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIHRhYlNpemUsIHRvID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvOykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSkge1xuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBjb2x1bW4gcG9zaXRpb24gaW4gYVxuc3RyaW5nLCB0YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC4gQnlcbmRlZmF1bHQsIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIHJldHVybmVkIHdoZW4gaXQgaXMgdG9vIHNob3J0IHRvXG5yZWFjaCB0aGUgY29sdW1uLiBQYXNzIGBzdHJpY3RgIHRydWUgdG8gbWFrZSBpdCByZXR1cm4gLTEgaW4gdGhhdFxuc2l0dWF0aW9uLlxuKi9cbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBjb2wsIHRhYlNpemUsIHN0cmljdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gMDs7KSB7XG4gICAgICAgIGlmIChuID49IGNvbClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBpZiAoaSA9PSBzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG4gKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSA/IHRhYlNpemUgLSAobiAlIHRhYlNpemUpIDogMTtcbiAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdCA9PT0gdHJ1ZSA/IC0xIDogc3RyaW5nLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUsIENoYW5nZURlc2MsIENoYW5nZVNldCwgQ2hhckNhdGVnb3J5LCBDb21wYXJ0bWVudCwgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgRmFjZXQsIExpbmUsIE1hcE1vZGUsIFByZWMsIFJhbmdlLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBSYW5nZVZhbHVlLCBTZWxlY3Rpb25SYW5nZSwgU3RhdGVFZmZlY3QsIFN0YXRlRWZmZWN0VHlwZSwgU3RhdGVGaWVsZCwgVGV4dCwgVHJhbnNhY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBjb3VudENvbHVtbiwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgZnJvbUNvZGVQb2ludCB9O1xuIiwgImNvbnN0IEMgPSBcIlxcdTAzN2NcIlxuY29uc3QgQ09VTlQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fXCIgKyBDIDogU3ltYm9sLmZvcihDKVxuY29uc3QgU0VUID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX3N0eWxlU2V0XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpIDogU3ltYm9sKFwic3R5bGVTZXRcIilcbmNvbnN0IHRvcCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge31cblxuLy8gOjogLSBTdHlsZSBtb2R1bGVzIGVuY2Fwc3VsYXRlIGEgc2V0IG9mIENTUyBydWxlcyBkZWZpbmVkIGZyb21cbi8vIEphdmFTY3JpcHQuIFRoZWlyIGRlZmluaXRpb25zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBhIGdpdmVuIERPTVxuLy8gcm9vdCBhZnRlciBpdCBoYXMgYmVlbiBfbW91bnRlZF8gdGhlcmUgd2l0aCBgU3R5bGVNb2R1bGUubW91bnRgLlxuLy9cbi8vIFN0eWxlIG1vZHVsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgb25jZSBhbmQgc3RvcmVkIHNvbWV3aGVyZSwgYXNcbi8vIG9wcG9zZWQgdG8gcmUtY3JlYXRpbmcgdGhlbSBldmVyeSB0aW1lIHlvdSBuZWVkIHRoZW0uIFRoZSBhbW91bnQgb2Zcbi8vIENTUyBydWxlcyBnZW5lcmF0ZWQgZm9yIGEgZ2l2ZW4gRE9NIHJvb3QgaXMgYm91bmRlZCBieSB0aGUgYW1vdW50XG4vLyBvZiBzdHlsZSBtb2R1bGVzIHRoYXQgd2VyZSB1c2VkLiBTbyB0byBhdm9pZCBsZWFraW5nIHJ1bGVzLCBkb24ndFxuLy8gY3JlYXRlIHRoZXNlIGR5bmFtaWNhbGx5LCBidXQgdHJlYXQgdGhlbSBhcyBvbmUtdGltZSBhbGxvY2F0aW9ucy5cbmV4cG9ydCBjbGFzcyBTdHlsZU1vZHVsZSB7XG4gIC8vIDo6IChPYmplY3Q8U3R5bGU+LCA/e2ZpbmlzaDogPyhzdHJpbmcpIFx1MjE5MiBzdHJpbmd9KVxuICAvLyBDcmVhdGUgYSBzdHlsZSBtb2R1bGUgZnJvbSB0aGUgZ2l2ZW4gc3BlYy5cbiAgLy9cbiAgLy8gV2hlbiBgZmluaXNoYCBpcyBnaXZlbiwgaXQgaXMgY2FsbGVkIG9uIHJlZ3VsYXIgKG5vbi1gQGApXG4gIC8vIHNlbGVjdG9ycyAoYWZ0ZXIgYCZgIGV4cGFuc2lvbikgdG8gY29tcHV0ZSB0aGUgZmluYWwgc2VsZWN0b3IuXG4gIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzID0gW11cbiAgICBsZXQge2ZpbmlzaH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICBmdW5jdGlvbiBzcGxpdFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gL15ALy50ZXN0KHNlbGVjdG9yKSA/IFtzZWxlY3Rvcl0gOiBzZWxlY3Rvci5zcGxpdCgvLFxccyovKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcihzZWxlY3RvcnMsIHNwZWMsIHRhcmdldCwgaXNLZXlmcmFtZXMpIHtcbiAgICAgIGxldCBsb2NhbCA9IFtdLCBpc0F0ID0gL15AKFxcdyspXFxiLy5leGVjKHNlbGVjdG9yc1swXSksIGtleWZyYW1lcyA9IGlzQXQgJiYgaXNBdFsxXSA9PSBcImtleWZyYW1lc1wiXG4gICAgICBpZiAoaXNBdCAmJiBzcGVjID09IG51bGwpIHJldHVybiB0YXJnZXQucHVzaChzZWxlY3RvcnNbMF0gKyBcIjtcIilcbiAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdmFsdWUgPSBzcGVjW3Byb3BdXG4gICAgICAgIGlmICgvJi8udGVzdChwcm9wKSkge1xuICAgICAgICAgIHJlbmRlcihwcm9wLnNwbGl0KC8sXFxzKi8pLm1hcChwYXJ0ID0+IHNlbGVjdG9ycy5tYXAoc2VsID0+IHBhcnQucmVwbGFjZSgvJi8sIHNlbCkpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKSxcbiAgICAgICAgICAgICAgICAgdmFsdWUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmICghaXNBdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSAoXCIgKyBwcm9wICsgXCIpIHNob3VsZCBiZSBhIHByaW1pdGl2ZSB2YWx1ZS5cIilcbiAgICAgICAgICByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgdmFsdWUsIGxvY2FsLCBrZXlmcmFtZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGxvY2FsLnB1c2gocHJvcC5yZXBsYWNlKC9fLiovLCBcIlwiKS5yZXBsYWNlKC9bQS1aXS9nLCBsID0+IFwiLVwiICsgbC50b0xvd2VyQ2FzZSgpKSArIFwiOiBcIiArIHZhbHVlICsgXCI7XCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb2NhbC5sZW5ndGggfHwga2V5ZnJhbWVzKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKChmaW5pc2ggJiYgIWlzQXQgJiYgIWlzS2V5ZnJhbWVzID8gc2VsZWN0b3JzLm1hcChmaW5pc2gpIDogc2VsZWN0b3JzKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIiB7XCIgKyBsb2NhbC5qb2luKFwiIFwiKSArIFwifVwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHNwZWNbcHJvcF0sIHRoaXMucnVsZXMpXG4gIH1cblxuICAvLyA6OiAoKSBcdTIxOTIgc3RyaW5nXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kdWxlJ3MgQ1NTIHJ1bGVzLlxuICBnZXRSdWxlcygpIHsgcmV0dXJuIHRoaXMucnVsZXMuam9pbihcIlxcblwiKSB9XG5cbiAgLy8gOjogKCkgXHUyMTkyIHN0cmluZ1xuICAvLyBHZW5lcmF0ZSBhIG5ldyB1bmlxdWUgQ1NTIGNsYXNzIG5hbWUuXG4gIHN0YXRpYyBuZXdOYW1lKCkge1xuICAgIGxldCBpZCA9IHRvcFtDT1VOVF0gfHwgMVxuICAgIHRvcFtDT1VOVF0gPSBpZCArIDFcbiAgICByZXR1cm4gQyArIGlkLnRvU3RyaW5nKDM2KVxuICB9XG5cbiAgLy8gOjogKHVuaW9uPERvY3VtZW50LCBTaGFkb3dSb290PiwgdW5pb248W1N0eWxlTW9kdWxlXSwgU3R5bGVNb2R1bGU+KVxuICAvL1xuICAvLyBNb3VudCB0aGUgZ2l2ZW4gc2V0IG9mIG1vZHVsZXMgaW4gdGhlIGdpdmVuIERPTSByb290LCB3aGljaCBlbnN1cmVzXG4gIC8vIHRoYXQgdGhlIENTUyBydWxlcyBkZWZpbmVkIGJ5IHRoZSBtb2R1bGUgYXJlIGF2YWlsYWJsZSBpbiB0aGF0XG4gIC8vIGNvbnRleHQuXG4gIC8vXG4gIC8vIFJ1bGVzIGFyZSBvbmx5IGFkZGVkIHRvIHRoZSBkb2N1bWVudCBvbmNlIHBlciByb290LlxuICAvL1xuICAvLyBSdWxlIG9yZGVyIHdpbGwgZm9sbG93IHRoZSBvcmRlciBvZiB0aGUgbW9kdWxlcywgc28gdGhhdCBydWxlcyBmcm9tXG4gIC8vIG1vZHVsZXMgbGF0ZXIgaW4gdGhlIGFycmF5IHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBmcm9tIGVhcmxpZXJcbiAgLy8gbW9kdWxlcy4gSWYgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcm9vdFxuICAvLyBpbiBhIHdheSB0aGF0IGNoYW5nZXMgdGhlIG9yZGVyIG9mIGFscmVhZHkgbW91bnRlZCBtb2R1bGVzLCB0aGUgb2xkXG4gIC8vIG9yZGVyIHdpbGwgYmUgY2hhbmdlZC5cbiAgc3RhdGljIG1vdW50KHJvb3QsIG1vZHVsZXMpIHtcbiAgICAocm9vdFtTRVRdIHx8IG5ldyBTdHlsZVNldChyb290KSkubW91bnQoQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc10pXG4gIH1cbn1cblxubGV0IGFkb3B0ZWRTZXQgPSBudWxsXG5cbmNsYXNzIFN0eWxlU2V0IHtcbiAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgIGlmICghcm9vdC5oZWFkICYmIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzICYmIHR5cGVvZiBDU1NTdHlsZVNoZWV0ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChhZG9wdGVkU2V0KSB7XG4gICAgICAgIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW2Fkb3B0ZWRTZXQuc2hlZXRdLmNvbmNhdChyb290LmFkb3B0ZWRTdHlsZVNoZWV0cylcbiAgICAgICAgcmV0dXJuIHJvb3RbU0VUXSA9IGFkb3B0ZWRTZXRcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldFxuICAgICAgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbdGhpcy5zaGVldF0uY29uY2F0KHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzKVxuICAgICAgYWRvcHRlZFNldCA9IHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZVRhZyA9IChyb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCkuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpXG4gICAgICBsZXQgdGFyZ2V0ID0gcm9vdC5oZWFkIHx8IHJvb3RcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZVRhZywgdGFyZ2V0LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHRoaXMubW9kdWxlcyA9IFtdXG4gICAgcm9vdFtTRVRdID0gdGhpc1xuICB9XG5cbiAgbW91bnQobW9kdWxlcykge1xuICAgIGxldCBzaGVldCA9IHRoaXMuc2hlZXRcbiAgICBsZXQgcG9zID0gMCAvKiBDdXJyZW50IHJ1bGUgb2Zmc2V0ICovLCBqID0gMCAvKiBJbmRleCBpbnRvIHRoaXMubW9kdWxlcyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1vZCA9IG1vZHVsZXNbaV0sIGluZGV4ID0gdGhpcy5tb2R1bGVzLmluZGV4T2YobW9kKVxuICAgICAgaWYgKGluZGV4IDwgaiAmJiBpbmRleCA+IC0xKSB7IC8vIE9yZGVyaW5nIGNvbmZsaWN0XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIGotLVxuICAgICAgICBpbmRleCA9IC0xXG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShqKyssIDAsIG1vZClcbiAgICAgICAgaWYgKHNoZWV0KSBmb3IgKGxldCBrID0gMDsgayA8IG1vZC5ydWxlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKG1vZC5ydWxlc1trXSwgcG9zKyspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoaiA8IGluZGV4KSBwb3MgKz0gdGhpcy5tb2R1bGVzW2orK10ucnVsZXMubGVuZ3RoXG4gICAgICAgIHBvcyArPSBtb2QucnVsZXMubGVuZ3RoXG4gICAgICAgIGorK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hlZXQpIHtcbiAgICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZHVsZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHRleHQgKz0gdGhpcy5tb2R1bGVzW2ldLmdldFJ1bGVzKCkgKyBcIlxcblwiXG4gICAgICB0aGlzLnN0eWxlVGFnLnRleHRDb250ZW50ID0gdGV4dFxuICAgIH1cbiAgfVxufVxuXG4vLyBTdHlsZTo6T2JqZWN0PHVuaW9uPFN0eWxlLHN0cmluZz4+XG4vL1xuLy8gQSBzdHlsZSBpcyBhbiBvYmplY3QgdGhhdCwgaW4gdGhlIHNpbXBsZSBjYXNlLCBtYXBzIENTUyBwcm9wZXJ0eVxuLy8gbmFtZXMgdG8gc3RyaW5ncyBob2xkaW5nIHRoZWlyIHZhbHVlcywgYXMgaW4gYHtjb2xvcjogXCJyZWRcIixcbi8vIGZvbnRXZWlnaHQ6IFwiYm9sZFwifWAuIFRoZSBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZ2l2ZW4gaW5cbi8vIGNhbWVsLWNhc2VcdTIwMTR0aGUgbGlicmFyeSB3aWxsIGluc2VydCBhIGRhc2ggYmVmb3JlIGNhcGl0YWwgbGV0dGVyc1xuLy8gd2hlbiBjb252ZXJ0aW5nIHRoZW0gdG8gQ1NTLlxuLy9cbi8vIElmIHlvdSBpbmNsdWRlIGFuIHVuZGVyc2NvcmUgaW4gYSBwcm9wZXJ0eSBuYW1lLCBpdCBhbmQgZXZlcnl0aGluZ1xuLy8gYWZ0ZXIgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIG91dHB1dCwgd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuXG4vLyBwcm92aWRpbmcgYSBwcm9wZXJ0eSBtdWx0aXBsZSB0aW1lcywgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuLy8gcmVhc29ucy5cbi8vXG4vLyBBIHByb3BlcnR5IGluIGEgc3R5bGUgb2JqZWN0IGNhbiBhbHNvIGJlIGEgc3ViLXNlbGVjdG9yLCB3aGljaFxuLy8gZXh0ZW5kcyB0aGUgY3VycmVudCBjb250ZXh0IHRvIGFkZCBhIHBzZXVkby1zZWxlY3RvciBvciBhIGNoaWxkXG4vLyBzZWxlY3Rvci4gU3VjaCBhIHByb3BlcnR5IHNob3VsZCBjb250YWluIGEgYCZgIGNoYXJhY3Rlciwgd2hpY2hcbi8vIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGN1cnJlbnQgc2VsZWN0b3IuIEZvciBleGFtcGxlIGB7XCImOmJlZm9yZVwiOlxuLy8ge2NvbnRlbnQ6ICdcImhpXCInfX1gLiBTdWItc2VsZWN0b3JzIGFuZCByZWd1bGFyIHByb3BlcnRpZXMgY2FuXG4vLyBmcmVlbHkgYmUgbWl4ZWQgaW4gYSBnaXZlbiBvYmplY3QuIEFueSBwcm9wZXJ0eSBjb250YWluaW5nIGEgYCZgIGlzXG4vLyBhc3N1bWVkIHRvIGJlIGEgc3ViLXNlbGVjdG9yLlxuLy9cbi8vIEZpbmFsbHksIGEgcHJvcGVydHkgY2FuIHNwZWNpZnkgYW4gQC1ibG9jayB0byBiZSB3cmFwcGVkIGFyb3VuZCB0aGVcbi8vIHN0eWxlcyBkZWZpbmVkIGluc2lkZSB0aGUgb2JqZWN0IHRoYXQncyB0aGUgcHJvcGVydHkncyB2YWx1ZS4gRm9yXG4vLyBleGFtcGxlIHRvIGNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IHlvdSBjYW4gZG8gYHtcIkBtZWRpYSBzY3JlZW4gYW5kXG4vLyAobWluLXdpZHRoOiA0MDBweClcIjogey4uLn19YC5cbiIsICJleHBvcnQgdmFyIGJhc2UgPSB7XG4gIDg6IFwiQmFja3NwYWNlXCIsXG4gIDk6IFwiVGFiXCIsXG4gIDEwOiBcIkVudGVyXCIsXG4gIDEyOiBcIk51bUxvY2tcIixcbiAgMTM6IFwiRW50ZXJcIixcbiAgMTY6IFwiU2hpZnRcIixcbiAgMTc6IFwiQ29udHJvbFwiLFxuICAxODogXCJBbHRcIixcbiAgMjA6IFwiQ2Fwc0xvY2tcIixcbiAgMjc6IFwiRXNjYXBlXCIsXG4gIDMyOiBcIiBcIixcbiAgMzM6IFwiUGFnZVVwXCIsXG4gIDM0OiBcIlBhZ2VEb3duXCIsXG4gIDM1OiBcIkVuZFwiLFxuICAzNjogXCJIb21lXCIsXG4gIDM3OiBcIkFycm93TGVmdFwiLFxuICAzODogXCJBcnJvd1VwXCIsXG4gIDM5OiBcIkFycm93UmlnaHRcIixcbiAgNDA6IFwiQXJyb3dEb3duXCIsXG4gIDQ0OiBcIlByaW50U2NyZWVuXCIsXG4gIDQ1OiBcIkluc2VydFwiLFxuICA0NjogXCJEZWxldGVcIixcbiAgNTk6IFwiO1wiLFxuICA2MTogXCI9XCIsXG4gIDkxOiBcIk1ldGFcIixcbiAgOTI6IFwiTWV0YVwiLFxuICAxMDY6IFwiKlwiLFxuICAxMDc6IFwiK1wiLFxuICAxMDg6IFwiLFwiLFxuICAxMDk6IFwiLVwiLFxuICAxMTA6IFwiLlwiLFxuICAxMTE6IFwiL1wiLFxuICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAxNjA6IFwiU2hpZnRcIixcbiAgMTYxOiBcIlNoaWZ0XCIsXG4gIDE2MjogXCJDb250cm9sXCIsXG4gIDE2MzogXCJDb250cm9sXCIsXG4gIDE2NDogXCJBbHRcIixcbiAgMTY1OiBcIkFsdFwiLFxuICAxNzM6IFwiLVwiLFxuICAxODY6IFwiO1wiLFxuICAxODc6IFwiPVwiLFxuICAxODg6IFwiLFwiLFxuICAxODk6IFwiLVwiLFxuICAxOTA6IFwiLlwiLFxuICAxOTE6IFwiL1wiLFxuICAxOTI6IFwiYFwiLFxuICAyMTk6IFwiW1wiLFxuICAyMjA6IFwiXFxcXFwiLFxuICAyMjE6IFwiXVwiLFxuICAyMjI6IFwiJ1wiXG59XG5cbmV4cG9ydCB2YXIgc2hpZnQgPSB7XG4gIDQ4OiBcIilcIixcbiAgNDk6IFwiIVwiLFxuICA1MDogXCJAXCIsXG4gIDUxOiBcIiNcIixcbiAgNTI6IFwiJFwiLFxuICA1MzogXCIlXCIsXG4gIDU0OiBcIl5cIixcbiAgNTU6IFwiJlwiLFxuICA1NjogXCIqXCIsXG4gIDU3OiBcIihcIixcbiAgNTk6IFwiOlwiLFxuICA2MTogXCIrXCIsXG4gIDE3MzogXCJfXCIsXG4gIDE4NjogXCI6XCIsXG4gIDE4NzogXCIrXCIsXG4gIDE4ODogXCI8XCIsXG4gIDE4OTogXCJfXCIsXG4gIDE5MDogXCI+XCIsXG4gIDE5MTogXCI/XCIsXG4gIDE5MjogXCJ+XCIsXG4gIDIxOTogXCJ7XCIsXG4gIDIyMDogXCJ8XCIsXG4gIDIyMTogXCJ9XCIsXG4gIDIyMjogXCJcXFwiXCJcbn1cblxudmFyIGNocm9tZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gbWFjIHx8IGNocm9tZSAmJiArY2hyb21lWzFdIDwgNTdcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIHZhciBpZ25vcmVLZXkgPSBicm9rZW5Nb2RpZmllck5hbWVzICYmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5KSB8fFxuICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIlxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgPyBzaGlmdCA6IGJhc2UpW2V2ZW50LmtleUNvZGVdIHx8XG4gICAgZXZlbnQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIlxuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICBpZiAobmFtZSA9PSBcIkxlZnRcIikgbmFtZSA9IFwiQXJyb3dMZWZ0XCJcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcbiAgaWYgKG5hbWUgPT0gXCJEb3duXCIpIG5hbWUgPSBcIkFycm93RG93blwiXG4gIHJldHVybiBuYW1lXG59XG4iLCAiaW1wb3J0IHsgVGV4dCwgUmFuZ2VTZXQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBmaW5kQ29sdW1uLCBDaGFyQ2F0ZWdvcnksIFRyYW5zYWN0aW9uLCBQcmVjLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUmFuZ2VTZXRCdWlsZGVyLCBjb3VudENvbHVtbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcbmltcG9ydCB7IGtleU5hbWUsIGJhc2UsIHNoaWZ0IH0gZnJvbSAndzNjLWtleW5hbWUnO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5jb25zdCBSZWN0MCA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwIH07XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QsIHNpZGUsIHgsIHksIHhNYXJnaW4sIHlNYXJnaW4sIGx0cikge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7IC8vIEVsZW1lbnRcbiAgICAgICAgICAgIGxldCBib3VuZGluZywgdG9wID0gY3VyID09IGRvYy5ib2R5O1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0gd2luZG93UmVjdCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPD0gY3VyLmNsaWVudEhlaWdodCAmJiBjdXIuc2Nyb2xsV2lkdGggPD0gY3VyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGN1ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgY3VyLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgY3VyLmNsaWVudEhlaWdodCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICAgICAgaWYgKHkgPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAocmVjdC50b3AgLSBtb3ZlWSkgPCBib3VuZGluZy50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wICsgbW92ZVkgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByZWN0SGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCwgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHkgPT0gXCJjZW50ZXJcIiAmJiByZWN0SGVpZ2h0IDw9IGJvdW5kaW5nSGVpZ2h0ID8gcmVjdC50b3AgKyByZWN0SGVpZ2h0IC8gMiAtIGJvdW5kaW5nSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgICAgICAgIHkgPT0gXCJzdGFydFwiIHx8IHkgPT0gXCJjZW50ZXJcIiAmJiBzaWRlIDwgMCA/IHJlY3QudG9wIC0geU1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmJvdHRvbSAtIGJvdW5kaW5nSGVpZ2h0ICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWSA9IHRhcmdldFRvcCAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBtb3ZlWCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCArIG1vdmVYIC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExlZnQgPSB4ID09IFwiY2VudGVyXCIgPyByZWN0LmxlZnQgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAyIC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHggPT0gXCJzdGFydFwiKSA9PSBsdHIgPyByZWN0LmxlZnQgLSB4TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QucmlnaHQgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVggPSB0YXJnZXRMZWZ0IC0gYm91bmRpbmcubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZWRYID0gMCwgbW92ZWRZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbFRvcCArPSBtb3ZlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWSA9IGN1ci5zY3JvbGxUb3AgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFggPSBjdXIuc2Nyb2xsTGVmdCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuc2V0KHJhbmdlLmFuY2hvck5vZGUsIHJhbmdlLmFuY2hvck9mZnNldCwgcmFuZ2UuZm9jdXNOb2RlLCByYW5nZS5mb2N1c09mZnNldCk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSA9PSBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBET01Qb3Mge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCwgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IHByZWNpc2U7XG4gICAgfVxuICAgIHN0YXRpYyBiZWZvcmUoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pLCBwcmVjaXNlKTsgfVxuICAgIHN0YXRpYyBhZnRlcihkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSkgKyAxLCBwcmVjaXNlKTsgfVxufVxuY29uc3Qgbm9DaGlsZHJlbiA9IFtdO1xuY2xhc3MgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IDIgLyogRGlydHkuTm9kZSAqLztcbiAgICB9XG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3NpbmcgdmlldyBpbiBvcnBoYW4gY29udGVudCB2aWV3XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZWRpdG9yVmlldztcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh2aWV3KSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB2aWV3KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBXaWxsIHJldHVybiBhIHJlY3RhbmdsZSBkaXJlY3RseSBiZWZvcmUgKHdoZW4gc2lkZSA8IDApLCBhZnRlclxuICAgIC8vIChzaWRlID4gMCkgb3IgZGlyZWN0bHkgb24gKHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQpIHRoZVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvb3Jkc0F0KF9wb3MsIF9zaWRlKSB7IHJldHVybiBudWxsOyB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAmIDIgLyogRGlydHkuTm9kZSAqLykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsLCBuZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRWaWV3IHx8ICFjb250ZW50Vmlldy5wYXJlbnQgJiYgY29udGVudFZpZXcuY2FuUmV1c2VET00oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IDAgLyogRGlydHkuTm90ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQuZG9tLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgdHJhY2sgJiYgdHJhY2subm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAobmV4dClcbiAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgMSAvKiBEaXJ0eS5DaGlsZCAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gMCAvKiBEaXJ0eS5Ob3QgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKF9kb20pIHsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGFmdGVyO1xuICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLmRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IG1heE9mZnNldChub2RlKSA9PSAwID8gMCA6IG9mZnNldCA9PSAwID8gLTEgOiAxO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXMgPT0gMCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09IHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlciA9PSB0aGlzLmRvbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHdoaWxlIChhZnRlciAmJiAhQ29udGVudFZpZXcuZ2V0KGFmdGVyKSlcbiAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmRvbSA9PSBhZnRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBmcm9tSSA9IC0xLCBmcm9tU3RhcnQgPSAtMSwgdG9JID0gLTEsIHRvRW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBvZmZzZXQsIHByZXZFbmQgPSBvZmZzZXQ7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBwb3MpO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBmcm9tICYmIGZyb21JID09IC0xKSB7XG4gICAgICAgICAgICAgICAgZnJvbUkgPSBpO1xuICAgICAgICAgICAgICAgIGZyb21TdGFydCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPiB0byAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRvSSA9IGk7XG4gICAgICAgICAgICAgICAgdG9FbmQgPSBwcmV2RW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkVuZCA9IGVuZDtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbVN0YXJ0LCB0bzogdG9FbmQgPCAwID8gb2Zmc2V0ICsgdGhpcy5sZW5ndGggOiB0b0VuZCxcbiAgICAgICAgICAgIHN0YXJ0RE9NOiAoZnJvbUkgPyB0aGlzLmNoaWxkcmVuW2Zyb21JIC0gMV0uZG9tLm5leHRTaWJsaW5nIDogbnVsbCkgfHwgdGhpcy5kb20uZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIGVuZERPTTogdG9JIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgdG9JID49IDAgPyB0aGlzLmNoaWxkcmVuW3RvSV0uZG9tIDogbnVsbCB9O1xuICAgIH1cbiAgICBtYXJrRGlydHkoYW5kUGFyZW50ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSB8PSAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eShhbmRQYXJlbnQpO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KGNoaWxkTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRMaXN0KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSB8PSAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgICAgICAgICBpZiAocGFyZW50LmRpcnR5ICYgMSAvKiBEaXJ0eS5DaGlsZCAqLylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwYXJlbnQuZGlydHkgfD0gMSAvKiBEaXJ0eS5DaGlsZCAqLztcbiAgICAgICAgICAgIGNoaWxkTGlzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RE9NKGRvbSkge1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmRvbS5jbVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgZG9tLmNtVmlldyA9IHRoaXM7XG4gICAgfVxuICAgIGdldCByb290VmlldygpIHtcbiAgICAgICAgZm9yIChsZXQgdiA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHYucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB2ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VDaGlsZHJlbihmcm9tLCB0bywgY2hpbGRyZW4gPSBub0NoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcylcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKF9yZWMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKFwiVmlld1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPyBcIltcIiArIChuYW1lID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy5icmVha0FmdGVyID8gXCIjXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldChub2RlKSB7IHJldHVybiBub2RlLmNtVmlldzsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3I7IH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzIENoaWxkQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvcyB8fCBwb3MgPT0gdGhpcy5wb3MgJiZcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmID0gcG9zIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bLS10aGlzLmldO1xuICAgICAgICAgICAgdGhpcy5wb3MgLT0gbmV4dC5sZW5ndGggKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuW2Zyb21JXSA6IG51bGw7XG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgbGV0IGJyZWFrQXRFbmQgPSBsYXN0ID8gbGFzdC5icmVha0FmdGVyIDogYnJlYWtBdFN0YXJ0O1xuICAgIC8vIENoYW5nZSB3aXRoaW4gYSBzaW5nbGUgY2hpbGRcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXG4gICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgaW5zZXJ0Lmxlbmd0aCA/IGxhc3QgOiBudWxsLCBmcm9tT2ZmID09IDAsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBjaGlsZCBhZnRlciB0aGUgdXBkYXRlIGlzIHByZXNlcnZlZCBpbiBgYWZ0ZXJgXG4gICAgICAgIGlmIChhZnRlciAmJiB0b09mZiA8IGFmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgY2hpbGQsIHNlcGFyYXRlIHBhcnQgb2YgaXQgdG8gYXZvaWQgdGhhdFxuICAgICAgICAgICAgLy8gYmVpbmcgbWFuZ2xlZCB3aGVuIHVwZGF0aW5nIHRoZSBjaGlsZCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNwbGl0KHRvT2ZmKTtcbiAgICAgICAgICAgICAgICB0b09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgcmVwbGFjZW1lbnQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByZXBsYWNpbmcgZWxlbWVudCwgdXBkYXRlIGBjb250ZW50YFxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZilcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIG51bGwsIGZhbHNlLCAwLCBvcGVuRW5kKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLmJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGl0cyBsaW5lIGJyZWFrLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2UndmUgaGFuZGxlZCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgLy8gbm93LCBtYWtlIHN1cmUgYHRvSWAgcG9pbnRzIGFmdGVyIHRoYXQuXG4gICAgICAgIHRvSSsrO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xuICAgICAgICBpZiAoZnJvbU9mZiA+IDApIHtcbiAgICAgICAgICAgIGlmICghYnJlYWtBdFN0YXJ0ICYmIGluc2VydC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGluc2VydFswXSwgZmFsc2UsIG9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tT2ZmIDwgYmVmb3JlLmxlbmd0aCB8fCBiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoICYmIGJlZm9yZS5jaGlsZHJlbltiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBtZXJnZSB3aWRnZXRzIG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSByZXBsYWNlbWVudFxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHRvSS0tO1xuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xuICAgICAgICAgICAgb3BlbkVuZCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgICAgIGluc2VydC5zaGlmdCgpO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgY2hpbGRyZW5bZnJvbUkgLSAxXSwgZmFsc2UsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIGZyb21JLS07XG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGRyZW4oZnJvbUksIHRvSSwgaW5zZXJ0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGluc2VydClcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcbiAgICBwYXJlbnQubGVuZ3RoICs9IGRMZW47XG4gICAgcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgMCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHNhZmFyaSxcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIHRhYlNpemU6IGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT0gdGhpcy5kb20gPyBvZmZzZXQgOiBvZmZzZXQgPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMuZG9tLCBwb3MpOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKF9mcm9tLCBfdG8sIG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aGlzLmxlbmd0aCwgc3RhcnRET006IHRoaXMuZG9tLCBlbmRET006IHRoaXMuZG9tLm5leHRTaWJsaW5nIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGV4dENvb3Jkcyh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5jbGFzcyBNYXJrVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXJrLCBjaGlsZHJlbiA9IFtdLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgY2guc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBzZXRBdHRycyhkb20pIHtcbiAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKGRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuY2xhc3MpXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gdGhpcy5tYXJrLmNsYXNzO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB0aGlzLm1hcmsuYXR0cnNbbmFtZV0pO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovIHwgMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDQgLyogRGlydHkuQXR0cnMgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IFtdLCBvcGVuU3RhcnQgLSAxLCBvcGVuRW5kIC0gMSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgb2ZmID0gMCwgZGV0YWNoRnJvbSA9IC0xLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyBlbHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2ZmIDwgZnJvbSA/IGVsdC5zcGxpdChmcm9tIC0gb2ZmKSA6IGVsdCk7XG4gICAgICAgICAgICBpZiAoZGV0YWNoRnJvbSA8IDAgJiYgb2ZmID49IGZyb20pXG4gICAgICAgICAgICAgICAgZGV0YWNoRnJvbSA9IGk7XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tO1xuICAgICAgICBpZiAoZGV0YWNoRnJvbSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGRldGFjaEZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXcodGhpcy5tYXJrLCByZXN1bHQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2lkZSA8IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICB9XG4gICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRleHQsIGZyb20sIHRvKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUmVjdDA7XG4gICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xuICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHdpZGdldC5jdXN0b21WaWV3IHx8IFdpZGdldFZpZXcpKHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gV2lkZ2V0Vmlldy5jcmVhdGUodGhpcy53aWRnZXQsIHRoaXMubGVuZ3RoIC0gZnJvbSwgdGhpcy5zaWRlKTtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gZnJvbTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odGhpcy5lZGl0b3JWaWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPT0gdGhpcy5sZW5ndGggJiYgb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lcShvdGhlci53aWRnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0b3AucGFyZW50KVxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgbGV0IHZpZXcgPSB0b3AuZWRpdG9yVmlldywgdGV4dCA9IHZpZXcgJiYgdmlldy5zdGF0ZS5kb2MsIHN0YXJ0ID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPT0gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHJlY3QgPSBudWxsO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBSZWN0MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyA+IDAgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKHBvcyA+IDAgPyAtMSA6IDEpKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA/IHJlY3QgOiBmbGF0dGVuUmVjdChyZWN0LCB0aGlzLnNpZGUgPiAwKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3IGV4dGVuZHMgV2lkZ2V0VmlldyB7XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IHRvcFZpZXcsIHRleHQgfSA9IHRoaXMud2lkZ2V0O1xuICAgICAgICBpZiAoIXRvcFZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwb3MsIHRleHQubm9kZVZhbHVlLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIDAsIHRvcFZpZXcsIHRleHQsICh2LCBwKSA9PiB2LmRvbUF0UG9zKHApLCBwID0+IG5ldyBET01Qb3ModGV4dCwgTWF0aC5taW4ocCwgdGV4dC5ub2RlVmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICBzeW5jKCkgeyB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSgpKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgIGlmICghdG9wVmlldylcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHBvc0Zyb21ET01JbkNvbXBvc2l0aW9uVHJlZShub2RlLCBvZmZzZXQsIHRvcFZpZXcsIHRleHQpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgIGlmICghdG9wVmlldylcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSk7XG4gICAgICAgIHJldHVybiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgc2lkZSwgdG9wVmlldywgdGV4dCwgKHYsIHBvcywgc2lkZSkgPT4gdi5jb29yZHNBdChwb3MsIHNpZGUpLCAocG9zLCBzaWRlKSA9PiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgKF9hID0gdGhpcy53aWRnZXQudG9wVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgY2FuUmV1c2VET00oKSB7IHJldHVybiB0cnVlOyB9XG59XG4vLyBVc2VzIHRoZSBvbGQgc3RydWN0dXJlIG9mIGEgY2h1bmsgb2YgY29udGVudCB2aWV3IGZyb3plbiBmb3Jcbi8vIGNvbXBvc2l0aW9uIHRvIHRyeSBhbmQgZmluZCBhIHJlYXNvbmFibGUgRE9NIGxvY2F0aW9uIGZvciB0aGUgZ2l2ZW5cbi8vIG9mZnNldC5cbmZ1bmN0aW9uIHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCB2aWV3LCB0ZXh0LCBlbnRlclZpZXcsIGZyb21UZXh0KSB7XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldykge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHZpZXcuZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IENvbnRlbnRWaWV3LmdldChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21UZXh0KHBvcywgc2lkZSk7XG4gICAgICAgICAgICBsZXQgaGFzQ29tcCA9IGNvbnRhaW5zKGNoaWxkLCB0ZXh0KTtcbiAgICAgICAgICAgIGxldCBsZW4gPSBkZXNjLmxlbmd0aCArIChoYXNDb21wID8gdGV4dC5ub2RlVmFsdWUubGVuZ3RoIDogMCk7XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuIHx8IHBvcyA9PSBsZW4gJiYgZGVzYy5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ29tcCA/IHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCBkZXNjLCB0ZXh0LCBlbnRlclZpZXcsIGZyb21UZXh0KSA6IGVudGVyVmlldyhkZXNjLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgcG9zIC09IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50ZXJWaWV3KHZpZXcsIHZpZXcubGVuZ3RoLCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuZG9tID09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21UZXh0KHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZW50ZXJWaWV3KHZpZXcsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcG9zRnJvbURPTUluQ29tcG9zaXRpb25UcmVlKG5vZGUsIG9mZnNldCwgdmlldywgdGV4dCkge1xuICAgIGlmICh2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygdmlldy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHBvcyA9IDAsIGhhc0NvbXAgPSBjb250YWlucyhjaGlsZC5kb20sIHRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGNoaWxkLmRvbSwgbm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyArIChoYXNDb21wID8gcG9zRnJvbURPTUluQ29tcG9zaXRpb25UcmVlKG5vZGUsIG9mZnNldCwgY2hpbGQsIHRleHQpIDogY2hpbGQubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgcG9zICs9IGhhc0NvbXAgPyB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGggOiBjaGlsZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5kb20gPT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ob2Zmc2V0LCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbn1cbi8vIFRoZXNlIGFyZSBkcmF3biBhcm91bmQgdW5lZGl0YWJsZSB3aWRnZXRzIHRvIGF2b2lkIGEgbnVtYmVyIG9mXG4vLyBicm93c2VyIGJ1Z3MgdGhhdCBzaG93IHVwIHdoZW4gdGhlIGN1cnNvciBpcyBkaXJlY3RseSBuZXh0IHRvXG4vLyB1bmVkaXRhYmxlIGlubGluZSBjb250ZW50LlxuY2xhc3MgV2lkZ2V0QnVmZmVyVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiAwOyB9XG4gICAgbWVyZ2UoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlO1xuICAgIH1cbiAgICBzcGxpdCgpIHsgcmV0dXJuIG5ldyBXaWRnZXRCdWZmZXJWaWV3KHRoaXMuc2lkZSk7IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiO1xuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICBsZXQgaW1nUmVjdCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBTaW5jZSB0aGUgPGltZz4gaGVpZ2h0IGRvZXNuJ3QgY29ycmVzcG9uZCB0byB0ZXh0IGhlaWdodCwgdHJ5XG4gICAgICAgIC8vIHRvIGJvcnJvdyB0aGUgaGVpZ2h0IGZyb20gc29tZSBzaWJsaW5nIG5vZGUuXG4gICAgICAgIGxldCBzaWJsaW5nUmVjdCA9IGlubGluZVNpYmxpbmdSZWN0KHRoaXMsIHRoaXMuc2lkZSA+IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2libGluZ1JlY3QgJiYgc2libGluZ1JlY3QudG9wIDwgaW1nUmVjdC5ib3R0b20gJiYgc2libGluZ1JlY3QuYm90dG9tID4gaW1nUmVjdC50b3BcbiAgICAgICAgICAgID8geyBsZWZ0OiBpbWdSZWN0LmxlZnQsIHJpZ2h0OiBpbWdSZWN0LnJpZ2h0LCB0b3A6IHNpYmxpbmdSZWN0LnRvcCwgYm90dG9tOiBzaWJsaW5nUmVjdC5ib3R0b20gfSA6IGltZ1JlY3Q7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgIH1cbn1cblRleHRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0QnVmZmVyVmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBub0NoaWxkcmVuO1xuZnVuY3Rpb24gaW5saW5lU2libGluZ1JlY3Qodmlldywgc2lkZSkge1xuICAgIGxldCBwYXJlbnQgPSB2aWV3LnBhcmVudCwgaW5kZXggPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih2aWV3KSA6IC0xO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgaW5kZXggPj0gMCkge1xuICAgICAgICBpZiAoc2lkZSA8IDAgPyBpbmRleCA+IDAgOiBpbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gcGFyZW50LmNoaWxkcmVuW2luZGV4ICsgc2lkZV07XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRleHRWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRSZWN0ID0gbmV4dC5jb29yZHNBdChzaWRlIDwgMCA/IG5leHQubGVuZ3RoIDogMCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRSZWN0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCArPSBzaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50LnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHBhcmVudCkgKyAoc2lkZSA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBwYXJlbnQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3Qubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0LmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaW5saW5lRE9NQXRQb3MocGFyZW50LCBwb3MpIHtcbiAgICBsZXQgZG9tID0gcGFyZW50LmRvbSwgeyBjaGlsZHJlbiB9ID0gcGFyZW50LCBpID0gMDtcbiAgICBmb3IgKGxldCBvZmYgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHBvcyA+IG9mZiAmJiBwb3MgPCBlbmQgJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XG4gICAgICAgIGlmIChwb3MgPD0gb2ZmKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgbGV0IHByZXYgPSBjaGlsZHJlbltqIC0gMV07XG4gICAgICAgIGlmIChwcmV2LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUF0UG9zKHByZXYubGVuZ3RoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICBpZiAobmV4dC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb21BdFBvcygwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBET01Qb3MoZG9tLCAwKTtcbn1cbi8vIEFzc3VtZXMgYHZpZXdgLCBpZiBhIG1hcmsgdmlldywgaGFzIHByZWNpc2VseSAxIGNoaWxkLlxuZnVuY3Rpb24gam9pbklubGluZUludG8ocGFyZW50LCB2aWV3LCBvcGVuKSB7XG4gICAgbGV0IGxhc3QsIHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBpZiAob3BlbiA+IDAgJiYgdmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAobGFzdCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGxhc3QubWFyay5lcSh2aWV3Lm1hcmspKSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKGxhc3QsIHZpZXcuY2hpbGRyZW5bMF0sIG9wZW4gLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2godmlldyk7XG4gICAgICAgIHZpZXcuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgfVxuICAgIHBhcmVudC5sZW5ndGggKz0gdmlldy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjb29yZHNJbkNoaWxkcmVuKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCBiZWZvcmUgPSBudWxsLCBiZWZvcmVQb3MgPSAtMSwgYWZ0ZXIgPSBudWxsLCBhZnRlclBvcyA9IC0xO1xuICAgIGZ1bmN0aW9uIHNjYW4odmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgdmlldy5jaGlsZHJlbi5sZW5ndGggJiYgb2ZmIDw9IHBvczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB2aWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbihjaGlsZCwgcG9zIC0gb2ZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFmdGVyICYmIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZnRlclBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmIDwgcG9zIHx8IChvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW4odmlldywgcG9zKTtcbiAgICBsZXQgdGFyZ2V0ID0gKHNpZGUgPCAwID8gYmVmb3JlIDogYWZ0ZXIpIHx8IGJlZm9yZSB8fCBhZnRlcjtcbiAgICBpZiAodGFyZ2V0KVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvb3Jkc0F0KE1hdGgubWF4KDAsIHRhcmdldCA9PSBiZWZvcmUgPyBiZWZvcmVQb3MgOiBhZnRlclBvcyksIHNpZGUpO1xuICAgIHJldHVybiBmYWxsYmFja1JlY3Qodmlldyk7XG59XG5mdW5jdGlvbiBmYWxsYmFja1JlY3Qodmlldykge1xuICAgIGxldCBsYXN0ID0gdmlldy5kb20ubGFzdENoaWxkO1xuICAgIGlmICghbGFzdClcbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGxhc3QpO1xuICAgIHJldHVybiByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXR0cnMoc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIgJiYgdGFyZ2V0LmNsYXNzKVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzICs9IFwiIFwiICsgc291cmNlLmNsYXNzO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgKz0gXCI7XCIgKyBzb3VyY2Uuc3R5bGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGF0dHJzRXEoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSB8fCAhYilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzQS5sZW5ndGggIT0ga2V5c0IubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cnMoZG9tLCBwcmV2LCBhdHRycykge1xuICAgIGxldCBjaGFuZ2VkID0gbnVsbDtcbiAgICBpZiAocHJldilcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKCEoYXR0cnMgJiYgbmFtZSBpbiBhdHRycykpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShjaGFuZ2VkID0gbmFtZSk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKCEocHJldiAmJiBwcmV2W25hbWVdID09IGF0dHJzW25hbWVdKSlcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKGNoYW5nZWQgPSBuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuICEhY2hhbmdlZDtcbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgY3VzdG9tVmlldygpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcbiAgICBmcm9tIHRoZSBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbi8qKlxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXG4qL1xudmFyIEJsb2NrVHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIC8qKlxuICAgIEEgbGluZSBvZiB0ZXh0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYWZ0ZXIgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QmVmb3JlXCJdID0gMV0gPSBcIldpZGdldEJlZm9yZVwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEFmdGVyXCJdID0gMl0gPSBcIldpZGdldEFmdGVyXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgW3JlcGxhY2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgYSByYW5nZSBvZiBjb250ZW50LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XG5yZXR1cm4gQmxvY2tUeXBlfSkoQmxvY2tUeXBlIHx8IChCbG9ja1R5cGUgPSB7fSkpO1xuLyoqXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxub2YgY29udGVudC4gWW91J2xsIHVzdWFsbHkgdXNlIGl0IHdyYXBwZWQgaW4gYVxuW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpLCB3aGljaCBhZGRzIGEgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbkBub25hYnN0cmFjdFxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0U2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbmRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdpZGdldCwgXG4gICAgLyoqXG4gICAgVGhlIGNvbmZpZyBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhpcyBkZWNvcmF0aW9uLiBZb3UgY2FuXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcbiAgICB5b3VyIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTaWRlID0gc3RhcnRTaWRlO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgICBjb250ZW50IGluIGl0cyByYW5nZS4gTmVzdGVkIG1hcmsgZGVjb3JhdGlvbnMgd2lsbCBjYXVzZSBuZXN0ZWRcbiAgICBET00gZWxlbWVudHMgdG8gYmUgY3JlYXRlZC4gTmVzdGluZyBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5XG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgICB0aGUgaGlnaGVyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMgY3JlYXRpbmcgdGhlIGlubmVyIERPTSBub2Rlcy5cbiAgICBTdWNoIGVsZW1lbnRzIGFyZSBzcGxpdCBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBzcGVjLnNpZGUgfHwgMCwgYmxvY2sgPSAhIXNwZWMuYmxvY2s7XG4gICAgICAgIHNpZGUgKz0gYmxvY2sgPyAoc2lkZSA+IDAgPyAzMDAwMDAwMDAgLyogU2lkZS5CbG9ja0FmdGVyICovIDogLTQwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQmVmb3JlICovKSA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBTaWRlLklubGluZUFmdGVyICovIDogLTEwMDAwMDAwMCAvKiBTaWRlLklubGluZUJlZm9yZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxuICAgIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XG4gICAgICAgIGxldCBibG9jayA9ICEhc3BlYy5ibG9jaywgc3RhcnRTaWRlLCBlbmRTaWRlO1xuICAgICAgICBpZiAoc3BlYy5pc0Jsb2NrR2FwKSB7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XG4gICAgICAgICAgICBlbmRTaWRlID0gNDAwMDAwMDAwIC8qIFNpZGUuR2FwRW5kICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrKTtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IChzdGFydCA/IChibG9jayA/IC0zMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY1N0YXJ0ICovIDogLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLykgOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLykgLSAxO1xuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8gOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLywgZW5kID8gMSAvKiBTaWRlLklubGluZUluY0VuZCAqLyA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8sIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmF0dHJpYnV0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3MgPT0gb3RoZXIuY2xhc3MgJiZcbiAgICAgICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTWFya0RlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5jbGFzcyBMaW5lRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiYgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgPCB0aGlzLmVuZFNpZGUgPyBCbG9ja1R5cGUuV2lkZ2V0UmFuZ2VcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBMaW5lVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgLy8gQ29uc3VtZXMgc291cmNlXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICBzb3VyY2UudHJhbnNmZXJET00odGhpcyk7IC8vIFJldXNlIHNvdXJjZS5kb20gd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdGFydClcbiAgICAgICAgICAgIHRoaXMuc2V0RGVjbyhzb3VyY2UgPyBzb3VyY2UuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IFtdLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2pdLCAwKTtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblstLWldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZChjaGlsZCwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKHRoaXMsIGNoaWxkLCBvcGVuU3RhcnQpO1xuICAgIH1cbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gICAgYWRkTGluZURlY28oZGVjbykge1xuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKGF0dHJzLCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoeyBjbGFzczogY2xzIH0sIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5IHw9IDQgLyogRGlydHkuQXR0cnMgKi8gfCAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlydHkgJiA0IC8qIERpcnR5LkF0dHJzICovKSB7XG4gICAgICAgICAgICBjbGVhckF0dHJpYnV0ZXModGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5wcmV2QXR0cnMsIHRoaXMuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChsYXN0ICYmIENvbnRlbnRWaWV3LmdldChsYXN0KSBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbGFzdCA9IGxhc3QubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgIXRoaXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBsYXN0Lm5vZGVOYW1lICE9IFwiQlJcIiAmJiAoKF9hID0gQ29udGVudFZpZXcuZ2V0KGxhc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAoIWJyb3dzZXIuaW9zIHx8ICF0aGlzLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUZXh0VmlldykpKSB7XG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcbiAgICAgICAgICAgIGhhY2suY21JZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgL1teIC1+XS8udGVzdChjaGlsZC50ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XG4gICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdG90YWxXaWR0aCA/IG51bGwgOiB7XG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICAgICAgICBjaGFyV2lkdGg6IHRvdGFsV2lkdGggLyB0aGlzLmxlbmd0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgYmVjb21lKF9vdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIEJsb2NrVHlwZS5UZXh0OyB9XG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgZG9jVmlldy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMubGVuZ3RoIC0gYXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMudHlwZSk7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odGhpcy5lZGl0b3JWaWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIG90aGVyLnR5cGUgPT0gdGhpcy50eXBlICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmVxKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IgPSBkaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIC8vIFNldCB0byBmYWxzZSBkaXJlY3RseSBhZnRlciBhIHdpZGdldCB0aGF0IGNvdmVycyB0aGUgcG9zaXRpb24gYWZ0ZXIgaXRcbiAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IC0xO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgICAgIHRoaXMuc2tpcCA9IHBvcztcbiAgICB9XG4gICAgcG9zQ292ZXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5icmVha0F0U3RhcnQgJiYgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tICE9IHRoaXMucG9zO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiAhbGFzdC5icmVha0FmdGVyICYmICEobGFzdCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBsYXN0LnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSk7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh0aGlzLmN1ckxpbmUgPSBuZXcgTGluZVZpZXcpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyTGluZTtcbiAgICB9XG4gICAgZmx1c2hCdWZmZXIoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KC0xKSwgYWN0aXZlKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCbG9ja1dpZGdldCh2aWV3KSB7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoW10pO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCFvcGVuRW5kKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihbXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgfVxuICAgIGJ1aWxkVGV4dChsZW5ndGgsIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmID09IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuIG91dCBvZiB0ZXh0IGNvbnRlbnQgd2hlbiBkcmF3aW5nIGlubGluZSB2aWV3c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoW10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoMCwgb3BlblN0YXJ0KSk7XG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hcHBlbmQod3JhcE1hcmtzKG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UodGhpcy50ZXh0T2ZmLCB0aGlzLnRleHRPZmYgKyB0YWtlKSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGV4dE9mZiArPSB0YWtlO1xuICAgICAgICAgICAgbGVuZ3RoIC09IHRha2U7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNwYW4oZnJvbSwgdG8sIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHRoaXMuYnVpbGRUZXh0KHRvIC0gZnJvbSwgYWN0aXZlLCBvcGVuU3RhcnQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvLCBhY3RpdmUsIG9wZW5TdGFydCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3JbaW5kZXhdICYmIGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQmxvY2sgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgICAgICBpZiAodG8gPiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGVjb3JhdGlvbnMgdGhhdCByZXBsYWNlIGxpbmUgYnJlYWtzIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IGRlY287XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmICF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9ja1dpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwiZGl2XCIpLCBsZW4sIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gV2lkZ2V0Vmlldy5jcmVhdGUoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJzcGFuXCIpLCBsZW4sIGxlbiA/IDAgOiBkZWNvLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvckJlZm9yZSA9IHRoaXMuYXRDdXJzb3JQb3MgJiYgIXZpZXcuaXNFZGl0YWJsZSAmJiBvcGVuU3RhcnQgPD0gYWN0aXZlLmxlbmd0aCAmJiAoZnJvbSA8IHRvIHx8IGRlY28uc3RhcnRTaWRlID4gMCk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvckFmdGVyID0gIXZpZXcuaXNFZGl0YWJsZSAmJiAoZnJvbSA8IHRvIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvckJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGFjdGl2ZS5sZW5ndGggKyBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IGN1cnNvckFmdGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9ICFjdXJzb3JBZnRlciA/IDAgLyogQnVmLk5vICovIDogZnJvbSA8IHRvID8gMSAvKiBCdWYuWWVzICovIDogMiAvKiBCdWYuSWZDdXJzb3IgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMsIGR5bmFtaWNEZWNvcmF0aW9uTWFwKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBkeW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XG4gICAgICAgIGlmIChidWlsZGVyLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICBidWlsZGVyLm9wZW5TdGFydCA9IGJ1aWxkZXIub3BlbkVuZDtcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSkge1xuICAgIGZvciAobGV0IG1hcmsgb2YgYWN0aXZlKVxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xuICAgIHJldHVybiB2aWV3O1xufVxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnRhZyA9PSB0aGlzLnRhZzsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7IHJldHVybiBlbHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLnRhZzsgfVxufVxuXG5jb25zdCBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGV4Y2VwdGlvblNpbmsgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHBlckxpbmVUZXh0RGlyZWN0aW9uID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3QgbmF0aXZlU2VsZWN0aW9uSGlkZGVuID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6IG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbik7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcbiAgICAgICAgd2luZG93Lm9uZXJyb3IoU3RyaW5nKGV4Y2VwdGlvbiksIGNvbnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xubGV0IG5leHRQbHVnaW5JRCA9IDA7XG5jb25zdCB2aWV3UGx1Z2luID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5WaWV3IHBsdWdpbnMgYXNzb2NpYXRlIHN0YXRlZnVsIHZhbHVlcyB3aXRoIGEgdmlldy4gVGhleSBjYW5cbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xudGhhdCBoYXBwZW4gaW4gdGhlIHZpZXcuXG4qL1xuY2xhc3MgVmlld1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRIYW5kbGVycywgYnVpbGRFeHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IGRvbUV2ZW50SGFuZGxlcnM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gYnVpbGRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIHByb3ZpZGUsIGRlY29yYXRpb25zOiBkZWNvIH0gPSBzcGVjIHx8IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdQbHVnaW4obmV4dFBsdWdpbklEKyssIGNyZWF0ZSwgZXZlbnRIYW5kbGVycywgcGx1Z2luID0+IHtcbiAgICAgICAgICAgIGxldCBleHQgPSBbdmlld1BsdWdpbi5vZihwbHVnaW4pXTtcbiAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKGRlY29yYXRpb25zLm9mKHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luSW5zdCA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5JbnN0ID8gZGVjbyhwbHVnaW5JbnN0KSA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZSlcbiAgICAgICAgICAgICAgICBleHQucHVzaChwcm92aWRlKHBsdWdpbikpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBmb3IgYSBjbGFzcyB3aG9zZSBjb25zdHJ1Y3RvciB0YWtlcyBhIHNpbmdsZVxuICAgIGVkaXRvciB2aWV3IGFzIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21DbGFzcyhjbHMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IGNscyh2aWV3KSwgc3BlYyk7XG4gICAgfVxufVxuY2xhc3MgUGx1Z2luSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLy8gV2hlbiBzdGFydGluZyBhbiB1cGRhdGUsIGFsbCBwbHVnaW5zIGhhdmUgdGhpcyBmaWVsZCBzZXQgdG8gdGhlXG4gICAgICAgIC8vIHVwZGF0ZSBvYmplY3QsIGluZGljYXRpbmcgdGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQuIFdoZW4gZmluaXNoZWRcbiAgICAgICAgLy8gdXBkYXRpbmcsIGl0IGlzIHNldCB0byBgZmFsc2VgLiBSZXRyaWV2aW5nIGEgcGx1Z2luIHRoYXQgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIGB2aWV3LnBsdWdpbmAgZm9yY2VzIGFuIGVhZ2VyIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBpcyBudWxsIHdoZW4gdGhlIHBsdWdpbiBpcyBpbml0aWFsbHkgY3JlYXRlZCwgYnV0XG4gICAgICAgIC8vIGluaXRpYWxpemVkIG9uIHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGUodmlldykge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zcGVjLmNyZWF0ZSh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubXVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IHRoaXMubXVzdFVwZGF0ZTtcbiAgICAgICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odXBkYXRlLnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3kodmlldykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnNwZWMgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG59XG5jb25zdCBlZGl0b3JBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgY29udGVudEF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vLyBQcm92aWRlIGRlY29yYXRpb25zXG5jb25zdCBkZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHNjcm9sbE1hcmdpbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBzdHlsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIENoYW5nZWRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikge1xuICAgICAgICB0aGlzLmZyb21BID0gZnJvbUE7XG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xuICAgICAgICB0aGlzLmZyb21CID0gZnJvbUI7XG4gICAgICAgIHRoaXMudG9CID0gdG9CO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlZFJhbmdlKE1hdGgubWluKHRoaXMuZnJvbUEsIG90aGVyLmZyb21BKSwgTWF0aC5tYXgodGhpcy50b0EsIG90aGVyLnRvQSksIE1hdGgubWluKHRoaXMuZnJvbUIsIG90aGVyLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIG90aGVyLnRvQikpO1xuICAgIH1cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzZXQubGVuZ3RoLCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZXRbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmZyb21BID4gbWUudG9BKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnRvQSA8IG1lLmZyb21BKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcbiAgICAgICAgICAgIHNldC5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGRJID0gMCwgckkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7OyBkSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRJID09IGRpZmYubGVuZ3RoID8gbnVsbCA6IGRpZmZbZEldLCBvZmYgPSBwb3NBIC0gcG9zQjtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tQiA6IDFlOTtcbiAgICAgICAgICAgIHdoaWxlIChySSA8IHJhbmdlcy5sZW5ndGggJiYgcmFuZ2VzW3JJXSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW3JJXSwgdG8gPSByYW5nZXNbckkgKyAxXTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1heChwb3NCLCBmcm9tKSwgdG9CID0gTWF0aC5taW4oZW5kLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CIDw9IHRvQilcbiAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShmcm9tQiArIG9mZiwgdG9CICsgb2ZmLCBmcm9tQiwgdG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGVuZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBySSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKG5leHQuZnJvbUEsIG5leHQudG9BLCBuZXh0LmZyb21CLCBuZXh0LnRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgIHBvc0EgPSBuZXh0LnRvQTtcbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuVmlldyBbcGx1Z2luc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pIGFyZSBnaXZlbiBpbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4qL1xuY2xhc3MgVmlld1VwZGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3IHRoYXQgdGhlIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgKi9cbiAgICB2aWV3LCBcbiAgICAvKipcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuY29tcG9zZSh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiBjaGFuZ2VkUmFuZ2VzLnB1c2gobmV3IENoYW5nZWRSYW5nZShmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZWRSYW5nZXMgPSBjaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICBpZiAoZm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3VXBkYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgW3ZpZXdwb3J0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aWV3cG9ydCkgb3JcbiAgICBbdmlzaWJsZSByYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpc2libGVSYW5nZXMpIGNoYW5nZWQgaW4gdGhpc1xuICAgIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaGVpZ2h0IG9mIGEgYmxvY2sgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gICAgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBoZWlnaHRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCB3YXMgbW9kaWZpZWQgb3IgdGhlIHNpemUgb2YgdGhlXG4gICAgZWRpdG9yLCBvciBlbGVtZW50cyB3aXRoaW4gdGhlIGVkaXRvciwgY2hhbmdlZC5cbiAgICAqL1xuICAgIGdldCBnZW9tZXRyeUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0NoYW5nZWQgfHwgKHRoaXMuZmxhZ3MgJiAoOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuLyoqXG5Vc2VkIHRvIGluZGljYXRlIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4qL1xudmFyIERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIC8vIChUaGVzZSBhcmUgY2hvc2VuIHRvIG1hdGNoIHRoZSBiYXNlIGxldmVscywgaW4gYmlkaSBhbGdvcml0aG1cbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxuICAgIC8qKlxuICAgIExlZnQtdG8tcmlnaHQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgIFJpZ2h0LXRvLWxlZnQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IExUUiA9IERpcmVjdGlvbi5MVFIsIFJUTCA9IERpcmVjdGlvbi5SVEw7XG4vLyBEZWNvZGUgYSBzdHJpbmcgd2l0aCBlYWNoIHR5cGUgZW5jb2RlZCBhcyBsb2cyKHR5cGUpXG5mdW5jdGlvbiBkZWMoc3RyKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XG5jb25zdCBMb3dUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKTtcbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCksIEJyYWNrZXRTdGFjayA9IFtdO1xuLy8gVGhlcmUncyBhIGxvdCBtb3JlIGluXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcbi8vIHdoaWNoIGFyZSBsZWZ0IG91dCB0byBrZWVwIGNvZGUgc2l6ZSBkb3duLlxuZm9yIChsZXQgcCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxuICAgICAgICAgICAgMHg2MDAgPD0gY2ggJiYgY2ggPD0gMHg2ZjkgPyBBcmFiaWNUeXBlc1tjaCAtIDB4NjAwXSA6XG4gICAgICAgICAgICAgICAgMHg2ZWUgPD0gY2ggJiYgY2ggPD0gMHg4YWMgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBiID8gMjU2IC8qIFQuTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgMHhmYjUwIDw9IGNoICYmIGNoIDw9IDB4ZmRmZiA/IDQgLyogVC5BTCAqLyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPT0gMHgyMDBjID8gMjU2IC8qIFQuTkkgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHNwYW4gKHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBzcGFuLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBbXCJiaWRpXG4gICAgbGV2ZWxcIl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS8jQmFzaWNfRGlzcGxheV9BbGdvcml0aG0pXG4gICAgb2YgdGhlIHNwYW4gKGluIHRoaXMgY29udGV4dCwgMCBtZWFuc1xuICAgIGxlZnQtdG8tcmlnaHQsIDEgbWVhbnMgcmlnaHQtdG8tbGVmdCwgMiBtZWFucyBsZWZ0LXRvLXJpZ2h0XG4gICAgbnVtYmVyIGluc2lkZSByaWdodC10by1sZWZ0IHRleHQpLlxuICAgICovXG4gICAgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkaXJlY3Rpb24gb2YgdGhpcyBzcGFuLlxuICAgICovXG4gICAgZ2V0IGRpcigpIHsgcmV0dXJuIHRoaXMubGV2ZWwgJSAyID8gUlRMIDogTFRSOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xuICAgIGxldCBsZW4gPSBsaW5lLmxlbmd0aCwgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IExUUiA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8sIG9wcG9zaXRlVHlwZSA9IGRpcmVjdGlvbiA9PSBMVFIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGlmICghbGluZSB8fCBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxlbik7XG4gICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGNoYXJhY3Rlci4gSWYgdGhlIE5TTSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxldmVsIHJ1biwgaXQgd2lsbFxuICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgLy8gbnVtYmVyLlxuICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICBmb3IgKGxldCBpID0gMCwgcHJldiA9IG91dGVyVHlwZSwgcHJldlN0cm9uZyA9IG91dGVyVHlwZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUobGluZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gOCAvKiBULkVOICovICYmIHByZXZTdHJvbmcgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICB9XG4gICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgLy8gTmV1dHJhbC5cbiAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcbiAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICBmb3IgKGxldCBpID0gMCwgcHJldiA9IG91dGVyVHlwZSwgcHJldlN0cm9uZyA9IG91dGVyVHlwZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzW2ldID0gcHJldjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gOCAvKiBULkVOICovICYmIHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgIH1cbiAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAvLyBzZXF1ZW50aWFsbHkgaW4gdGhlIGxvZ2ljYWwgb3JkZXIgb2YgdGhlIHRleHQgcG9zaXRpb25zIG9mIHRoZVxuICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICBmb3IgKGxldCBpID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMCwgY2gsIGJyLCB0eXBlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gS2VlcHMgW3N0YXJ0SW5kZXgsIHR5cGUsIHN0cm9uZ1NlZW5dIHRyaXBsZXMgZm9yIGVhY2ggb3BlblxuICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICBpZiAoYnIgPCAwKSB7IC8vIENsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IEJyYWNrZXRTdGFja1tzSiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVCZWZvcmUgKi8pID8gb3Bwb3NpdGVUeXBlIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzSSA9IHNKO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGk7XG4gICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICBsZXQgZW1iZWQgPSB0eXBlID09IG91dGVyVHlwZTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IEJyYWNrZXRTdGFja1tzSiArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGVtYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXG4gICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cbiAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVzW2ldID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pXG4gICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICBsZXQgYmVmb3JlTCA9IChpID8gdHlwZXNbaSAtIDFdIDogb3V0ZXJUeXBlKSA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgbGVuID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICBsZXQgcmVwbGFjZSA9IGJlZm9yZUwgPT0gYWZ0ZXJMID8gKGJlZm9yZUwgPyAxIC8qIFQuTCAqLyA6IDIgLyogVC5SICovKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgZW5kOyBqKyspXG4gICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICAvLyBsZXZlbHMgKDAsIDEsIDIpIGluIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lc24ndCB0YWtlXG4gICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxuICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG4gICAgbGV0IG9yZGVyID0gW107XG4gICAgaWYgKG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGksIHJ0bCA9IHR5cGVzW2krK10gIT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBydGwgPT0gKHR5cGVzW2ldICE9IDEgLyogVC5MICovKSlcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGosIGwgPSB0eXBlc1stLWpdICE9IDIgLyogVC5SICovO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA+IHN0YXJ0ICYmIGwgPT0gKHR5cGVzW2ogLSAxXSAhPSAyIC8qIFQuUiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGosIGVuZCwgbCA/IDIgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oc3RhcnQsIGksIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdID09IDIgLyogVC5SICovO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgcnRsID09ICh0eXBlc1tpXSA9PSAyIC8qIFQuUiAqLykpXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oc3RhcnQsIGksIHJ0bCA/IDEgOiAyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tLCBzcGFuSSA9IC0xO1xuICAgIGlmIChzdGFydEluZGV4ID09IDApIHtcbiAgICAgICAgaWYgKCFmb3J3YXJkIHx8ICFsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgIT0gZGlyKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gb3JkZXJbMF0uc2lkZShmYWxzZSwgZGlyKTtcbiAgICAgICAgICAgIHNwYW5JID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGFydEluZGV4ID09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsYXN0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0LmxldmVsICE9IGRpcikge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxhc3Quc2lkZSh0cnVlLCBkaXIpO1xuICAgICAgICAgICAgc3BhbkkgPSBvcmRlci5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcGFuSSA8IDApXG4gICAgICAgIHNwYW5JID0gQmlkaVNwYW4uZmluZChvcmRlciwgc3RhcnRJbmRleCwgKF9hID0gc3RhcnQuYmlkaUxldmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMSwgc3RhcnQuYXNzb2MpO1xuICAgIGxldCBzcGFuID0gb3JkZXJbc3BhbkldO1xuICAgIC8vIEVuZCBvZiBzcGFuLiAoQnV0IG5vdCBlbmQgb2YgbGluZS0tdGhhdCB3YXMgY2hlY2tlZCBmb3IgYWJvdmUuKVxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpKSB7XG4gICAgICAgIHNwYW4gPSBvcmRlcltzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xXTtcbiAgICAgICAgc3RhcnRJbmRleCA9IHNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IGluZGV4Rm9yd2FyZCA9IGZvcndhcmQgPT0gKHNwYW4uZGlyID09IGRpcik7XG4gICAgbGV0IG5leHRJbmRleCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBpbmRleEZvcndhcmQpO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBpZiAobmV4dEluZGV4ICE9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIGluZGV4Rm9yd2FyZCA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG4gICAgbGV0IG5leHRTcGFuID0gc3BhbkkgPT0gKGZvcndhcmQgPyBvcmRlci5sZW5ndGggLSAxIDogMCkgPyBudWxsIDogb3JkZXJbc3BhbkkgKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgIGlmICghbmV4dFNwYW4gJiYgc3Bhbi5sZXZlbCAhPSBkaXIpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxLCBkaXIpO1xuICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0U3Bhbi5sZXZlbCA8IHNwYW4ubGV2ZWwpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRTcGFuLnNpZGUoIWZvcndhcmQsIGRpcikgKyBsaW5lLmZyb20sIGZvcndhcmQgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xufVxuXG5jb25zdCBMaW5lQnJlYWtQbGFjZWhvbGRlciA9IFwiXFx1ZmZmZlwiO1xuY2xhc3MgRE9NUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSBzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKTtcbiAgICB9XG4gICAgYXBwZW5kKHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IHRleHQ7XG4gICAgfVxuICAgIGxpbmVCcmVhaygpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IExpbmVCcmVha1BsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZWFkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGN1cik7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgbmV4dFZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkpKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWRUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSAtMSwgYnJlYWtTaXplID0gMSwgbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZCh0ZXh0LnNsaWNlKG9mZiwgbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrKSk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBpZiAoYnJlYWtTaXplID4gMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBwb2ludC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucG9zIC09IGJyZWFrU2l6ZSAtIDE7XG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jbUlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBmcm9tVmlldyA9IHZpZXcgJiYgdmlldy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgIGlmIChmcm9tVmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluc2lkZShub2RlLCBmcm9tVmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21WaWV3Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGkubGluZUJyZWFrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBvaW50QmVmb3JlKG5vZGUsIG5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZmluZFBvaW50SW5zaWRlKG5vZGUsIG1heExlbikge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgPyBwb2ludC5ub2RlID09IG5vZGUgOiBub2RlLmNvbnRhaW5zKHBvaW50Lm5vZGUpKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihtYXhMZW4sIHBvaW50Lm9mZnNldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgJiYgL14oRElWfFB8TEl8VUx8T0x8QkxPQ0tRVU9URXxERHxEVHxIXFxkfFNFQ1RJT058UFJFKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG59XG5jbGFzcyBET01Qb2ludCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnBvcyA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgRG9jVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXAgPSBbXTtcbiAgICAgICAgLy8gVHJhY2sgYSBtaW5pbXVtIHdpZHRoIGZvciB0aGUgZWRpdG9yLiBXaGVuIG1lYXN1cmluZyBzaXplcyBpblxuICAgICAgICAvLyBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzLCB0aGlzIGlzIHVwZGF0ZWQgdG8gcG9pbnQgYXQgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIGEgZ2l2ZW4gZWxlbWVudCBhbmQgaXRzIGV4dGVudCBpbiB0aGUgZG9jdW1lbnQuIFdoZW4gYSBjaGFuZ2VcbiAgICAgICAgLy8gaGFwcGVucyBpbiB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW5cbiAgICAgICAgLy8gYSBsaW5lL2VsZW1lbnQgb2YgYSBnaXZlbiBsZW5ndGgsIHdlIGtlZXAgdGhlIGVkaXRvciB3aWRlIGVub3VnaFxuICAgICAgICAvLyB0byBmaXQgYXQgbGVhc3QgdGhhdCBlbGVtZW50LCB1bnRpbCBpdCBpcyBjaGFuZ2VkLCBhdCB3aGljaCBwb2ludFxuICAgICAgICAvLyB3ZSBmb3JnZXQgaXQgYWdhaW4uXG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIERPTSBzZWxlY3Rpb24gd2FzIHNldCBpbiBhIGxvc3N5IHdheSwgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBtZXNzIGl0IHVwIHdoZW4gcmVhZGluZyBpdCBiYWNrIGl0XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSByZXNpemUgb2JzZXJ2ZXIgdG8gaWdub3JlIHJlc2l6ZXMgdGhhdCB3ZSBjYXVzZWRcbiAgICAgICAgLy8gb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2V0RE9NKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExpbmVWaWV3XTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldLCAwKTtcbiAgICB9XG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXc7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS4gc2Nyb2xsSW50b1ZpZXcgY2FuIGJlXG4gICAgLy8gdXNlZCBhcyBhIGhpbnQgdG8gY29tcHV0ZSBhIG5ldyB2aWV3cG9ydCB0aGF0IGluY2x1ZGVzIHRoYXRcbiAgICAvLyBwb3NpdGlvbiwgaWYgd2Uga25vdyB0aGUgZWRpdG9yIGlzIGdvaW5nIHRvIHNjcm9sbCB0aGF0IHBvc2l0aW9uXG4gICAgLy8gaW50byB2aWV3LlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28gPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGVsc2UgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoIHx8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IGNvbXB1dGVDb21wb3NpdGlvbkRlY28odGhpcy52aWV3LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIXRoaXMuY29tcG9zaXRpb25EZWNvLnNpemUgJiYgdXBkYXRlICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLmRlY29yYXRpb25zLCBkZWNvID0gdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIGxldCBkZWNvRGlmZiA9IGZpbmRDaGFuZ2VkRGVjbyhwcmV2RGVjbywgZGVjbywgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY2hhbmdlZFJhbmdlcywgZGVjb0RpZmYpO1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSAwIC8qIERpcnR5Lk5vdCAqLyAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBvbGRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCk7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCB3aGVuIERPTSBtdXRhdGlvbnMgb2NjdXIgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBnZXQgY29uZnVzZWQgYW5kIHJlcG9ydCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcbiAgICAgICAgICAgIC8vIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICAgICAgICAgIGxldCB0cmFjayA9IGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuaW9zID8geyBub2RlOiBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUsIHdyaXR0ZW46IGZhbHNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN5bmModHJhY2spO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IDAgLyogRGlydHkuTm90ICovO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICh0cmFjay53cml0dGVuIHx8IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSB0cmFjay5ub2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvIDwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGNoaWxkLmRvbSk7XG4gICAgICAgIG9ic2VydmVyLnVwZGF0ZUdhcHMoZ2Fwcyk7XG4gICAgfVxuICAgIHVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jaGlsZEN1cnNvcihvbGRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPj0gMCA/IGNoYW5nZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gbmV4dDtcbiAgICAgICAgICAgIGxldCB7IGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3Vyc29yLmZpbmRQb3ModG9BLCAxKTtcbiAgICAgICAgICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1cnNvci5maW5kUG9zKGZyb21BLCAtMSk7XG4gICAgICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAoIShmcm9tUG9pbnRlciB8fCB0aGlzLm1heUNvbnRyb2xTZWxlY3Rpb24oKSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIC8vIEZJWE1FIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3Rpb24gZmFsbHMgaW5zaWRlIGEgYmxvY2sgcmFuZ2VcbiAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLmRvbUF0UG9zKG1haW4uaGVhZCk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5lYXJieVRleHROb2RlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IERPTVBvcyh0ZXh0LCBuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gMCA6IHRleHQubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgZG9tU2VsLmN1cnNvckJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmN1cnNvckJpZGlMZXZlbCA9IG1haW4uYmlkaUxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdTZWwuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSB3aWxsIGlnbm9yZSB0aGUgY2FsbCBhYm92ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZGVuLCBhbmQgdGhlbiByYWlzZSBhbiBlcnJvciBvbiB0aGUgY2FsbCB0byBleHRlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gKCM5NDApLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmV4dGVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgKElFKSB3YXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYW5jaG9yID4gbWFpbi5oZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBbaGVhZCwgYW5jaG9yXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5zZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gYW5jaG9yLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IGhlYWQucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgfVxuICAgIGVuZm9yY2VDdXJzb3JBc3NvYygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25EZWNvLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcbiAgICAgICAgLy8gc28gY2hlY2sgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5ld1JhbmdlLmFuY2hvck5vZGUsIG5ld1JhbmdlLmFuY2hvck9mZnNldCkgIT0gY3Vyc29yLmZyb20pXG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICB9XG4gICAgbWF5Q29udHJvbFNlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5kb20gfHxcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlKSAmJiAhKGFjdGl2ZSAmJiB0aGlzLmRvbS5jb250YWlucyhhY3RpdmUpKTtcbiAgICB9XG4gICAgbmVhcmVzdChkb20pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgICAgICBsZXQgZG9tVmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpO1xuICAgICAgICAgICAgaWYgKGRvbVZpZXcgJiYgZG9tVmlldy5yb290VmlldyA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21WaWV3O1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZWFyZXN0KG5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBmaW5kIHBvc2l0aW9uIGZvciBhIERPTSBwb3NpdGlvbiBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkgKyB2aWV3LnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgLTEpO1xuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAob2ZmIDwgY2hpbGQubGVuZ3RoIHx8IGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUF0UG9zKG9mZik7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3RhcnQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyIC0gY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHN0YXJ0IHx8XG4gICAgICAgICAgICAgICAgKHBvcyA9PSBzdGFydCAmJiBjaGlsZC50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgJiYgY2hpbGQudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFpIHx8IHNpZGUgPT0gMiB8fCB0aGlzLmNoaWxkcmVuW2kgLSAxXS5icmVha0FmdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jaGlsZHJlbltpIC0gMV0udHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlICYmIHNpZGUgPiAtMikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29vcmRzQXQocG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2aWV3cG9ydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHsgZnJvbSwgdG8gfSA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gdGhpcy52aWV3LmNvbnRlbnRET00uY2xpZW50V2lkdGg7XG4gICAgICAgIGxldCBpc1dpZGVyID0gY29udGVudFdpZHRoID4gTWF0aC5tYXgodGhpcy52aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCwgdGhpcy5taW5XaWR0aCkgKyAxO1xuICAgICAgICBsZXQgd2lkZXN0ID0gLTEsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUmVjdCA9IGNoaWxkLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWRlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGNoaWxkLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGxhc3QgPyBjbGllbnRSZWN0c0ZvcihsYXN0KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gbHRyID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0IDogY2hpbGRSZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZXN0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHsgaSB9ID0gdGhpcy5jaGlsZFBvcyhwb3MsIDEpO1xuICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNoaWxkcmVuW2ldLmRvbSkuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykge1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlID0gY2hpbGQubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHdvcmthYmxlIGxpbmUgZXhpc3RzLCBmb3JjZSBhIGxheW91dCBvZiBhIG1lYXN1cmFibGUgZWxlbWVudFxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGg7XG4gICAgICAgIGR1bW15LmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICBkdW1teS5zdHlsZS53aWR0aCA9IFwiOTk5OTlweFwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIGR1bW15LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbGluZUhlaWdodCwgY2hhcldpZHRoIH07XG4gICAgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIE1vdmUgYmFjayB0byBzdGFydCBvZiBsYXN0IGVsZW1lbnQgd2hlbiBwb3NzaWJsZSwgc28gdGhhdFxuICAgICAgICAvLyBgQ2hpbGRDdXJzb3IuZmluZFBvc2AgZG9lc24ndCBoYXZlIHRvIGRlYWwgd2l0aCB0aGUgZWRnZSBjYXNlXG4gICAgICAgIC8vIG9mIGJlaW5nIGFmdGVyIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICAgIGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgICAgcG9zIC09IHRoaXMuY2hpbGRyZW5bLS1pXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCBpKTtcbiAgICB9XG4gICAgY29tcHV0ZUJsb2NrR2FwRGVjbygpIHtcbiAgICAgICAgbGV0IGRlY28gPSBbXSwgdnMgPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHZzLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogdnMudmlld3BvcnRzW2ldO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb20gLSAxIDogdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3A7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQmxvY2tHYXA6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgbGV0IGFsbERlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFsbERlY28ubGVuZ3RoOyBpIDwgYWxsRGVjby5sZW5ndGggKyAzOyBpKyspXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25zID0gW1xuICAgICAgICAgICAgLi4uYWxsRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvLFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQmxvY2tHYXBEZWNvKCksXG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVHYXBEZWNvXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCkge1xuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1MZWZ0ID0gMCwgbVJpZ2h0ID0gMCwgbVRvcCA9IDAsIG1Cb3R0b20gPSAwO1xuICAgICAgICBmb3IgKGxldCBtYXJnaW5zIG9mIHRoaXMudmlldy5zdGF0ZS5mYWNldChzY3JvbGxNYXJnaW5zKS5tYXAoZiA9PiBmKHRoaXMudmlldykpKVxuICAgICAgICAgICAgaWYgKG1hcmdpbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IG1hcmdpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbUxlZnQgPSBNYXRoLm1heChtTGVmdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1SaWdodCA9IE1hdGgubWF4KG1SaWdodCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3AgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbVRvcCA9IE1hdGgubWF4KG1Ub3AsIHRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtQm90dG9tID0gTWF0aC5tYXgobUJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBtTGVmdCwgdG9wOiByZWN0LnRvcCAtIG1Ub3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1SaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSArIG1Cb3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnhNYXJnaW4sIHRhcmdldC55TWFyZ2luLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcbiAgICByZXR1cm4gcG9zLm5vZGUubm9kZVR5cGUgPT0gMSAmJiBwb3Mubm9kZS5maXJzdENoaWxkICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IDAgfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmhlaWdodDsgfVxufVxuZnVuY3Rpb24gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGxldCB0ZXh0Tm9kZSA9IHNlbC5mb2N1c05vZGUgJiYgbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCAwKTtcbiAgICBpZiAoIXRleHROb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdCh0ZXh0Tm9kZSk7XG4gICAgaWYgKCFjVmlldylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGNWaWV3IGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSBjVmlldy5kb20pXG4gICAgICAgICAgICB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBsZXQgcHJldiA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB3aGlsZSAocHJldiAmJiAhQ29udGVudFZpZXcuZ2V0KHByZXYpKVxuICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBsZXQgcG9zID0gcHJldiA/IENvbnRlbnRWaWV3LmdldChwcmV2KS5wb3NBdEVuZCA6IGNWaWV3LnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcywgbm9kZTogdG9wTm9kZSwgdGV4dDogdGV4dE5vZGUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCB7IHBhcmVudCB9ID0gY1ZpZXc7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNWaWV3ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tID0gY1ZpZXcucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG86IGZyb20gKyBjVmlldy5sZW5ndGgsIG5vZGU6IGNWaWV3LmRvbSwgdGV4dDogdGV4dE5vZGUgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQ29tcG9zaXRpb25EZWNvKHZpZXcsIGNoYW5nZXMpIHtcbiAgICBsZXQgc3Vycm91bmRpbmcgPSBjb21wb3NpdGlvblN1cnJvdW5kaW5nTm9kZSh2aWV3KTtcbiAgICBpZiAoIXN1cnJvdW5kaW5nKVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIGxldCB7IGZyb20sIHRvLCBub2RlLCB0ZXh0OiB0ZXh0Tm9kZSB9ID0gc3Vycm91bmRpbmc7XG4gICAgbGV0IG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhmcm9tLCAxKSwgbmV3VG8gPSBNYXRoLm1heChuZXdGcm9tLCBjaGFuZ2VzLm1hcFBvcyh0bywgLTEpKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgdGV4dCA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlIDpcbiAgICAgICAgbmV3IERPTVJlYWRlcihbXSwgc3RhdGUpLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpLnRleHQ7XG4gICAgaWYgKG5ld1RvIC0gbmV3RnJvbSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcobmV3RnJvbSwgTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbmV3RnJvbSArIHRleHQubGVuZ3RoKSwgTGluZUJyZWFrUGxhY2Vob2xkZXIpID09IHRleHQpXG4gICAgICAgICAgICBuZXdUbyA9IG5ld0Zyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKE1hdGgubWF4KDAsIG5ld1RvIC0gdGV4dC5sZW5ndGgpLCBuZXdUbywgTGluZUJyZWFrUGxhY2Vob2xkZXIpID09IHRleHQpXG4gICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gLSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5ld0Zyb20sIG5ld1RvLCBMaW5lQnJlYWtQbGFjZWhvbGRlcikgIT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICBsZXQgdG9wVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICBpZiAodG9wVmlldyBpbnN0YW5jZW9mIENvbXBvc2l0aW9uVmlldylcbiAgICAgICAgdG9wVmlldyA9IHRvcFZpZXcud2lkZ2V0LnRvcFZpZXc7XG4gICAgZWxzZSBpZiAodG9wVmlldylcbiAgICAgICAgdG9wVmlldy5wYXJlbnQgPSBudWxsO1xuICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBDb21wb3NpdGlvbldpZGdldChub2RlLCB0ZXh0Tm9kZSwgdG9wVmlldyksIGluY2x1c2l2ZTogdHJ1ZSB9KVxuICAgICAgICAucmFuZ2UobmV3RnJvbSwgbmV3VG8pKTtcbn1cbmNsYXNzIENvbXBvc2l0aW9uV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodG9wLCB0ZXh0LCB0b3BWaWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSB0b3BWaWV3O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy50b3AgPT0gb3RoZXIudG9wICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0OyB9XG4gICAgdG9ET00oKSB7IHJldHVybiB0aGlzLnRvcDsgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgY3VzdG9tVmlldygpIHsgcmV0dXJuIENvbXBvc2l0aW9uVmlldzsgfVxufVxuZnVuY3Rpb24gbmVhcmJ5VGV4dE5vZGUobm9kZSwgb2Zmc2V0LCBzaWRlKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCAmJiBzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0VG9VbmVkaXRhYmxlKG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAob2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSAvKiBOZXh0VG8uQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBOZXh0VG8uQWZ0ZXIgKi8gOiAwKTtcbn1cbmNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yJDEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG59XG5mdW5jdGlvbiBmaW5kQ2hhbmdlZERlY28oYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBdChzdGF0ZSwgcG9zLCBiaWFzID0gMSkge1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XG4gICAgaWYgKGxpbmUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgaWYgKGxpbmVQb3MgPT0gMClcbiAgICAgICAgYmlhcyA9IDE7XG4gICAgZWxzZSBpZiAobGluZVBvcyA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgYmlhcyA9IC0xO1xuICAgIGxldCBmcm9tID0gbGluZVBvcywgdG8gPSBsaW5lUG9zO1xuICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgZnJvbSA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zLCBmYWxzZSk7XG4gICAgZWxzZVxuICAgICAgICB0byA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB3aGlsZSAoZnJvbSA+IDApIHtcbiAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmcm9tID0gcHJldjtcbiAgICB9XG4gICAgd2hpbGUgKHRvIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdG8pO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UodG8sIG5leHQpKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdG8gPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20gKyBsaW5lLmZyb20sIHRvICsgbGluZS5mcm9tKTtcbn1cbi8vIFNlYXJjaCB0aGUgRE9NIGZvciB0aGUge25vZGUsIG9mZnNldH0gcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW5cbi8vIGNvb3JkaW5hdGVzLiBWZXJ5IGluZWZmaWNpZW50IGFuZCBjcnVkZSwgYnV0IGNhbiB1c3VhbGx5IGJlIGF2b2lkZWRcbi8vIGJ5IGNhbGxpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGluc3RlYWQuXG5mdW5jdGlvbiBnZXRkeCh4LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QubGVmdCA+IHggPyByZWN0LmxlZnQgLSB4IDogTWF0aC5tYXgoMCwgeCAtIHJlY3QucmlnaHQpO1xufVxuZnVuY3Rpb24gZ2V0ZHkoeSwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiBNYXRoLm1heCgwLCB5IC0gcmVjdC5ib3R0b20pO1xufVxuZnVuY3Rpb24geU92ZXJsYXAoYSwgYikge1xuICAgIHJldHVybiBhLnRvcCA8IGIuYm90dG9tIC0gMSAmJiBhLmJvdHRvbSA+IGIudG9wICsgMTtcbn1cbmZ1bmN0aW9uIHVwVG9wKHJlY3QsIHRvcCkge1xuICAgIHJldHVybiB0b3AgPCByZWN0LnRvcCA/IHsgdG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gdXBCb3QocmVjdCwgYm90dG9tKSB7XG4gICAgcmV0dXJuIGJvdHRvbSA+IHJlY3QuYm90dG9tID8geyB0b3A6IHJlY3QudG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiBkb21Qb3NBdENvb3JkcyhwYXJlbnQsIHgsIHkpIHtcbiAgICBsZXQgY2xvc2VzdCwgY2xvc2VzdFJlY3QsIGNsb3Nlc3RYLCBjbG9zZXN0WSwgY2xvc2VzdE92ZXJsYXAgPSBmYWxzZTtcbiAgICBsZXQgYWJvdmUsIGJlbG93LCBhYm92ZVJlY3QsIGJlbG93UmVjdDtcbiAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFJlY3QgJiYgeU92ZXJsYXAoY2xvc2VzdFJlY3QsIHJlY3QpKVxuICAgICAgICAgICAgICAgIHJlY3QgPSB1cFRvcCh1cEJvdChyZWN0LCBjbG9zZXN0UmVjdC5ib3R0b20pLCBjbG9zZXN0UmVjdC50b3ApO1xuICAgICAgICAgICAgbGV0IGR4ID0gZ2V0ZHgoeCwgcmVjdCksIGR5ID0gZ2V0ZHkoeSwgcmVjdCk7XG4gICAgICAgICAgICBpZiAoZHggPT0gMCAmJiBkeSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5ub2RlVHlwZSA9PSAzID8gZG9tUG9zSW5UZXh0KGNoaWxkLCB4LCB5KSA6IGRvbVBvc0F0Q29vcmRzKGNoaWxkLCB4LCB5KTtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCB8fCBjbG9zZXN0WSA+IGR5IHx8IGNsb3Nlc3RZID09IGR5ICYmIGNsb3Nlc3RYID4gZHgpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RYID0gZHg7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFkgPSBkeTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFkeCB8fCAoZHggPiAwID8gaSA8IHJlY3RzLmxlbmd0aCAtIDEgOiBpID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gcmVjdC5ib3R0b20gJiYgKCFhYm92ZVJlY3QgfHwgYWJvdmVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFib3ZlUmVjdCAmJiB5T3ZlcmxhcChhYm92ZVJlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgeU92ZXJsYXAoYmVsb3dSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm92ZVJlY3QgJiYgYWJvdmVSZWN0LmJvdHRvbSA+PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBhYm92ZTtcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiBiZWxvd1JlY3QudG9wIDw9IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGJlbG93UmVjdDtcbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0KVxuICAgICAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldDogMCB9O1xuICAgIGxldCBjbGlwWCA9IE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSk7XG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGRvbVBvc0luVGV4dChjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgaWYgKGNsb3Nlc3RPdmVybGFwICYmIGNsb3Nlc3QuY29udGVudEVkaXRhYmxlICE9IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGROb2RlcywgY2xvc2VzdCkgK1xuICAgICAgICAoeCA+PSAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGRvbVBvc0luVGV4dChub2RlLCB4LCB5KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VzdE9mZnNldCA9IC0xLCBjbG9zZXN0RFkgPSAxZTksIGdlbmVyYWxTaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZ2VuZXJhbFNpZGUpXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IGR5ID0gKHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IHkgLSByZWN0LmJvdHRvbSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCAtIDEgPD0geCAmJiByZWN0LnJpZ2h0ICsgMSA+PSB4ICYmIGR5IDwgY2xvc2VzdERZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBSVEwgb24gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdldHRpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gdGV4dFJhbmdlKG5vZGUsIGkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR5IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPZmZzZXQgPSBpICsgKGFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REWSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIHsgeCwgeSB9LCBwcmVjaXNlLCBiaWFzID0gLTEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeU9mZnNldCA9IHkgLSBkb2NUb3A7XG4gICAgaWYgKHlPZmZzZXQgPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoeU9mZnNldCA+IGRvY0hlaWdodClcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAvLyBTY2FuIGZvciBhIHRleHQgYmxvY2sgbmVhciB0aGUgcXVlcmllZCB5IHBvc2l0aW9uXG4gICAgZm9yIChsZXQgaGFsZkxpbmUgPSB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgKHsgc3RhcnRDb250YWluZXI6IG5vZGUsIHN0YXJ0T2Zmc2V0OiBvZmZzZXQgfSA9IHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudFJlY3QsIGJsb2NrLCB4LCB5KSB7XG4gICAgbGV0IGludG8gPSBNYXRoLnJvdW5kKCh4IC0gY29udGVudFJlY3QubGVmdCkgKiB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCk7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLmZsb29yKCh5IC0gYmxvY2sudG9wKSAvIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBwYXJlbnQuZmlyc3RDaGlsZCAhPSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tbGluZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZWN0ID0gbm9kZS5ub2RlVHlwZSA9PSAxID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geCAtIHJlY3QubGVmdCA+IDU7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCAhdmlldy5saW5lV3JhcHBpbmcgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgbGV0IGxpbmVWaWV3ID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHN0YXJ0LmhlYWQpO1xuICAgIGxldCBlbmQgPSBsaW5lVmlldyA/IChmb3J3YXJkID8gbGluZVZpZXcucG9zQXRFbmQgOiBsaW5lVmlldy5wb3NBdFN0YXJ0KSA6IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZW5kLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUuZnJvbSA6IGxpbmUudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcyksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgPj4gMSk7XG4gICAgZm9yIChsZXQgZXh0cmEgPSAwOzsgZXh0cmEgKz0gMTApIHtcbiAgICAgICAgbGV0IGN1clkgPSBzdGFydFkgKyAoZGlzdCArIGV4dHJhKSAqIGRpcjtcbiAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzKHZpZXcsIHsgeDogcmVzb2x2ZWRHb2FsLCB5OiBjdXJZIH0sIGZhbHNlLCBkaXIpO1xuICAgICAgICBpZiAoY3VyWSA8IHJlY3QudG9wIHx8IGN1clkgPiByZWN0LmJvdHRvbSB8fCAoZGlyIDwgMCA/IHBvcyA8IHN0YXJ0UG9zIDogcG9zID4gc3RhcnRQb3MpKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBzdGFydC5hc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbXModmlldywgb2xkUG9zLCBwb3MpIHtcbiAgICBsZXQgYXRvbXMgPSB2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MuZnJvbSAtIDEsIHBvcy5mcm9tICsgMSwgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MuZnJvbSA+IGZyb20gJiYgcG9zLmZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tLCAxKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cblxuLy8gVGhpcyB3aWxsIGFsc28gYmUgd2hlcmUgZHJhZ2dpbmcgaW5mbyBhbmQgc3VjaCBnb2VzXG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuY2hyb21lU2Nyb2xsSGFjayA9IC0xO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzID0gW107XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB8fCB0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdXN0Rmx1c2hPYnNlcnZlcihldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bkN1c3RvbUhhbmRsZXJzKHR5cGUsIHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICAgICAgfSwgaGFuZGxlck9wdGlvbnNbdHlwZV0pO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzLnB1c2godHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuY2hyb21lX3ZlcnNpb24gPT0gMTAyKSB7IC8vIEZJWE1FIHJlbW92ZSBhdCBzb21lIHBvaW50XG4gICAgICAgICAgICAvLyBPbiBDaHJvbWUgMTAyLCB2aWV3cG9ydCB1cGRhdGVzIHNvbWVob3cgc3RvcCB3aGVlbC1iYXNlZFxuICAgICAgICAgICAgLy8gc2Nyb2xsaW5nLiBUdXJuaW5nIG9mZiBwb2ludGVyIGV2ZW50cyBkdXJpbmcgdGhlIHNjcm9sbCBzZWVtc1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGlzc3VlLlxuICAgICAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaHJvbWVTY3JvbGxIYWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5jaHJvbWVTY3JvbGxIYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHZpZXcsIHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICAgIHRoaXMuY3VzdG9tSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHBsdWdpbnMpXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgPSAoX2EgPSBwbHVnaW4udXBkYXRlKHZpZXcpLnNwZWMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycy5wdXNoKHsgcGx1Z2luOiBwbHVnaW4udmFsdWUsIGhhbmRsZXJzIH0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHMuaW5kZXhPZih0eXBlKSA8IDAgJiYgdHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIHRoaXMuY3VzdG9tSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBydW5TY3JvbGxIYW5kbGVycyh2aWV3LCBldmVudCkge1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnMuc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIERhdGUubm93KCkgPCB0aGlzLmxhc3RFc2NQcmVzcyArIDIwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkoZXZlbnQua2V5LCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgRW50ZXIgb24gaU9TIG1ha2VzIHRoZVxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcbiAgICAgICAgLy8gc3RhdGUuIFNvIHdlIGxldCBpdCBnbyB0aHJvdWdoLCBhbmQgdGhlbiwgaW5cbiAgICAgICAgLy8gYXBwbHlET01DaGFuZ2UsIG5vdGlmeSBrZXkgaGFuZGxlcnMgb2YgaXQgYW5kIHJlc2V0IHRvXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXG4gICAgICAgIGxldCBwZW5kaW5nO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAgICAgICAoKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiYgIWV2ZW50LmN0cmxLZXkgfHxcbiAgICAgICAgICAgICAgICBFbWFjc3lQZW5kaW5nS2V5cy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSAmJiBldmVudC5jdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHBlbmRpbmcgfHwgZXZlbnQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2hJT1NLZXkodmlldyksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KHZpZXcpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xuICAgIH1cbiAgICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIS9ea2V5Ly50ZXN0KGV2ZW50LnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xuICAgICAgICAvLyBjb25maXJtIGNoYXJhY3RlciBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlIHNvbWV0aW1lcyBlbWl0dGVkIGluIHRoZVxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWJyb3dzZXIuaW9zICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtdXN0Rmx1c2hPYnNlcnZlcihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiBldmVudC5rZXlDb2RlICE9IDIyOTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuY29uc3QgUGVuZGluZ0tleXMgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIGtleUNvZGU6IDgsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0UGFyYWdyYXBoXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnRFdmVudCwgc3R5bGUsIG11c3RTZWxlY3QpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBtdXN0U2VsZWN0O1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIGxldCBkb2MgPSB2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gc3RhcnRFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpICYmIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnTW92ZSA9IGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpICYmIGdldENsaWNrVHlwZShzdGFydEV2ZW50KSA9PSAxID8gbnVsbCA6IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvbiwgaW1tZWRpYXRlbHkgYXBwbHkgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBzdGFydGluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qoc3RhcnRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uLm1haW4uYXNzb2MgIT0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgJiYgdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKCFzZWwgfHwgc2VsLnJhbmdlQ291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHJlY3RzID0gc2VsLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ID49IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gPj0gZXZlbnQuY2xpZW50WSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0LCBjVmlldzsgbm9kZSAhPSB2aWV3LmNvbnRlbnRET007IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8ICgoY1ZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSkpICYmIGNWaWV3Lmlnbm9yZUV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgaGFuZGxlck9wdGlvbnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSVx1MjAxNGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcbiAgICBlbHNlIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gMDtcbn07XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVyT3B0aW9ucy50b3VjaHN0YXJ0ID0gaGFuZGxlck9wdGlvbnMudG91Y2htb3ZlID0geyBwYXNzaXZlOiB0cnVlIH07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobXVzdEZvY3VzKVxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSkpO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlLCBtdXN0Rm9jdXMpKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmFuZ2VGb3JDbGljayh2aWV3LCBwb3MsIGJpYXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSAxKSB7IC8vIFNpbmdsZSBjbGlja1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09IDIpIHsgLy8gRG91YmxlIGNsaWNrXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUcmlwbGUgY2xpY2tcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5sZXQgaW5zaWRlWSA9ICh5LCByZWN0KSA9PiB5ID49IHJlY3QudG9wICYmIHkgPD0gcmVjdC5ib3R0b207XG5sZXQgaW5zaWRlID0gKHgsIHksIHJlY3QpID0+IGluc2lkZVkoeSwgcmVjdCkgJiYgeCA+PSByZWN0LmxlZnQgJiYgeCA8PSByZWN0LnJpZ2h0O1xuLy8gVHJ5IHRvIGRldGVybWluZSwgZm9yIHRoZSBnaXZlbiBjb29yZGluYXRlcywgYXNzb2NpYXRlZCB3aXRoIHRoZVxuLy8gZ2l2ZW4gcG9zaXRpb24sIHdoZXRoZXIgdGhleSBhcmUgcmVsYXRlZCB0byB0aGUgZWxlbWVudCBiZWZvcmUgb3Jcbi8vIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCB4LCB5KSB7XG4gICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKTtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBvZmYgPSBwb3MgLSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgLy8gTGluZSBib3VuZGFyaWVzIHBvaW50IGludG8gdGhlIGxpbmVcbiAgICBpZiAob2ZmID09IDApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChvZmYgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAvLyBQb3NpdGlvbnMgb24gdG9wIG9mIGFuIGVsZW1lbnQgcG9pbnQgYXQgdGhhdCBlbGVtZW50XG4gICAgbGV0IGJlZm9yZSA9IGxpbmUuY29vcmRzQXQob2ZmLCAtMSk7XG4gICAgaWYgKGJlZm9yZSAmJiBpbnNpZGUoeCwgeSwgYmVmb3JlKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBhZnRlciA9IGxpbmUuY29vcmRzQXQob2ZmLCAxKTtcbiAgICBpZiAoYWZ0ZXIgJiYgaW5zaWRlKHgsIHksIGFmdGVyKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGxpbmUgd3JhcCBwb2ludC4gUGljayBiZWZvcmUgaWYgdGhlIHBvaW50IGlzXG4gICAgLy8gYmVzaWRlIGl0LlxuICAgIHJldHVybiBiZWZvcmUgJiYgaW5zaWRlWSh5LCBiZWZvcmUpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIHJldHVybiB7IHBvcywgYmlhczogZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpIH07XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgbGFzdCA9IHN0YXJ0LCBsYXN0RXZlbnQgPSBldmVudDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyO1xuICAgICAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBldmVudC5jbGllbnRYID09IGxhc3RFdmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkgPT0gbGFzdEV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICAgICAgY3VyID0gbGFzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ciA9IGxhc3QgPSBxdWVyeVBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIGN1ci5wb3MsIGN1ci5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChzdGFydC5wb3MgIT0gY3VyLnBvcyAmJiAhZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIHN0YXJ0LnBvcywgc3RhcnQuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihzdGFydFJhbmdlLmZyb20sIHJhbmdlLmZyb20pLCB0byA9IE1hdGgubWF4KHN0YXJ0UmFuZ2UudG8sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGZyb20gPCByYW5nZS5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5yZXBsYWNlUmFuZ2Uoc3RhcnRTZWwubWFpbi5leHRlbmQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIHN0YXJ0U2VsLnJhbmdlcy5zb21lKHIgPT4gci5lcShyYW5nZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVSYW5nZShzdGFydFNlbCwgcmFuZ2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVSYW5nZShzZWwsIHJhbmdlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXNbaV0uZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XG4gICAgfVxufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uOiB7IG1haW4gfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBsZXQgeyBtb3VzZVNlbGVjdGlvbiB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGlmIChtb3VzZVNlbGVjdGlvbilcbiAgICAgICAgbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgPSBtYWluO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHZpZXcuc3RhdGUuc2xpY2VEb2MobWFpbi5mcm9tLCBtYWluLnRvKSk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH1cbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRyb3BQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgeyBtb3VzZVNlbGVjdGlvbiB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGxldCBkZWwgPSBkaXJlY3QgJiYgbW91c2VTZWxlY3Rpb24gJiYgbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgJiYgbW91c2VTZWxlY3Rpb24uZHJhZ01vdmUgP1xuICAgICAgICB7IGZyb206IG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nLmZyb20sIHRvOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIiksIHRydWUpO1xuICAgIH1cbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQudmFsdWUgPSB0ZXh0O1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHRhcmdldC5zZWxlY3Rpb25FbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICB0YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBjb3BpZWRSYW5nZShzdGF0ZSkge1xuICAgIGxldCBjb250ZW50ID0gW10sIHJhbmdlcyA9IFtdLCBsaW5ld2lzZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgaWYgKCFjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBkbyBhIGxpbmUtd2lzZSBjb3B5XG4gICAgICAgIGxldCB1cHRvID0gLTE7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gobGluZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwdG8gPSBsaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsaW5ld2lzZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7IHRleHQ6IGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspLCByYW5nZXMsIGxpbmV3aXNlIH07XG59XG5sZXQgbGFzdExpbmV3aXNlQ29weSA9IG51bGw7XG5oYW5kbGVycy5jb3B5ID0gaGFuZGxlcnMuY3V0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgdGV4dCwgcmFuZ2VzLCBsaW5ld2lzZSB9ID0gY29waWVkUmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgaWYgKCF0ZXh0ICYmICFsaW5ld2lzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImN1dFwiICYmICF2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxuICAgICAgICB9KTtcbn07XG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3Lmhhc0ZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgMTApO1xufVxuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbmhhbmRsZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gaGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKVxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSB0aGUgY29tcG9zaXRpb24gc3RhdGUgdG8gYmUgY2xlYXJlZCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuXG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuY29tcG9zaXRpb25EZWNvLnNpemUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgNTApO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCAqIGxpbmVzO1xuICAgIH1cbiAgICBoZWlnaHRGb3JMaW5lKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGV0IGxpbmVzID0gMSArIE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVuZ3RoIC0gdGhpcy5saW5lTGVuZ3RoKSAvICh0aGlzLmxpbmVMZW5ndGggLSA1KSkpO1xuICAgICAgICByZXR1cm4gbGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldERvYyhkb2MpIHsgdGhpcy5kb2MgPSBkb2M7IHJldHVybiB0aGlzOyB9XG4gICAgbXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmc7XG4gICAgfVxuICAgIG11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykge1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gbGluZUhlaWdodHNbaV07XG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodDtcbiAgICB9XG4gICAgcmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIGxpbmVMZW5ndGgsIGtub3duSGVpZ2h0cykge1xuICAgICAgICBsZXQgbGluZVdyYXBwaW5nID0gd3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBNYXRoLnJvdW5kKGxpbmVIZWlnaHQpICE9IE1hdGgucm91bmQodGhpcy5saW5lSGVpZ2h0KSB8fCB0aGlzLmxpbmVXcmFwcGluZyAhPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IGNoYXJXaWR0aDtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gbGluZUxlbmd0aDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbm93bkhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGtub3duSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaCA8IDApXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG59XG4vLyBUaGlzIG9iamVjdCBpcyB1c2VkIGJ5IGB1cGRhdGVIZWlnaHRgIHRvIG1ha2UgRE9NIG1lYXN1cmVtZW50c1xuLy8gYXJyaXZlIGF0IHRoZSByaWdodCBuaWRlcy4gVGhlIGBoZWlnaHRzYCBhcnJheSBpcyBhIHNlcXVlbmNlIG9mXG4vLyBibG9jayBoZWlnaHRzLCBzdGFydGluZyBmcm9tIHBvc2l0aW9uIGBmcm9tYC5cbmNsYXNzIE1lYXN1cmVkSGVpZ2h0cyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgaGVpZ2h0cykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBoZWlnaHRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IG1vcmUoKSB7IHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDsgfVxufVxuLyoqXG5SZWNvcmQgdXNlZCB0byByZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBibG9jay1sZXZlbCBlbGVtZW50XG5pbiB0aGUgZWRpdG9yIHZpZXcuXG4qL1xuY2xhc3MgQmxvY2tJbmZvIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50KS5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgSXRzIGhlaWdodC5cbiAgICAqL1xuICAgIGhlaWdodCwgXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgZWxlbWVudCBhcyBhIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUaGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGRldGFpbCA9IChBcnJheS5pc0FycmF5KHRoaXMudHlwZSkgPyB0aGlzLnR5cGUgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIudHlwZSkgPyBvdGhlci50eXBlIDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgZGV0YWlsKTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb2xkRG9jLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBpZiAoZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiB0byA+PSBvZmZzZXQpXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBkb2MsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIF9mb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcFRleHQgZXh0ZW5kcyBIZWlnaHRNYXBCbG9jayB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSAwOyAvLyBBbW91bnQgb2YgY29sbGFwc2VkIGNvbnRlbnQgaW4gdGhlIGxpbmVcbiAgICAgICAgdGhpcy53aWRnZXRIZWlnaHQgPSAwOyAvLyBNYXhpbXVtIGlubGluZSB3aWRnZXQgaGVpZ2h0XG4gICAgfVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5sZW5ndGggLSBub2RlLmxlbmd0aCkgPCAxMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgICAgICBub2RlLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYGxpbmUoJHt0aGlzLmxlbmd0aH0ke3RoaXMuY29sbGFwc2VkID8gLXRoaXMuY29sbGFwc2VkIDogXCJcIn0ke3RoaXMud2lkZ2V0SGVpZ2h0ID8gXCI6XCIgKyB0aGlzLndpZGdldEhlaWdodCA6IFwiXCJ9KWA7XG4gICAgfVxufVxuY2xhc3MgSGVpZ2h0TWFwR2FwIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxuICAgIGxpbmVzKGRvYywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBkb2MubGluZUF0KG9mZnNldCkubnVtYmVyLCBsYXN0TGluZSA9IGRvYy5saW5lQXQob2Zmc2V0ICsgdGhpcy5sZW5ndGgpLm51bWJlcjtcbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgbGluZUhlaWdodDogdGhpcy5oZWlnaHQgLyAobGFzdExpbmUgLSBmaXJzdExpbmUgKyAxKSB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIGxpbmVIZWlnaHQpKSk7XG4gICAgICAgIGxldCB7IGZyb20sIGxlbmd0aCB9ID0gZG9jLmxpbmUoZmlyc3RMaW5lICsgbGluZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgbGluZUhlaWdodCAqIGxpbmUsIGxpbmVIZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQodmFsdWUsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgdG8gLSBmcm9tLCAwLCAwLCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoLCBudW1iZXIgfSA9IGRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIGxpbmVIZWlnaHQgKiAobnVtYmVyIC0gZmlyc3RMaW5lKSwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpLCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyB0aGlzLmxlbmd0aCwgdG8pOyBwb3MgPD0gZW5kOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zID09IGZyb20pXG4gICAgICAgICAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQgKiAobGluZS5udW1iZXIgLSBmaXJzdExpbmUpO1xuICAgICAgICAgICAgZihuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIHRvcCwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpKTtcbiAgICAgICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IG9yYWNsZS5oZWlnaHRDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwR2FwKG1lYXN1cmVkLmZyb20gLSBvZmZzZXQgLSAxKS51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPD0gZW5kICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSAtMjtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KGxlbiwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChlbmQgLSBwb3MpLnVwZGF0ZUhlaWdodChvcmFjbGUsIHBvcykpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHdhc0NoYW5nZWQgfHwgc2luZ2xlSGVpZ2h0IDwgMCB8fCBNYXRoLmFicyhyZXN1bHQuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpID49IEVwc2lsb24gfHxcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzaW5nbGVIZWlnaHQgLSB0aGlzLmxpbmVzKG9yYWNsZS5kb2MsIG9mZnNldCkubGluZUhlaWdodCkgPj0gRXBzaWxvbjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEZsYWcuQnJlYWsgKi87IH1cbiAgICBibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWlkID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8IG1pZCA/IHRoaXMubGVmdC5ibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgZG9jLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGxldCBsZWZ0ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQgPyB2YWx1ZSA8IHJpZ2h0VG9wIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIGRvYywgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gbGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWsgKyByaWdodC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCB9ID0gdGhpcywgcmlnaHRTdGFydCA9IG9mZnNldCArIGxlZnQubGVuZ3RoICsgdGhpcy5icmVhaywgcmViYWxhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IGxlZnQgPSBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlKTtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gcmlnaHRTdGFydCArIHJpZ2h0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gcmlnaHQgPSByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSk7XG4gICAgICAgIGlmIChyZWJhbGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sZWZ0LmhlaWdodCArIHRoaXMucmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLmJyZWFrID8gXCIgXCIgOiBcIi1cIikgKyB0aGlzLnJpZ2h0OyB9XG59XG5mdW5jdGlvbiBtZXJnZUdhcHMobm9kZXMsIGFyb3VuZCkge1xuICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgIGlmIChub2Rlc1thcm91bmRdID09IG51bGwgJiZcbiAgICAgICAgKGJlZm9yZSA9IG5vZGVzW2Fyb3VuZCAtIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJlxuICAgICAgICAoYWZ0ZXIgPSBub2Rlc1thcm91bmQgKyAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgIG5vZGVzLnNwbGljZShhcm91bmQgLSAxLCAzLCBuZXcgSGVpZ2h0TWFwR2FwKGJlZm9yZS5sZW5ndGggKyAxICsgYWZ0ZXIubGVuZ3RoKSk7XG59XG5jb25zdCByZWxldmFudFdpZGdldEhlaWdodCA9IDU7XG5jbGFzcyBOb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBvcmFjbGUpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMub3JhY2xlID0gb3JhY2xlO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGluZUVuZCA9IC0xO1xuICAgICAgICB0aGlzLmNvdmVyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSBwb3M7XG4gICAgfVxuICAgIGdldCBpc0NvdmVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdmVyaW5nICYmIHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSB0aGlzLmNvdmVyaW5nO1xuICAgIH1cbiAgICBzcGFuKF9mcm9tLCB0bykge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRvLCB0aGlzLmxpbmVFbmQpLCBsYXN0ID0gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIGxhc3QubGVuZ3RoICs9IGVuZCAtIHRoaXMucG9zO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dChlbmQgLSB0aGlzLnBvcywgLTEpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdHRlblRvID0gZW5kO1xuICAgICAgICAgICAgaWYgKHRvID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdHRlblRvKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbykge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGRlY28uaGVpZ2h0UmVsZXZhbnQpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28udHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvID4gZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5zcGFuKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lRW5kID4gLTEgJiYgdGhpcy5saW5lRW5kIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICB0aGlzLmxpbmVFbmQgPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKS50bztcbiAgICB9XG4gICAgZW50ZXJMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubGluZUVuZCA9IHRvO1xuICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tIC0gMSB8fCB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIGZyb20gLSAxKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCh0aGlzLnBvcyAtIGZyb20sIC0xKSk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3M7XG4gICAgfVxuICAgIGJsYW5rQ29udGVudChmcm9tLCB0bykge1xuICAgICAgICBsZXQgZ2FwID0gbmV3IEhlaWdodE1hcEdhcCh0byAtIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5vcmFjbGUuZG9jLmxpbmVBdChmcm9tKS50byA9PSB0bylcbiAgICAgICAgICAgIGdhcC5mbGFncyB8PSA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLztcbiAgICAgICAgcmV0dXJuIGdhcDtcbiAgICB9XG4gICAgZW5zdXJlTGluZSgpIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA/IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgYWRkQmxvY2soYmxvY2spIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChibG9jay50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaChmcm9tKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPT0gMCA/IG51bGwgOiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xICYmICEobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLndyaXR0ZW5UbyA8IHRoaXMucG9zIHx8IGxhc3QgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgdGhpcy5wb3MpKTtcbiAgICAgICAgbGV0IHBvcyA9IGZyb207XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlSGVpZ2h0KHRoaXMub3JhY2xlLCBwb3MpO1xuICAgICAgICAgICAgcG9zICs9IG5vZGUgPyBub2RlLmxlbmd0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBjYWxsZWQgd2l0aCBhIHJlZ2lvbiB0aGF0IG9uIGJvdGggc2lkZXMgZWl0aGVyIHN0cmV0Y2hlc1xuICAgIC8vIHRvIGEgbGluZSBicmVhayBvciB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICAvLyBUaGUgcmV0dXJuZWQgYXJyYXkgdXNlcyBudWxsIHRvIGluZGljYXRlIGxpbmUgYnJlYWtzLCBidXQgbmV2ZXJcbiAgICAvLyBzdGFydHMgb3IgZW5kcyBpbiBhIGxpbmUgYnJlYWssIG9yIGhhcyBtdWx0aXBsZSBsaW5lIGJyZWFrcyBuZXh0XG4gICAgLy8gdG8gZWFjaCBvdGhlci5cbiAgICBzdGF0aWMgYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgTm9kZUJ1aWxkZXIoZnJvbSwgb3JhY2xlKTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyLCAwKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKGZyb20pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMoYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCwgMCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZSgpIHsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bywgYSwgYikge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGEgJiYgYS5oZWlnaHRSZWxldmFudCB8fCBiICYmIGIuaGVpZ2h0UmVsZXZhbnQpXG4gICAgICAgICAgICBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzLCA1KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpc2libGVQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBsZXQgbGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCksIHJpZ2h0ID0gTWF0aC5taW4od2luLmlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xuICAgIGxldCB0b3AgPSBNYXRoLm1heCgwLCByZWN0LnRvcCksIGJvdHRvbSA9IE1hdGgubWluKHdpbi5pbm5lckhlaWdodCwgcmVjdC5ib3R0b20pO1xuICAgIGZvciAobGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9IGRvYy5ib2R5Oykge1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbHQpO1xuICAgICAgICAgICAgaWYgKChlbHQuc2Nyb2xsSGVpZ2h0ID4gZWx0LmNsaWVudEhlaWdodCB8fCBlbHQuc2Nyb2xsV2lkdGggPiBlbHQuY2xpZW50V2lkdGgpICYmXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgIT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50UmVjdCA9IGVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGFyZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBwYXJlbnRSZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHBhcmVudFJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwYXJlbnQgPT0gZG9tLnBhcmVudE5vZGUgPyBwYXJlbnRSZWN0LmJvdHRvbSA6IE1hdGgubWluKGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcod3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5zaXplLCB3cmFwcGluZykgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSAwO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyhmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICB0aGlzLnNjYWxlciA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodCA8PSA3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyA/IElkU2NhbGVyIDpcbiAgICAgICAgICAgIG5ldyBCaWdTY2FsZXIodGhpcy5oZWlnaHRPcmFjbGUuZG9jLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLnN0YXRlLmRvYywgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2godGhpcy5zY2FsZXIuc2NhbGUgPT0gMSA/IGJsb2NrIDogc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0KVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fFxuICAgICAgICAgICAgdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh1cGRhdGVMaW5lcylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmICghdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXG4gICAgICAgICAgICAhdXBkYXRlLnN0YXRlLmZhY2V0KG5hdGl2ZVNlbGVjdGlvbkhpZGRlbikpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKHZpZXcpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcuY29udGVudERPTSwgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tLmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gZG9tLmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAsIGJpYXMgPSAwO1xuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCwgcGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDA7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb20uY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoIH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdGhpcy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBkb2MgPSB0aGlzLnN0YXRlLmRvYywgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh2aXNpYmxlVG9wIC0gbWFyZ2luVG9wICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHZpc2libGVCb3R0b20gKyAoMSAtIG1hcmdpblRvcCkgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgLy8gSWYgc2Nyb2xsVGFyZ2V0IGlzIGdpdmVuLCBtYWtlIHN1cmUgdGhlIHZpZXdwb3J0IGluY2x1ZGVzIHRoYXQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHsgaGVhZCB9ID0gc2Nyb2xsVGFyZ2V0LnJhbmdlO1xuICAgICAgICAgICAgaWYgKGhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IGhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSBtYXAubGluZUF0KGhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKSwgdG9wUG9zO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcImNlbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSAoYmxvY2sudG9wICsgYmxvY2suYm90dG9tKSAvIDIgLSB2aWV3SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcInN0YXJ0XCIgfHwgc2Nyb2xsVGFyZ2V0LnkgPT0gXCJuZWFyZXN0XCIgJiYgaGVhZCA8IHZpZXdwb3J0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLmJvdHRvbSAtIHZpZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh0b3BQb3MgLSAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHRvcFBvcyArIHZpZXdIZWlnaHQgKyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICBtYXBWaWV3cG9ydCh2aWV3cG9ydCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLmZyb20sIHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkudG8pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiB2aWV3cG9ydCBjb3ZlcnMgdGhlIHZpc2libGUgcGFydCBvZiB0aGVcbiAgICAvLyBkb2N1bWVudCBhbmQgbm90IHRvbyBtdWNoIGJleW9uZCB0aGF0LlxuICAgIHZpZXdwb3J0SXNBcHByb3ByaWF0ZSh7IGZyb20sIHRvIH0sIGJpYXMgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHsgdG9wIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCk7XG4gICAgICAgIGxldCB7IGJvdHRvbSB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmcm9tID09IDAgfHwgdG9wIDw9IHZpc2libGVUb3AgLSBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oLWJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvcCA+IHZpc2libGVUb3AgLSAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8gJiYgYm90dG9tIDwgdmlzaWJsZUJvdHRvbSArIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFnYXBzLmxlbmd0aCB8fCBjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMudG91Y2hlc1JhbmdlKGdhcC5mcm9tLCBnYXAudG8pKVxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHRoaXMuZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBzLnB1c2goZ2FwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZS50b3RhbCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCAtIHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICh0aGlzLnBpeGVsVmlld3BvcnQubGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FwcztcbiAgICB9XG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRvKSAtIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMuc29tZSgociwgaSkgPT4gci5mcm9tICE9IHJhbmdlc1tpXS5mcm9tIHx8IHIudG8gIT0gcmFuZ2VzW2ldLnRvKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuc3RhdGUuZG9jLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDFcbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2sudHlwZSkgPyBibG9jay50eXBlLm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay50eXBlKTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiYuY20tZWRpdG9yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAxXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNHB4XCJcbiAgICB9LFxuICAgIFwiLmNtLXNlbGVjdGlvbkxheWVyXCI6IHtcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PT0gOCAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwIHx8XG4gICAgICAgICAgICBicm93c2VyLmFuZHJvaWQgJiYgZG9tQ2hhbmdlLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCBMaW5lQnJlYWtQbGFjZWhvbGRlciksIGRvbUNoYW5nZS50ZXh0LCBwcmVmZXJyZWRQb3MgLSBmcm9tLCBwcmVmZXJyZWRTaWRlKTtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBpbnNlcnRzIHR3byBuZXdsaW5lcyB3aGVuIHByZXNzaW5nIHNoaWZ0LWVudGVyIGF0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIG9mIGEgbGluZS4gRG9tQ2hhbmdlIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgfHwgIXZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IG5ld1NlbC5tYWluLmVxKHNlbCkpKSB7XG4gICAgICAgIG5ld1NlbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghY2hhbmdlICYmICFuZXdTZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWNoYW5nZSAmJiBkb21DaGFuZ2UudHlwZU92ZXIgJiYgIXNlbC5lbXB0eSAmJiBuZXdTZWwgJiYgbmV3U2VsLm1haW4uZW1wdHkpIHtcbiAgICAgICAgLy8gSGV1cmlzdGljIHRvIG5vdGljZSB0eXBpbmcgb3ZlciBhIHNlbGVjdGVkIGNoYXJhY3RlclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBzZWwudG8pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmXG4gICAgICAgIChjaGFuZ2UuZnJvbSAhPSBzZWwuZnJvbSB8fCBjaGFuZ2UudG8gIT0gc2VsLnRvKSAmJlxuICAgICAgICAoc2VsLnRvIC0gc2VsLmZyb20pIC0gKGNoYW5nZS50byAtIGNoYW5nZS5mcm9tKSA8PSA0KSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGFuZ2UgaXMgaW5zaWRlIHRoZSBzZWxlY3Rpb24gYW5kIGNvdmVycyBtb3N0IG9mIGl0LFxuICAgICAgICAvLyBhc3N1bWUgaXQgaXMgYSBzZWxlY3Rpb24gcmVwbGFjZSAod2l0aCBpZGVudGljYWwgY2hhcmFjdGVycyBhdFxuICAgICAgICAvLyB0aGUgc3RhcnQvZW5kIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGlmZilcbiAgICAgICAgY2hhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sXG4gICAgICAgICAgICBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkuYXBwZW5kKGNoYW5nZS5pbnNlcnQpLmFwcGVuZCh2aWV3LnN0YXRlLmRvYy5zbGljZShjaGFuZ2UudG8sIHNlbC50bykpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKChicm93c2VyLm1hYyB8fCBicm93c2VyLmFuZHJvaWQpICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgLSAxICYmXG4gICAgICAgIC9eXFwuID8kLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgLy8gRGV0ZWN0IGluc2VydC1wZXJpb2Qtb24tZG91YmxlLXNwYWNlIE1hYyBhbmQgQW5kcm9pZCBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHRyYW5zZm9ybSBpdCBpbnRvIGEgcmVndWxhciBzcGFjZSBpbnNlcnQuXG4gICAgICAgIGlmIChuZXdTZWwgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMilcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxuICAgICAgICBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkgPT0gXCJcXG4gXCIgJiYgdmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiB5b3UgaW5zZXJ0IGEgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZFxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxuICAgICAgICAvLyBib2d1cyBuZXcgbGluZSB0byBiZSBjcmVhdGVkIGluIENvZGVNaXJyb3IgKCM5NjgpXG4gICAgICAgIGlmIChuZXdTZWwpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5pbnB1dFN0YXRlLmZsdXNoSU9TS2V5KHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgZmlyZSByZWFzb25hYmxlIGtleSBldmVudHMgZm9yIGVudGVyLFxuICAgICAgICAvLyBiYWNrc3BhY2UsIG9yIGRlbGV0ZS4gU28gdGhpcyBkZXRlY3RzIGNoYW5nZXMgdGhhdCBsb29rIGxpa2VcbiAgICAgICAgLy8gdGhleSdyZSBjYXVzZWQgYnkgdGhvc2Uga2V5cywgYW5kIHJlaW50ZXJwcmV0cyB0aGVtIGFzIGtleVxuICAgICAgICAvLyBldmVudHMuIChTb21lIG9mIHRoZXNlIGtleXMgYXJlIGFsc28gaGFuZGxlZCBieSBiZWZvcmVpbnB1dFxuICAgICAgICAvLyBldmVudHMgYW5kIHRoZSBwZW5kaW5nQW5kcm9pZEtleSBtZWNoYW5pc20sIGJ1dCB0aGF0J3Mgbm90XG4gICAgICAgIC8vIHJlbGlhYmxlIGluIGFsbCBzaXR1YXRpb25zLilcbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJlxuICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UuaW5zZXJ0LmxpbmVzID09IDIgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRW50ZXJcIiwgMTMpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gKyAxICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkRlbGV0ZVwiLCA0NikpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMClcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcrKztcbiAgICAgICAgbGV0IHRyO1xuICAgICAgICBpZiAoY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSA+PSAoc2VsLnRvIC0gc2VsLmZyb20pIC8gMyAmJlxuICAgICAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBzZWwuZnJvbSA8IGNoYW5nZS5mcm9tID8gc3RhcnRTdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgY2hhbmdlLmZyb20pIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgKyBhZnRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgICAgIGxldCBtYWluU2VsID0gbmV3U2VsICYmICFzdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmVxKG5ld1NlbC5tYWluKSAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aFxuICAgICAgICAgICAgICAgID8gbmV3U2VsLm1haW4gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgICAgIGlmIChzdGFydFN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byA+PSBzZWwudG8gLSAxMCkge1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvc2l0aW9uUmFuZ2UgPSBjb21wb3NpdGlvblN1cnJvdW5kaW5nTm9kZSh2aWV3KSB8fCB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBzZWwudG8gLSBjaGFuZ2UudG8sIHNpemUgPSBzZWwudG8gLSBzZWwuZnJvbTtcbiAgICAgICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXMsIHJhbmdlOiBtYWluU2VsIHx8IHJhbmdlLm1hcChjaGFuZ2VzKSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG8gPSByYW5nZS50byAtIG9mZnNldCwgZnJvbSA9IHRvIC0gcmVwbGFjZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgaW4gdGhlIHNhbWUgbm9kZSB3b3JrIHdpdGhvdXQgYWJvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlICYmIHJhbmdlLnRvID49IGNvbXBvc2l0aW9uUmFuZ2UuZnJvbSAmJiByYW5nZS5mcm9tIDw9IGNvbXBvc2l0aW9uUmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiByYW5nZUNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWF4KDAsIG1haW5TZWwuYW5jaG9yICsgc2VsT2ZmKSwgTWF0aC5tYXgoMCwgbWFpblNlbC5oZWFkICsgc2VsT2ZmKSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IG1haW5TZWwgJiYgc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmVwbGFjZVJhbmdlKG1haW5TZWwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLmNvbXBvc2VcIjtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5zdGFydFwiO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh0ciwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBtaW5MZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxuICAgICAgICBmcm9tKys7XG4gICAgaWYgKGZyb20gPT0gbWluTGVuICYmIGEubGVuZ3RoID09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdG9BID0gYS5sZW5ndGgsIHRvQiA9IGIubGVuZ3RoO1xuICAgIHdoaWxlICh0b0EgPiAwICYmIHRvQiA+IDAgJiYgYS5jaGFyQ29kZUF0KHRvQSAtIDEpID09IGIuY2hhckNvZGVBdCh0b0IgLSAxKSkge1xuICAgICAgICB0b0EtLTtcbiAgICAgICAgdG9CLS07XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIGZyb20gLSBNYXRoLm1pbih0b0EsIHRvQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gdG9BICsgYWRqdXN0IC0gZnJvbTtcbiAgICB9XG4gICAgaWYgKHRvQSA8IGZyb20gJiYgYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0EgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0IgPSBmcm9tICsgKHRvQiAtIHRvQSk7XG4gICAgICAgIHRvQSA9IGZyb207XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvQiA8IGZyb20pIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9CID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9BID0gZnJvbSArICh0b0EgLSB0b0IpO1xuICAgICAgICB0b0IgPSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0b0EsIHRvQiB9O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uUG9pbnRzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlICE9IGFuY2hvck5vZGUgfHwgZm9jdXNPZmZzZXQgIT0gYW5jaG9yT2Zmc2V0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xuICAgIHJldHVybiBhbmNob3IgPiAtMSAmJiBoZWFkID4gLTEgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciArIGJhc2UsIGhlYWQgKyBiYXNlKSA6IG51bGw7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcbmNvbnN0IHVzZUNoYXJEYXRhID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvLyBUaGUga25vd24gc2VsZWN0aW9uLiBLZXB0IGluIG91ciBvd24gb2JqZWN0LCBhcyBvcHBvc2VkIHRvIGp1c3RcbiAgICAgICAgLy8gZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBzZWxlY3Rpb24gYmVjYXVzZTpcbiAgICAgICAgLy8gIC0gU2FmYXJpIGRvZXNuJ3QgcmVwb3J0IHRoZSByaWdodCBzZWxlY3Rpb24gaW4gc2hhZG93IERPTVxuICAgICAgICAvLyAgLSBSZWFkaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBmb3JjZXMgYSBET00gbGF5b3V0XG4gICAgICAgIC8vICAtIFRoaXMgd2F5LCB3ZSBjYW4gaWdub3JlIHNlbGVjdGlvbmNoYW5nZSBldmVudHMgaWYgd2UgaGF2ZVxuICAgICAgICAvLyAgICBhbHJlYWR5IHNlZW4gdGhlICduZXcnIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gbmV3IERPTVNlbGVjdGlvblN0YXRlO1xuICAgICAgICAvLyBTZXQgd2hlbiBhIHNlbGVjdGlvbiBjaGFuZ2UgaXMgZGV0ZWN0ZWQsIGNsZWFyZWQgb24gZmx1c2hcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXBzID0gW107XG4gICAgICAgIC8vIFRpbWVvdXQgZm9yIHNjaGVkdWxpbmcgY2hlY2sgb2YgdGhlIHBhcmVudHMgdGhhdCBuZWVkIHNjcm9sbCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiBtdXRhdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvbiBvclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlciB0ZXh0IG5vZGUpIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbnJlbGF0ZWRseSwgaU9TIFNhZmFyaSB3aWxsLCB3aGVuIGVuZGluZyBhIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyByZWluc2VydCB0aGUgZmluaXNoZWQgdGV4dC4gQ29kZU1pcnJvcidzIGhhbmRsaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gZGVsZXRpb24gd2lsbCBwcmV2ZW50IHRoZSByZWluc2VydGlvbiBmcm9tIGhhcHBlbmluZyxcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmlvcyAmJiB2aWV3LmNvbXBvc2luZykgJiZcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblByaW50ID0gdGhpcy5vblByaW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy52aWV3LmRvY1ZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0VXBkYXRlKSA8IERhdGUubm93KCkgLSA3NSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZS5vYnNlcnZlKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuU2Nyb2xsSGFuZGxlcnModGhpcy52aWV3LCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmICghdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKSB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWwgPSB0aGlzLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odmlldy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3Lm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lmlnbm9yZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKCF3YXNDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgaGFzIGEgc2ltaWxhciBpc3N1ZSB3aGVuIGJhY2tzcGFjaW5nIG91dCBhXG4gICAgICAgIC8vIHNlbGVjdGlvbiAoIzY0NSkuXG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJlxuICAgICAgICAgICAgLy8gKFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRSlcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmVhZFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGUgU2VsZWN0aW9uIG9iamVjdCBpcyBicm9rZW4gaW4gc2hhZG93IHJvb3RzIGluIFNhZmFyaS4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0XG4gICAgICAgIGxldCByYW5nZSA9IGJyb3dzZXIuc2FmYXJpICYmIHZpZXcucm9vdC5ub2RlVHlwZSA9PSAxMSAmJlxuICAgICAgICAgICAgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb20gJiZcbiAgICAgICAgICAgIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh0aGlzLnZpZXcpIHx8IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAoIXJhbmdlIHx8IHRoaXMuc2VsZWN0aW9uUmFuZ2UuZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbG9jYWwgPSBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHJhbmdlKTtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSBzaXR1YXRpb24gd2hlcmUgdGhlIGJyb3dzZXIgaGFzLCBvbiBmb2N1cywgbW92ZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC4gUmVzZXQgaXQgdG8gdGhlXG4gICAgICAgIC8vIHBvc2l0aW9uIGZyb20gdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgICAgaWYgKGxvY2FsICYmICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBhdEVsZW1lbnRTdGFydCh0aGlzLmRvbSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKGxvY2FsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjbGVhclNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChudWxsLCAwLCBudWxsLCAwKTtcbiAgICB9XG4gICAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHRoaXMuZG9tOyBkb207KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLnB1c2goZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZShmKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gICAgLy8gZG9lc24ndCByZWxpYWJseSBmaXJlIHJlZ3VsYXIga2V5IGV2ZW50cywgYnV0IGFsc28gb2Z0ZW5cbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgICAvLyBvciBvdGhlciBraW5kcyBvZiBjb3JydXB0aW9uLiBUaGlzIGhhY2sgbWFrZXMgdGhlIGVkaXRvciBiYWNrIG9mZlxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xuICAgIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIHRyaWVzIHRvIGZsdXNoXG4gICAgLy8gdGhlbSBvciwgaWYgdGhhdCBoYXMgbm8gZWZmZWN0LCBkaXNwYXRjaGVzIHRoZSBnaXZlbiBrZXkuXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgbGV0IGZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5mbHVzaCgpICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHJlY29yZHMucHVzaChtdXQpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V0XHUyMDE0dGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWRcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjVmlldy5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXG4gICAgICAgICAgICBjVmlldy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgaWYgKHdpbiAhPSB0aGlzLndpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQoY1ZpZXcsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVmlldyA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICBpZiAoY3VyVmlldyAmJiBjdXJWaWV3LnBhcmVudCA9PSBjVmlldylcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSBjVmlldy5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd3Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdFx1MjAxNHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5jb250ZW50RE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIFx1MjE5MiBVcGRhdGluZyBcdTIxQzYgSWRsZSAodW5jaGVja2VkKSBcdTIxOTIgTWVhc3VyaW5nIFx1MjE5MiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHUyMTkxICAgICAgXHUyMTkzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXG4gICAgdmlldywgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5NYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0ge307XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5jbGFzc05hbWUgPSBcImNtLXNjcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwMDBweFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGNvbmZpZy5kaXNwYXRjaCB8fCAoKHRyKSA9PiB0aGlzLnVwZGF0ZShbdHJdKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaChpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRbMF1cbiAgICAgICAgICAgIDogdGhpcy5zdGF0ZS51cGRhdGUoLi4uaW5wdXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIERPTSBjaGFuZ2UsIGVhZ2VybHkgcmVhZCBpdCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGFwcGx5IGl0IGFmdGVyIHRoZSBnaXZlbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKHBlbmRpbmdLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyeSB0byBhcHBseSBET00gY2hhbmdlcyBpZiB0aGUgdHJhbnNhY3Rpb25zIGRpZG4ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBkb2Mgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykgIT0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG1haW4gfSA9IHRyLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHJlZHJhd24sIHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwic2VsZWN0LnBvaW50ZXJcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHRoZW1lKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhlbWUpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmNvbnRlbnRET00sIHBlbmRpbmdLZXkua2V5LCBwZW5kaW5nS2V5LmtleUNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZkhlaWdodCA9IHNjcm9sbFRvcCA+IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCAtIDQgPyBzY3JvbGxIZWlnaHQgOiBzY3JvbGxUb3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGxldCByZWZCbG9jayA9IHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KHJlZkhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSlcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMubWVhc3VyZVJlcXVlc3RzLCBtZWFzdXJpbmddID0gW21lYXN1cmluZywgdGhpcy5tZWFzdXJlUmVxdWVzdHNdO1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5yZWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZSwgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocmVmQmxvY2suZnJvbSkudG9wIC0gcmVmQmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRE9NLnNjcm9sbFRvcCArPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IG9sZFZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSBvbGRWaWV3cG9ydC50byAmJlxuICAgICAgICAgICAgICAgICAgICAhc2Nyb2xsZWQgJiYgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gYXR0cnNGcm9tRmFjZXQodGhpcywgZWRpdG9yQXR0cmlidXRlcywge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNvbnRlbnRBdHRycyA9IHtcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0ua2V5ID09PSByZXF1ZXN0LmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGx1Z2luLCBpZiBwcmVzZW50LiBOb3RlIHRoYXRcbiAgICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xuICAgIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBwbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMucGx1Z2luTWFwLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoa25vd24gPT09IHVuZGVmaW5lZCB8fCBrbm93biAmJiBrbm93bi5zcGVjICE9IHBsdWdpbilcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLnNldChwbHVnaW4sIGtub3duID0gdGhpcy5wbHVnaW5zLmZpbmQocCA9PiBwLnNwZWMgPT0gcGx1Z2luKSB8fCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGtub3duICYmIGtub3duLnVwZGF0ZSh0aGlzKS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnQsIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVGhpc1xuICAgIG1heSBiZSBuZWdhdGl2ZSB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsZWQgZG93bi4gUG9pbnRzXG4gICAgZGlyZWN0bHkgdG8gdGhlIHRvcCBvZiB0aGUgZmlyc3QgbGluZSwgbm90IGFib3ZlIHRoZSBwYWRkaW5nLlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcG9ydHMgdGhlIHBhZGRpbmcgYWJvdmUgYW5kIGJlbG93IHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcCwgYm90dG9tOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nQm90dG9tIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgbGluZSBvciBibG9jayB3aWRnZXQgYXQgdGhlIGdpdmVuIHZlcnRpY2FsXG4gICAgcG9zaXRpb24gKHdoaWNoIGlzIGludGVycHJldGVkIGFzIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkpLlxuICAgICovXG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuZWxlbWVudEF0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgKHNlZVxuICAgIFtgbGluZUJsb2NrQXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgYXQgdGhlIGdpdmVuXG4gICAgaGVpZ2h0LCBhZ2FpbiBpbnRlcnByZXRlZCByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApLlxuICAgICovXG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCBhbmQgdmVydGljYWwgcG9zaXRpb24gb2YgYWxsIFtsaW5lXG4gICAgYmxvY2tzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgaW4gdGhlIHZpZXdwb3J0LiBQb3NpdGlvbnNcbiAgICBhcmUgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKTtcbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydExpbmVCbG9ja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydExpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIGFyb3VuZCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIEEgbGluZVxuICAgIGJsb2NrIGlzIGEgcmFuZ2UgZGVsaW1pdGVkIG9uIGJvdGggc2lkZXMgYnkgZWl0aGVyIGFcbiAgICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgbGluZSBicmVha3MsIG9yIHRoZVxuICAgIHN0YXJ0L2VuZCBvZiB0aGUgZG9jdW1lbnQuIEl0IHdpbGwgdXN1YWxseSBqdXN0IGhvbGQgYSBsaW5lIG9mXG4gICAgdGV4dCwgYnV0IG1heSBiZSBicm9rZW4gaW50byBtdWx0aXBsZSB0ZXh0YmxvY2tzIGJ5IGJsb2NrXG4gICAgd2lkZ2V0cy5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxuICAgICovXG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGJ5IFtncmFwaGVtZVxuICAgIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gSW5cbiAgICBiaWRpcmVjdGlvbmFsIHRleHQsIHRoZSBsaW5lIGlzIHRyYXZlcnNlZCBpbiB2aXN1YWwgb3JkZXIsIHVzaW5nXG4gICAgdGhlIGVkaXRvcidzIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4gICAgV2hlbiB0aGUgc3RhcnQgcG9zaXRpb24gd2FzIHRoZSBsYXN0IG9uZSBvbiB0aGUgbGluZSwgdGhlXG4gICAgcmV0dXJuZWQgcG9zaXRpb24gd2lsbCBiZSBhY3Jvc3MgdGhlIGxpbmUgYnJlYWsuIElmIHRoZXJlIGlzIG5vXG4gICAgZnVydGhlciBsaW5lLCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgbW92ZXMgb3ZlciBhIHNpbmdsZSBjbHVzdGVyLiBUaGVcbiAgICBvcHRpb25hbCBgYnlgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIG1vdmUgYWNyb3NzIG1vcmUuIEl0IHdpbGxcbiAgICBiZSBjYWxsZWQgd2l0aCB0aGUgZmlyc3QgY2x1c3RlciBhcyBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm5cbiAgICBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMsIGZvciBlYWNoIHN1YnNlcXVlbnQgY2x1c3RlcixcbiAgICB3aGV0aGVyIGl0IHNob3VsZCBhbHNvIGJlIG1vdmVkIG92ZXIuXG4gICAgKi9cbiAgICBtb3ZlQnlDaGFyKHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBieSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGFjcm9zcyB0aGUgbmV4dCBncm91cCBvZiBlaXRoZXJcbiAgICBbbGV0dGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIG9yIG5vbi1sZXR0ZXJcbiAgICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgbW92ZUJ5R3JvdXAoc3RhcnQsIGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbilcdTIwMTRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLmJpZGlDYWNoZSlcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcbiAgICAgICAgbGV0IG9yZGVyID0gY29tcHV0ZU9yZGVyKGxpbmUudGV4dCwgZGlyKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICAgIFRoZSB2YWx1ZSBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gaGFuZGxlclxuICAgIGZ1bmN0aW9ucy4gRm9yIGFueSBnaXZlbiBldmVudCwgc3VjaCBmdW5jdGlvbnMgYXJlIG9yZGVyZWQgYnlcbiAgICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcbiAgICBiZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZCB0aGF0IGV2ZW50LCBhbmQgbm8gb3RoZXIgaGFuZGxlcnMgb3JcbiAgICBidWlsdC1pbiBiZWhhdmlvciB3aWxsIGJlIGFjdGl2YXRlZCBmb3IgaXQuIFRoZXNlIGFyZSByZWdpc3RlcmVkXG4gICAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcbiAgICBmb3IgYHNjcm9sbGAgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZVxuICAgIGVkaXRvcidzIFtzY3JvbGwgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2Nyb2xsRE9NKSBvciBvbmUgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbilcbiAgICBzdHlsZSBzcGVjIHByb3ZpZGluZyB0aGUgc3R5bGVzIGZvciB0aGUgdGhlbWUuIFRoZXNlIHdpbGwgYmVcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gICAgXG4gICAgQmVjYXVzZSB0aGUgc2VsZWN0b3JzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCBhIHNjb3BlIGNsYXNzLCBydWxlXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb20pXHUyMDE0dG8gd2hpY2ggdGhlIHNjb3BlIGNsYXNzIHdpbGwgYmVcbiAgICBhZGRlZFx1MjAxNG5lZWQgdG8gYmUgZXhwbGljaXRseSBkaWZmZXJlbnRpYXRlZCBieSBhZGRpbmcgYW4gYCZgIHRvXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnRcdTIwMTRmb3IgZXhhbXBsZVxuICAgIGAmLmNtLWZvY3VzZWRgLlxuICAgIFxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgICB3aGljaCB3aWxsIGNhdXNlIHRoZSBgJmRhcmtgIHJ1bGVzIGZyb20gW2Jhc2VcbiAgICB0aGVtZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmJhc2VUaGVtZSkgdG8gYmUgdXNlZCAoYXMgb3Bwb3NlZCB0b1xuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAgICovXG4gICAgc3RhdGljIHRoZW1lKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFt0aGVtZS5vZihwcmVmaXgpLCBzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKGAuJHtwcmVmaXh9YCwgc3BlYykpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXJrKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gICAgd2l0aCBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpLCB1c2UgYCZgIHRvIGluZGljYXRlIHRoZVxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXG4gICAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICAgIHRhcmdldCBlZGl0b3JzIHdpdGggYSBkYXJrIG9yIGxpZ2h0IHRoZW1lLlxuICAgICovXG4gICAgc3RhdGljIGJhc2VUaGVtZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBQcmVjLmxvd2VzdChzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHNwZWMsIGxpZ2h0RGFya0lEcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYW4gZWRpdG9yIHZpZXcgaW5zdGFuY2UgZnJvbSB0aGUgdmlldydzIERPTVxuICAgIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tRE9NKGRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZW50ID0gZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tY29udGVudFwiKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gY29udGVudCAmJiBDb250ZW50Vmlldy5nZXQoY29udGVudCkgfHwgQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIHJldHVybiAoKF9hID0gY1ZpZXcgPT09IG51bGwgfHwgY1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNWaWV3LnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkZhY2V0IHRvIGFkZCBhIFtzdHlsZVxubW9kdWxlXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbikgdG9cbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcbm1vdW50ZWQgaW4gaXRzIFtkb2N1bWVudFxucm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29uc3RydWN0b3JeY29uZmlnLnJvb3QpLlxuKi9cbkVkaXRvclZpZXcuc3R5bGVNb2R1bGUgPSBzdHlsZU1vZHVsZTtcbi8qKlxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxuRE9NIGNvbnRlbnQgYXJlIGhhbmRsZWQuIEhhbmRsZXJzIGFyZSBwYXNzZWQgdGhlIGRvY3VtZW50XG5wb3NpdGlvbnMgYmV0d2VlbiB3aGljaCB0aGUgY2hhbmdlIHdhcyBmb3VuZCwgYW5kIHRoZSBuZXdcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcbmNhbGxlZCBhbmQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLlxuKi9cbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuLyoqXG5CeSBkZWZhdWx0LCB0aGUgZWRpdG9yIGFzc3VtZXMgYWxsIGl0cyBjb250ZW50IGhhcyB0aGUgc2FtZVxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxudmFsdWUgdG8gbWFrZSBpdCByZWFkIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiBldmVyeSAocmVuZGVyZWQpXG5saW5lIHNlcGFyYXRlbHkuXG4qL1xuRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHBlckxpbmVUZXh0RGlyZWN0aW9uO1xuLyoqXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcbmxpYnJhcnkgY2F0Y2hlcyBhbiBleGNlcHRpb24gZnJvbSBhbiBleHRlbnNpb24gKG1vc3RseSBmcm9tIHZpZXdcbnBsdWdpbnMsIGJ1dCBtYXkgYmUgdXNlZCBieSBvdGhlciBleHRlbnNpb25zIHRvIHJvdXRlIGV4Y2VwdGlvbnNcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcbmRlYnVnZ2luZyBhbmQgbG9nZ2luZy4gU2VlIFtgbG9nRXhjZXB0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxvZ0V4Y2VwdGlvbikuXG4qL1xuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lciA9IHVwZGF0ZUxpc3RlbmVyO1xuLyoqXG5GYWNldCB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvciBjb250ZW50IERPTSBpcyBlZGl0YWJsZS5cbldoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgZWxlbWVudCB3aWxsXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcbm5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LiBUaGVcbmRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY2hlY2sgYGV2ZW50Lm1ldGFLZXlgIG9uIG1hY09TLCBhbmRcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXG4qL1xuRWRpdG9yVmlldy5jbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlO1xuLyoqXG5BIGZhY2V0IHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKVxuYXJlIHNob3duIGluIHRoZSB2aWV3LiBEZWNvcmF0aW9ucyBjYW4gYmUgcHJvdmlkZWQgaW4gdHdvXG53YXlzXHUyMDE0ZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXG5cbk9ubHkgZGVjb3JhdGlvbiBzZXRzIHByb3ZpZGVkIGRpcmVjdGx5IGFyZSBhbGxvd2VkIHRvIGluZmx1ZW5jZVxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXG5mdW5jdGlvbnMgYXJlIGNhbGxlZCBfYWZ0ZXJfIHRoZSBuZXcgdmlld3BvcnQgaGFzIGJlZW4gY29tcHV0ZWQsXG5hbmQgdGh1cyAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrIHdpZGdldHMgb3IgcmVwbGFjaW5nXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxuXG5JZiB5b3Ugd2FudCBkZWNvcmF0ZWQgcmFuZ2VzIHRvIGJlaGF2ZSBsaWtlIGF0b21pYyB1bml0cyBmb3JcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxuY29udGFpbmluZyB0aGUgZGVjb3JhdGlvbnMgdG9cbltgRWRpdG9yVmlldy5hdG9taWNSYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15hdG9taWNSYW5nZXMpLlxuKi9cbkVkaXRvclZpZXcuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcbm1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGUgc2lkZXMgb2YgdGhlIHNjcm9sbGluZyBlbGVtZW50IHRoYXRcbnNob3VsZCBiZSBjb25zaWRlcmVkIGludmlzaWJsZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcbi8qKlxuVGhpcyBmYWNldCByZWNvcmRzIHdoZXRoZXIgYSBkYXJrIHRoZW1lIGlzIGFjdGl2ZS4gVGhlIGV4dGVuc2lvblxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XG5pbmNsdWRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIHdoZW4gdGhlIGBkYXJrYCBvcHRpb24gaXMgc2V0IHRvXG50cnVlLlxuKi9cbkVkaXRvclZpZXcuZGFya1RoZW1lID0gZGFya1RoZW1lO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xuZWRpdGFibGUgRE9NIGVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3Mgb3V0ZXJcbmVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5lZGl0b3JBdHRyaWJ1dGVzID0gZWRpdG9yQXR0cmlidXRlcztcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBsaW5lIHdyYXBwaW5nIGluIHRoZSBlZGl0b3IgKGJ5XG5zZXR0aW5nIENTUyBgd2hpdGUtc3BhY2VgIHRvIGBwcmUtd3JhcGAgaW4gdGhlIGNvbnRlbnQpLlxuKi9cbkVkaXRvclZpZXcubGluZVdyYXBwaW5nID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YoeyBcImNsYXNzXCI6IFwiY20tbGluZVdyYXBwaW5nXCIgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB1c2VkIHRvIGluY2x1ZGUgc2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnRzIGluIGFcbnRyYW5zYWN0aW9uLiBUaGVzZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBET00gaW4gYSB2aXN1YWxseSBoaWRkZW5cbmVsZW1lbnQgd2l0aCBgYXJpYS1saXZlPVwicG9saXRlXCJgIHNldCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvXG5kZXNjcmliZSBlZmZlY3RzIHRoYXQgYXJlIHZpc3VhbGx5IG9idmlvdXMgYnV0IG1heSBub3QgYmVcbm5vdGljZWQgYnkgc2NyZWVuIHJlYWRlciB1c2VycyAoc3VjaCBhcyBtb3ZpbmcgdG8gdGhlIG5leHRcbnNlYXJjaCBtYXRjaCkuXG4qL1xuRWRpdG9yVmlldy5hbm5vdW5jZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8vIE1heGltdW0gbGluZSBsZW5ndGggZm9yIHdoaWNoIHdlIGNvbXB1dGUgYWNjdXJhdGUgYmlkaSBpbmZvXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGxhc3REaXIgPSBjYWNoZS5sZW5ndGggPyBjYWNoZVtjYWNoZS5sZW5ndGggLSAxXS5kaXIgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoMCwgY2FjaGUubGVuZ3RoIC0gMTApOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IGNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmRpciA9PSBsYXN0RGlyICYmICFjaGFuZ2VzLnRvdWNoZXNSYW5nZShlbnRyeS5mcm9tLCBlbnRyeS50bykpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IENhY2hlZE9yZGVyKGNoYW5nZXMubWFwUG9zKGVudHJ5LmZyb20sIDEpLCBjaGFuZ2VzLm1hcFBvcyhlbnRyeS50bywgLTEpLCBlbnRyeS5kaXIsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICBsZXQgcGFydHMgPSBrZXkuc3BsaXQoLyAoPyEkKS8pLm1hcChrID0+IG5vcm1hbGl6ZUtleU5hbWUoaywgcGxhdGZvcm0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgY2hlY2tQcmVmaXgocHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc2NvcGVPYmpbcHJlZml4XSlcbiAgICAgICAgICAgICAgICBzY29wZU9ialtwcmVmaXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuOiBbKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3VyT2JqID0gc3RvcmVkUHJlZml4ID0geyB2aWV3LCBwcmVmaXgsIHNjb3BlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGlmIChzdG9yZWRQcmVmaXggPT0gb3VyT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsOyB9LCBQcmVmaXhUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbCA9IHBhcnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICBjaGVja1ByZWZpeChmdWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBiaW5kaW5nID0gc2NvcGVPYmpbZnVsbF0gfHwgKHNjb3BlT2JqW2Z1bGxdID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHJ1bjogKChfYiA9IChfYSA9IHNjb3BlT2JqLl9hbnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgpKSB8fCBbXSB9KTtcbiAgICAgICAgaWYgKGNvbW1hbmQpXG4gICAgICAgICAgICBiaW5kaW5nLnJ1bi5wdXNoKGNvbW1hbmQpO1xuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBiaW5kaW5nLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvciAobGV0IGIgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgbGV0IHNjb3BlcyA9IGIuc2NvcGUgPyBiLnNjb3BlLnNwbGl0KFwiIFwiKSA6IFtcImVkaXRvclwiXTtcbiAgICAgICAgaWYgKGIuYW55KVxuICAgICAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlT2JqLl9hbnkpXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqLl9hbnkgPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgcnVuOiBbXSB9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzY29wZU9iailcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmpba2V5XS5ydW4ucHVzaChiLmFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcbiAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpO1xuICAgIGxldCBjaGFyQ29kZSA9IGNvZGVQb2ludEF0KG5hbWUsIDApLCBpc0NoYXIgPSBjb2RlUG9pbnRTaXplKGNoYXJDb2RlKSA9PSBuYW1lLmxlbmd0aCAmJiBuYW1lICE9IFwiIFwiO1xuICAgIGxldCBwcmVmaXggPSBcIlwiLCBmYWxsdGhyb3VnaCA9IGZhbHNlO1xuICAgIGlmIChzdG9yZWRQcmVmaXggJiYgc3RvcmVkUHJlZml4LnZpZXcgPT0gdmlldyAmJiBzdG9yZWRQcmVmaXguc2NvcGUgPT0gc2NvcGUpIHtcbiAgICAgICAgcHJlZml4ID0gc3RvcmVkUHJlZml4LnByZWZpeCArIFwiIFwiO1xuICAgICAgICBpZiAoZmFsbHRocm91Z2ggPSBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XG4gICAgbGV0IHJ1bkZvciA9IChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXG4gICAgICAgICAgICAgICAgaWYgKCFyYW4uaGFzKGNtZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuLmFkZChjbWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxuICAgICAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoc2hpZnROYW1lLCBldmVudCwgZmFsc2UpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqLl9hbnkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxsdGhyb3VnaDtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBkcmF3U2VsZWN0aW9uUGx1Z2luLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuY2xhc3MgUGllY2Uge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgYWRqdXN0KGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy53aWR0aCA+PSAwKVxuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgICBlcShwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgPT0gcC5sZWZ0ICYmIHRoaXMudG9wID09IHAudG9wICYmIHRoaXMud2lkdGggPT0gcC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PSBwLmhlaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPT0gcC5jbGFzc05hbWU7XG4gICAgfVxufVxuY29uc3QgZHJhd1NlbGVjdGlvblBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnJhbmdlUGllY2VzID0gW107XG4gICAgICAgIHRoaXMuY3Vyc29ycyA9IFtdO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3U2VsLmJpbmQodGhpcykgfTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllciA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLmNsYXNzTmFtZSA9IFwiY20tc2VsZWN0aW9uTGF5ZXJcIjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIgPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5jbGFzc05hbWUgPSBcImNtLWN1cnNvckxheWVyXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIHRoaXMuc2V0QmxpbmtSYXRlKCk7XG4gICAgfVxuICAgIHNldEJsaW5rUmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZkNoYW5nZWQgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBpZiAoY29uZkNoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5zZXRCbGlua1JhdGUoKTtcbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY29uZiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCByYW5nZVBpZWNlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogbWVhc3VyZVJhbmdlKHRoaXMudmlldywgcikpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IG1lYXN1cmVDdXJzb3IodGhpcy52aWV3LCByLCBwcmltKTtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VQaWVjZXMsIGN1cnNvcnMgfTtcbiAgICB9XG4gICAgZHJhd1NlbCh7IHJhbmdlUGllY2VzLCBjdXJzb3JzIH0pIHtcbiAgICAgICAgaWYgKHJhbmdlUGllY2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlUGllY2VzLmxlbmd0aCB8fCByYW5nZVBpZWNlcy5zb21lKChwLCBpKSA9PiAhcC5lcSh0aGlzLnJhbmdlUGllY2VzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiByYW5nZVBpZWNlcylcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLmFwcGVuZENoaWxkKHAuZHJhdygpKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VQaWVjZXMgPSByYW5nZVBpZWNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyc29ycy5sZW5ndGggIT0gdGhpcy5jdXJzb3JzLmxlbmd0aCB8fCBjdXJzb3JzLnNvbWUoKGMsIGkpID0+ICFjLmVxKHRoaXMuY3Vyc29yc1tpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkQ3Vyc29ycyA9IHRoaXMuY3Vyc29yTGF5ZXIuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAob2xkQ3Vyc29ycy5sZW5ndGggIT09IGN1cnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JMYXllci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGN1cnNvcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuYXBwZW5kQ2hpbGQoYy5kcmF3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29ycy5mb3JFYWNoKChjLCBpZHgpID0+IGMuYWRqdXN0KG9sZEN1cnNvcnNbaWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3JzID0gY3Vyc29ycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuY29uc3QgdGhlbWVTcGVjID0ge1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH0sXG4gICAgICAgIFwiJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9XG4gICAgfVxufTtcbmlmIChDYW5IaWRlUHJpbWFyeSlcbiAgICB0aGVtZVNwZWNbXCIuY20tbGluZVwiXS5jYXJldENvbG9yID0gXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCI7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy50aGVtZSh0aGVtZVNwZWMpKTtcbmZ1bmN0aW9uIGdldEJhc2Uodmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCwgdG9wOiByZWN0LnRvcCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCB9O1xufVxuZnVuY3Rpb24gd3JhcHBlZExpbmUodmlldywgcG9zLCBpbnNpZGUpIHtcbiAgICBsZXQgcmFuZ2UgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgcmV0dXJuIHsgZnJvbTogTWF0aC5tYXgoaW5zaWRlLmZyb20sIHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmYWxzZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHRvOiBNYXRoLm1pbihpbnNpZGUudG8sIHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlLCB0cnVlKS5mcm9tKSxcbiAgICAgICAgdHlwZTogQmxvY2tUeXBlLlRleHQgfTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLnRvID4gcG9zIHx8IGwudG8gPT0gcG9zICYmIChsLnRvID09IGxpbmUudG8gfHwgbC50eXBlID09IEJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbWVhc3VyZVJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnRvIDw9IHZpZXcudmlld3BvcnQuZnJvbSB8fCByYW5nZS5mcm9tID49IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHJhbmdlLmZyb20sIHZpZXcudmlld3BvcnQuZnJvbSksIHRvID0gTWF0aC5taW4ocmFuZ2UudG8sIHZpZXcudmlld3BvcnQudG8pO1xuICAgIGxldCBsdHIgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICBsZXQgbGluZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudC5maXJzdENoaWxkKTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICsgcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdMZWZ0KSArIE1hdGgubWluKDAsIHBhcnNlSW50KGxpbmVTdHlsZS50ZXh0SW5kZW50KSk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICBpZiAodmlzdWFsU3RhcnQpXG4gICAgICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIHZpc3VhbFN0YXJ0KTtcbiAgICAgICAgaWYgKHZpc3VhbEVuZClcbiAgICAgICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCB2aXN1YWxFbmQpO1xuICAgIH1cbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kICYmIHZpc3VhbFN0YXJ0LmZyb20gPT0gdmlzdWFsRW5kLmZyb20pIHtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyhkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCByYW5nZS50bywgdmlzdWFsU3RhcnQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3AgPSB2aXN1YWxTdGFydCA/IGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIG51bGwsIHZpc3VhbFN0YXJ0KSA6IGRyYXdGb3JXaWRnZXQoc3RhcnRCbG9jaywgZmFsc2UpO1xuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcbiAgICAgICAgbGV0IGJldHdlZW4gPSBbXTtcbiAgICAgICAgaWYgKCh2aXN1YWxTdGFydCB8fCBzdGFydEJsb2NrKS50byA8ICh2aXN1YWxFbmQgfHwgZW5kQmxvY2spLmZyb20gLSAxKVxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcbiAgICAgICAgZWxzZSBpZiAodG9wLmJvdHRvbSA8IGJvdHRvbS50b3AgJiYgdmlldy5lbGVtZW50QXRIZWlnaHQoKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDIpLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICB0b3AuYm90dG9tID0gYm90dG9tLnRvcCA9ICh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyO1xuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFBpZWNlKGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wIC0gMC4wMSAvKiBDLkVwc2lsb24gKi8sIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wICsgMC4wMSAvKiBDLkVwc2lsb24gKi8sIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oZnJvbUNvb3Jkcy50b3AsIHRvQ29vcmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGZyb21Db29yZHMuYm90dG9tLCB0b0Nvb3Jkcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKGx0ciAmJiBmcm9tT3BlbiA/IGxlZnRTaWRlIDogZnJvbUNvb3Jkcy5sZWZ0LCBsdHIgJiYgdG9PcGVuID8gcmlnaHRTaWRlIDogdG9Db29yZHMucmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IGxpbmUuZnJvbSwgZW5kID0gdG8gIT09IG51bGwgJiYgdG8gIT09IHZvaWQgMCA/IHRvIDogbGluZS50bztcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpXG4gICAgICAgICAgICBpZiAoci50byA+IHN0YXJ0ICYmIHIuZnJvbSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvY0xpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BhbiBvZiB2aWV3LmJpZGlTcGFucyhkb2NMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Gcm9tID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3BhbihNYXRoLm1heChzcGFuRnJvbSwgcG9zKSwgZnJvbSA9PSBudWxsICYmIHNwYW5Gcm9tIDw9IHN0YXJ0LCBNYXRoLm1pbihzcGFuVG8sIGVuZFBvcyksIHRvID09IG51bGwgJiYgc3BhblRvID49IGVuZCwgc3Bhbi5kaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWwubGVuZ3RoID09IDApXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XG4gICAgICAgIGxldCB5ID0gY29udGVudFJlY3QudG9wICsgKHRvcCA/IGJsb2NrLnRvcCA6IGJsb2NrLmJvdHRvbSk7XG4gICAgICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBob3Jpem9udGFsOiBbXSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lYXN1cmVDdXJzb3IodmlldywgY3Vyc29yLCBwcmltYXJ5KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MoY3Vyc29yLmhlYWQsIGN1cnNvci5hc3NvYyB8fCAxKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIHJldHVybiBuZXcgUGllY2UocG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgLTEsIHBvcy5ib3R0b20gLSBwb3MudG9wLCBwcmltYXJ5ID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIik7XG59XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB0aGlzLnZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvdXRlciA9IHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xuICAgIGxldCB2aXNpYmxlID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICh2aXNpYmxlLmxlbmd0aCA9PSAxICYmIHZpc2libGVbMF0uZnJvbSA9PSB2aWV3LnZpZXdwb3J0LmZyb20gJiZcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBmcm9tIC0gbWF4TGVuZ3RoKTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvLCB0byArIG1heExlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPSB0bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGVscGVyIGNsYXNzIHVzZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWFpbnRhaW4gZGVjb3JhdGlvbnMgb25cbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcbmluIGEgW3ZpZXcgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikuIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdFxucmVwcmVzZW50IGEgbWF0Y2hpbmcgY29uZmlndXJhdGlvbi5cbiovXG5jbGFzcyBNYXRjaERlY29yYXRvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdleHAuZ2xvYmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVndWxhciBleHByZXNzaW9uIGdpdmVuIHRvIE1hdGNoRGVjb3JhdG9yIHNob3VsZCBoYXZlIGl0cyAnZycgZmxhZyBzZXRcIik7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICBpZiAoZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4gZGVjb3JhdGUoYWRkLCBmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBtYXRjaCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29yYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgICAgICBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWRkID0gYnVpbGQuYWRkLmJpbmQoYnVpbGQpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgVGFiV2lkZ2V0KChzaXplIC0gKGNvbCAlIHNpemUpKSAqIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLSB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdmlldy5kb2N1bWVudFBhZGRpbmcudG9wIC0gMC41O1xuICAgICAgICBpZiAoaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVyXHUyMDE0YSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlY29yYXRpb25zKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGggPyBEZWNvcmF0aW9uLm5vbmUgOiB0aGlzLnBsYWNlaG9sZGVyOyB9XG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gZS5hbHRLZXldLFxuICAgIENvbnRyb2w6IFsxNywgZSA9PiBlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+IGUubWV0YUtleV1cbn07XG5jb25zdCBzaG93Q3Jvc3NoYWlyID0geyBzdHlsZTogXCJjdXJzb3I6IGNyb3NzaGFpclwiIH07XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgdHVybnMgdGhlIHBvaW50ZXIgY3Vyc29yIGludG8gYVxuY3Jvc3NoYWlyIHdoZW4gYSBnaXZlbiBtb2RpZmllciBrZXksIGRlZmF1bHRpbmcgdG8gQWx0LCBpcyBoZWxkXG5kb3duLiBDYW4gc2VydmUgYXMgYSB2aXN1YWwgaGludCB0aGF0IHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBpc1xuZ29pbmcgdG8gaGFwcGVuIHdoZW4gcGFpcmVkIHdpdGhcbltgcmVjdGFuZ3VsYXJTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pLlxuKi9cbmZ1bmN0aW9uIGNyb3NzaGFpckN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQgW2NvZGUsIGdldHRlcl0gPSBrZXlzW29wdGlvbnMua2V5IHx8IFwiQWx0XCJdO1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNldChpc0Rvd24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG93biAhPSBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRG93biA9IGlzRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldykge1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcgPSBjcmVhdGVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0aGlzLnRvb2x0aXBzLm1hcChjcmVhdGVUb29sdGlwVmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRvb2x0aXBWaWV3cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cbiovXG5mdW5jdGlvbiB0b29sdGlwcyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB3aW5kb3dTcGFjZSh2aWV3KSB7XG4gICAgbGV0IHsgd2luIH0gPSB2aWV3O1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCB9O1xufVxuY29uc3QgdG9vbHRpcENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBicm93c2VyLmlvcyA/IFwiYWJzb2x1dGVcIiA6ICgoX2EgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucG9zaXRpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zaXRpb24pIHx8IFwiZml4ZWRcIixcbiAgICAgICAgICAgIHBhcmVudDogKChfYiA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wYXJlbnQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50KSB8fCBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcFNwYWNlOiAoKF9jID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnRvb2x0aXBTcGFjZSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b29sdGlwU3BhY2UpIHx8IHdpbmRvd1NwYWNlLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQpKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgdmlldy53aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uID0gdGhpcy5tZWFzdXJlU29vbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIGxldCBzaG91bGRNZWFzdXJlID0gdXBkYXRlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkO1xuICAgICAgICBsZXQgbmV3Q29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICBpZiAobmV3Q29uZmlnLnBvc2l0aW9uICE9IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wYXJlbnQgIT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbmV3Q29uZmlnLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodC5kb20pO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy52aWV3LnRoZW1lQ2xhc3NlcyAhPSB0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lYXN1cmUpXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sdGlwVmlldy5kb20pO1xuICAgICAgICBpZiAodG9vbHRpcFZpZXcubW91bnQpXG4gICAgICAgICAgICB0b29sdGlwVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gdG9vbHRpcFZpZXc7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgdG9vbHRpcFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9hID0gdG9vbHRpcFZpZXcuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodG9vbHRpcFZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lYXN1cmVUaW1lb3V0KTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLnZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogZWRpdG9yLFxuICAgICAgICAgICAgcG9zOiB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHYuZ2V0Q29vcmRzID8gdHYuZ2V0Q29vcmRzKHQucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICAgICAgc3BhY2U6IHRoaXMudmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKS50b29sdGlwU3BhY2UodGhpcy52aWV3KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGVkaXRvciwgc3BhY2UgfSA9IG1lYXN1cmVkO1xuICAgICAgICBsZXQgb3RoZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMubWFuYWdlci50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldLCB7IGRvbSB9ID0gdFZpZXc7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcbiAgICAgICAgICAgIC8vIEhpZGUgdG9vbHRpcHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgaWYgKCFwb3MgfHwgcG9zLmJvdHRvbSA8PSBNYXRoLm1heChlZGl0b3IudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbihlZGl0b3IuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgcG9zLnJpZ2h0IDwgTWF0aC5tYXgoZWRpdG9yLmxlZnQsIHNwYWNlLmxlZnQpIC0gLjEgfHxcbiAgICAgICAgICAgICAgICBwb3MubGVmdCA+IE1hdGgubWluKGVkaXRvci5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBBcnJvdy5TaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBzaXplLndpZHRoID4gc3BhY2UucmlnaHQgLSBzcGFjZS5sZWZ0ID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gISF0b29sdGlwLmFib3ZlO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgKyBvZmZzZXQueSA+IHNwYWNlLmJvdHRvbSkgJiZcbiAgICAgICAgICAgICAgICBhYm92ZSA9PSAoc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSA+IHBvcy50b3AgLSBzcGFjZS50b3ApKVxuICAgICAgICAgICAgICAgIGFib3ZlID0gIWFib3ZlO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGFib3ZlID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgOiBwb3MuYm90dG9tICsgYXJyb3dIZWlnaHQgKyBvZmZzZXQueTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygb3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBhYm92ZSA/IHIudG9wIC0gaGVpZ2h0IC0gMiAtIGFycm93SGVpZ2h0IDogci5ib3R0b20gKyBhcnJvd0hlaWdodCArIDI7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdylcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYCR7cG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gLSA3IC8qIEFycm93LlNpemUgKi8pfXB4YDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKG1lYXN1cmVkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZU1lYXN1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLnZpZXcuaW5WaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0di5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiAxMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0KSk7XG4gICAgfVxuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY3JlYXRlSG9zdGVkVmlldyh0b29sdGlwKSB7XG4gICAgICAgIGxldCBob3N0ZWRWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgaG9zdGVkVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtc2VjdGlvblwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaG9zdGVkVmlldy5kb20pO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuZmlsdGVyKHQgPT4gdCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLmZpbHRlcih0ID0+IHQuZW5kICE9IG51bGwpLm1hcCh0ID0+IHQuZW5kKSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IHsgbGFzdE1vdmUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhsYXN0TW92ZS50YXJnZXQpID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGxhc3RNb3ZlKSA6IG51bGw7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHRoaXMudmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zQ29vcmRzID09IG51bGwgfHwgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgIGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCAtIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggfHxcbiAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYmlkaSA9IHRoaXMudmlldy5iaWRpU3BhbnModGhpcy52aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSkuZmluZChzID0+IHMuZnJvbSA8PSBwb3MgJiYgcy50byA+PSBwb3MpO1xuICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHRoaXMudmlldywgcG9zLCAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCkpO1xuICAgICAgICBpZiAob3BlbiA9PT0gbnVsbCB8fCBvcGVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihyZXN1bHQpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJob3ZlciB0b29sdGlwXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG9wZW4pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHRhcmdldDogZXZlbnQudGFyZ2V0LCB0aW1lOiBEYXRlLm5vdygpIH07XG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSk7XG4gICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGlmICh0b29sdGlwICYmICFpc0luVG9vbHRpcCh0aGlzLmxhc3RNb3ZlLnRhcmdldCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IHRvb2x0aXAgfHwgdGhpcy5wZW5kaW5nLCBlbmQgPSAoX2EgPSB0b29sdGlwID09PSBudWxsIHx8IHRvb2x0aXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvb2x0aXAuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3M7XG4gICAgICAgICAgICBpZiAoKHBvcyA9PSBlbmQgPyB0aGlzLnZpZXcucG9zQXRDb29yZHModGhpcy5sYXN0TW92ZSkgIT0gcG9zXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgNiAvKiBIb3Zlci5NYXhEaXN0ICovKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiAhaXNJblRvb2x0aXAoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlKTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0luVG9vbHRpcChlbHQpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBlbHQ7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcFwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT3ZlclJhbmdlKHZpZXcsIGZyb20sIHRvLCB4LCB5LCBtYXJnaW4pIHtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGxldCBmcm9tRE9NID0gdmlldy5kb21BdFBvcyhmcm9tKSwgdG9ET00gPSB2aWV3LmRvbUF0UG9zKHRvKTtcbiAgICByYW5nZS5zZXRFbmQodG9ET00ubm9kZSwgdG9ET00ub2Zmc2V0KTtcbiAgICByYW5nZS5zZXRTdGFydChmcm9tRE9NLm5vZGUsIGZyb21ET00ub2Zmc2V0KTtcbiAgICBsZXQgcmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpO1xuICAgIHJhbmdlLmRldGFjaCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1heChyZWN0LnRvcCAtIHksIHkgLSByZWN0LmJvdHRvbSwgcmVjdC5sZWZ0IC0geCwgeCAtIHJlY3QucmlnaHQpO1xuICAgICAgICBpZiAoZGlzdCA8PSBtYXJnaW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXNcdTIwMTRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVPbiAmJiBvcHRpb25zLmhpZGVPbih0ciwgdmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuZW5kKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heWJlTWVhc3VyZSgpO1xufVxuXG5jb25zdCBwYW5lbENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBwYW5lbFBsdWdpblxufSk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBjbGFzczogXCJcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBlbGVtZW50U3R5bGU6IFwiXCIsXG4gICAgbWFya2VyczogKCkgPT4gUmFuZ2VTZXQuZW1wdHksXG4gICAgbGluZU1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9XG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyc1wiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBsaW5lIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgdGV4dCwgY2xhc3NTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8geyBsZWZ0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggfSA6IHsgcmlnaHQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMubG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGxpbmUodmlldywgbGluZSwgZXh0cmFNYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxvY2FsTWFya2VycyA9IFtdO1xuICAgICAgICBhZHZhbmNlQ3Vyc29yKHRoaXMuY3Vyc29yLCB0aGlzLmxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IGxvY2FsTWFya2VycyA9IGV4dHJhTWFya2Vycy5sZW5ndGggPyB0aGlzLmxvY2FsTWFya2Vycy5jb25jYXQoZXh0cmFNYXJrZXJzKSA6IHRoaXMubG9jYWxNYXJrZXJzO1xuICAgICAgICBsZXQgZm9yTGluZSA9IHRoaXMuZ3V0dGVyLmNvbmZpZy5saW5lTWFya2VyKHZpZXcsIGxpbmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIGlmIChmb3JMaW5lKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzLnVuc2hpZnQoZm9yTGluZSk7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgaWYgKGxvY2FsTWFya2Vycy5sZW5ndGggPT0gMCAmJiAhZ3V0dGVyLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYWJvdmUgPSBsaW5lLnRvcCAtIHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5pID09IGd1dHRlci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbHQgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHMucHVzaChuZXdFbHQpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5hcHBlbmRDaGlsZChuZXdFbHQuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50c1t0aGlzLmldLnVwZGF0ZSh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsaW5lLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pKys7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdEhlaWdodChldmVudC5jbGllbnRZIC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kb21FdmVudEhhbmRsZXJzW3Byb3BdKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkoY29uZmlnLm1hcmtlcnModmlldykpO1xuICAgICAgICBpZiAoY29uZmlnLmluaXRpYWxTcGFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgMCwgMCwgW2NvbmZpZy5pbml0aWFsU3BhY2VyKHZpZXcpXSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNwYWNlci5kb20pO1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIuZG9tLnN0eWxlLmNzc1RleHQgKz0gXCJ2aXNpYmlsaXR5OiBoaWRkZW47IHBvaW50ZXItZXZlbnRzOiBub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldk1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkodGhpcy5jb25maWcubWFya2Vycyh1cGRhdGUudmlldykpO1xuICAgICAgICBpZiAodGhpcy5zcGFjZXIgJiYgdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcih0aGlzLnNwYWNlci5tYXJrZXJzWzBdLCB1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWQgIT0gdGhpcy5zcGFjZXIubWFya2Vyc1swXSlcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlci51cGRhdGUodXBkYXRlLnZpZXcsIDAsIDAsIFt1cGRhdGVkXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZwID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgICAgIHJldHVybiAhUmFuZ2VTZXQuZXEodGhpcy5tYXJrZXJzLCBwcmV2TWFya2VycywgdnAuZnJvbSwgdnAudG8pIHx8XG4gICAgICAgICAgICAodGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSA/IHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UodXBkYXRlKSA6IGZhbHNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuZWxlbWVudHMpXG4gICAgICAgICAgICBlbHQuZGVzdHJveSgpO1xuICAgIH1cbn1cbmNsYXNzIEd1dHRlckVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IDA7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyRWxlbWVudFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCA9IGhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IHVwZGF0ZSA9PiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZyksXG4gICAgaW5pdGlhbFNwYWNlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xuICAgIH0sXG4gICAgdXBkYXRlU3BhY2VyKHNwYWNlciwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XG4gICAgICAgIHJldHVybiBtYXggPT0gc3BhY2VyLm51bWJlciA/IHNwYWNlciA6IG5ldyBOdW1iZXJNYXJrZXIobWF4KTtcbiAgICB9LFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnNcbn0pKTtcbi8qKlxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW5lTnVtYmVycyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbmVOdW1iZXJDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgZ3V0dGVycygpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XG4gICAgfVxufTtcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcbiAgICBsZXQgbWFya3MgPSBbXSwgbGFzdCA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlciwgbW92ZVZpc3VhbGx5IH07XG5cbmV4cG9ydCB7IEJpZGlTcGFuLCBCbG9ja0luZm8sIEJsb2NrVHlwZSwgRGVjb3JhdGlvbiwgRGlyZWN0aW9uLCBFZGl0b3JWaWV3LCBHdXR0ZXJNYXJrZXIsIE1hdGNoRGVjb3JhdG9yLCBWaWV3UGx1Z2luLCBWaWV3VXBkYXRlLCBXaWRnZXRUeXBlLCBfX3Rlc3QsIGNsb3NlSG92ZXJUb29sdGlwcywgY3Jvc3NoYWlyQ3Vyc29yLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBnZXRQYW5lbCwgZ2V0VG9vbHRpcCwgZ3V0dGVyLCBndXR0ZXJMaW5lQ2xhc3MsIGd1dHRlcnMsIGhhc0hvdmVyVG9vbHRpcHMsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgaG92ZXJUb29sdGlwLCBrZXltYXAsIGxpbmVOdW1iZXJNYXJrZXJzLCBsaW5lTnVtYmVycywgbG9nRXhjZXB0aW9uLCBwYW5lbHMsIHBsYWNlaG9sZGVyLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgcmVwb3NpdGlvblRvb2x0aXBzLCBydW5TY29wZUhhbmRsZXJzLCBzY3JvbGxQYXN0RW5kLCBzaG93UGFuZWwsIHNob3dUb29sdGlwLCB0b29sdGlwcyB9O1xuIiwgIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzIGluIG1peGVkLWxhbmd1YWdlIHBhcnNlcnMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBTa2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIEVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBBbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG4vLy8gb3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIC8vLyBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLy8vIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgLy8vIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIC8vLyB0cmVlKS5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8vLyBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICAvLy8gaW5zdGVhZC5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgLy8vIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIC8vLyBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKEl0ZXJNb2RlIHx8IChJdGVyTW9kZSA9IHt9KSk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgLy8vIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIC8vLyBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICAvLy8gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICAvLy8gW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgLy8vIHRyZWUuXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICAvLy8gW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICAvLy8gW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIC8vLyBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgLy8vIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgLy8vIHRoZSBob3N0IHRyZWVzKS5cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICAvLy8gbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKChzcGVjLm1vZGUgfHwgMCkgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAhYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgLy8vIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gY29uc3RydWN0b3IuXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICAvLy8gW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8vIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIC8vLyBvciBhIGN1cnNvciBvdmVyIHN1Y2ggYSBidWZmZXIuXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLy8vIFRoZSBlbXB0eSB0cmVlXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzKSAmJiAobW91bnRlZCA9IHRoaXMuX3RyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV0sIHRvID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20sIHRvKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7IHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpOyB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5idWZmZXIuc3RhcnQsIHNpZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIHBvcywgLTIgLyogQmVmb3JlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICAvLy8gY2hpbGQgbWF5IGVuZCBhdCB0aGF0IHBvc2l0aW9uLCB3aGVuIDEgaXQgbWF5IHN0YXJ0IHRoZXJlLiBUaGlzXG4gICAgLy8vIHdpbGwgYWxzbyBlbnRlciBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSlcbiAgICAvLy8gW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICAvLy8gc2V0IHRvIGZhbHNlLlxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IHRoaXMubW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKTtcbiAgICAgICAgcmV0dXJuIG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycyA/IGZhbHNlIDogdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5fdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXJfKE5MUikpXG4gICAgLy8vIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICAvLy8gY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICAvLy8gdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gICAgLy8vIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICAvLy8gcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgLy8vIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgICAvLy8gYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIC8vLyBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgLy8vIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dFx1MjAxNGEgc2VxdWVuY2VcbiAgICAvLy8gb2YgZGlyZWN0IHBhcmVudCBub2RlIG5hbWVzLiBFbXB0eSBzdHJpbmdzIGluIHRoZSBjb250ZXh0IGFycmF5XG4gICAgLy8vIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF1dXTtcbiAgICAgICAgICAgIGlmICghdHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogUmV1c2UgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBMb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG4vLy8gUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuLy8vIGFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcbi8vLyByZXRyaWV2ZWQgZnJvbSBhbiB1cGRhdGVkIHRyZWUuXG5jbGFzcyBOb2RlV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcbiAgICAgICAgaW5uZXIuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gaW5uZXIgJiYgaW5uZXIuZ2V0KGluZGV4KTtcbiAgICB9XG4gICAgLy8vIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUuXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUsIGlmIGl0IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgIGdldChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSA/IHRoaXMuZ2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgpXG4gICAgICAgICAgICA6IG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IHRoaXMubWFwLmdldChub2RlLnRyZWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgIGN1cnNvclNldChjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzXG4gICAgLy8vIHRvLlxuICAgIGN1cnNvckdldChjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5idWZmZXIgPyB0aGlzLmdldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4KSA6IHRoaXMubWFwLmdldChjdXJzb3IudHJlZSk7XG4gICAgfVxufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIC8vLyBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcbiAgICAvLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIGluc3RlYWQgb2ZcbiAgICAvLy8gY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBGdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBGdWxsICovIDogMSAvKiBQYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdLCB0byA9IGJ1Zi5idWZmZXJbZW5kSSAtIDJdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20sIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBvZmYpO1xuICAgIH1cbn1cbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBub2RlIHRoYXQncyBpbiBhIGJ1ZmZlciwgYW5kIGNvbnZlcnRzIGl0LCBhbmRcbi8vIGl0cyBwYXJlbnQgYnVmZmVyIG5vZGVzLCBpbnRvIGEgVHJlZS4gVGhpcyBpcyBhZ2FpbiBhY3Rpbmcgb24gdGhlXG4vLyBhc3N1bXB0aW9uIHRoYXQgdGhlIHRyZWVzIGFuZCBidWZmZXJzIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBieSB0aGVcbi8vIHBhcnNlIHRoYXQgd2FzIHJhbiB2aWEgdGhlIG1peCBwYXJzZXIsIGFuZCB0aHVzIGFyZW4ndCBzaGFyZWQgd2l0aFxuLy8gYW55IG90aGVyIGNvZGUsIG1ha2luZyB2aW9sYXRpb25zIG9mIHRoZSBpbW11dGFiaWxpdHkgc2FmZS5cbmZ1bmN0aW9uIG1hdGVyaWFsaXplKGN1cnNvcikge1xuICAgIGxldCB7IG5vZGUgfSA9IGN1cnNvciwgZGVwdGggPSAwO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICBkZXB0aCsrO1xuICAgIH0gd2hpbGUgKCFjdXJzb3IudHJlZSk7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGJ1ZmZlciBpbiB0aGF0IHRyZWVcbiAgICBsZXQgaSA9IDAsIGJhc2UgPSBjdXJzb3IudHJlZSwgb2ZmID0gMDtcbiAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICBvZmYgPSBiYXNlLnBvc2l0aW9uc1tpXSArIGN1cnNvci5mcm9tO1xuICAgICAgICBpZiAob2ZmIDw9IG5vZGUuZnJvbSAmJiBvZmYgKyBiYXNlLmNoaWxkcmVuW2ldLmxlbmd0aCA+PSBub2RlLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlcjtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgIHdoaWxlIChiW2kgKyAyXSArIG9mZiA8PSBub2RlLmZyb20pXG4gICAgICAgICAgICBpID0gYltpICsgM107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIGksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW2kgKyAxXSwgdG8gPSBiW2kgKyAyXTtcbiAgICAgICAgbGV0IGlzVGFyZ2V0ID0gZnJvbSArIG9mZiA9PSBub2RlLmZyb20gJiYgdG8gKyBvZmYgPT0gbm9kZS50byAmJiBiW2ldID09IG5vZGUudHlwZS5pZDtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChpc1RhcmdldCA/IG5vZGUudG9UcmVlKCkgOiBzcGxpdChpICsgNCwgYltpICsgM10sIGJ1Zi5zZXQudHlwZXNbYltpXV0sIGZyb20sIHRvIC0gZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbaSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDw9IGRlcHRoOyBkKyspXG4gICAgICAgIGN1cnNvci5jaGlsZEFmdGVyKG5vZGUuZnJvbSk7XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMgfCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmRQb3MgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgSXRlck1vZGUsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIE5vZGVXZWFrTWFwLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIiwgImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLy8vIEhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuLy8vIFRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxuLy8vIHRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuLy8vIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cbi8vL1xuLy8vIEJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG4vLy8gYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cbi8vLyBbdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xuLy8vIHRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3Jcbi8vLyBoaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxuLy8vIHZhcmlvdXMgbGFuZ3VhZ2VzKS5cbi8vL1xuLy8vIEl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuLy8vIGhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG4vLy8gdGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3Rcbi8vLyBiZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG4vLy8gZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuY2xhc3MgVGFnIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICAvLy8gdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICBzZXQsIFxuICAgIC8vLyBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgLy8vIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgIGJhc2UsIFxuICAgIC8vLyBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICAvLy8gRGVmaW5lIGEgbmV3IHRhZy4gSWYgYHBhcmVudGAgaXMgZ2l2ZW4sIHRoZSB0YWcgaXMgdHJlYXRlZCBhcyBhXG4gICAgLy8vIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIC8vLyBbaGlnaGxpZ2h0ZXJzXSgjaGlnaGxpZ2h0LnRhZ0hpZ2hsaWdodGVyKSB0aGF0IGRvbid0IG1lbnRpb25cbiAgICAvLy8gdGhpcyB0YWcgd2lsbCB0cnkgdG8gZmFsbCBiYWNrIHRvIHRoZSBwYXJlbnQgdGFnIChvciBncmFuZHBhcmVudFxuICAgIC8vLyB0YWcsIGV0YykuXG4gICAgc3RhdGljIGRlZmluZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcoW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvLy8gRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgLy8vIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICAvLy8gc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgIC8vLyA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICAvLy8gb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICAvLy8gc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgLy8vIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIC8vLyBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcigpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcjtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwb3dlclNldChtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50IG9mIGJhc2Uuc2V0KVxuICAgICAgICAgICAgaWYgKCFwYXJlbnQubW9kaWZpZWQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcG93ZXJTZXQoYXJyYXkpIHtcbiAgICBsZXQgc2V0cyA9IFtbXV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgZSA9IHNldHMubGVuZ3RoOyBqIDwgZTsgaisrKSB7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2V0c1tqXS5jb25jYXQoYXJyYXlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbn1cbi8vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRkIGEgc2V0IG9mIHRhZ3MgdG8gYSBsYW5ndWFnZSBzeW50YXhcbi8vLyB2aWEgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4vLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cbi8vL1xuLy8vIFRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXG4vLy8gdGFnc10oI2hpZ2hsaWdodC5UYWcpIG9yIGFycmF5cyBvZiB0YWdzLlxuLy8vXG4vLy8gTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cbi8vLyBTdWNoIGEgcGF0aCBjYW4gYmUgYSBbbm9kZSBuYW1lXSgjY29tbW9uLk5vZGVUeXBlLm5hbWUpLCBvclxuLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgKG9yIGAqYCB3aWxkY2FyZHMpIHNlcGFyYXRlZCBieSBzbGFzaFxuLy8vIGNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbi8vLyBtYXRjaGVzIHRoZSBmaW5hbCBub2RlIGJ1dCBvbmx5IGlmIGl0cyBkaXJlY3QgcGFyZW50IG5vZGVzIGFyZSB0aGVcbi8vLyBvdGhlciBub2RlcyBtZW50aW9uZWQuIEEgYCpgIGluIHN1Y2ggYSBwYXRoIG1hdGNoZXMgYW55IHBhcmVudCxcbi8vLyBidXQgb25seSBhIHNpbmdsZSBsZXZlbFx1MjAxNHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbi8vLyBhcmVuJ3Qgc3VwcG9ydGVkLCBib3RoIGZvciBlZmZpY2llbmN5IHJlYXNvbnMgYW5kIGJlY2F1c2UgTGV6ZXJcbi8vLyB0cmVlcyBtYWtlIGl0IHJhdGhlciBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGF0IHRoZXkgd291bGQgbWF0Y2guKVxuLy8vXG4vLy8gQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbi8vLyB0byB0aGUgbm9kZSBzaG91bGQgYWxzbyBhcHBseSB0byBhbGwgY2hpbGQgbm9kZXMsIGV2ZW4gaWYgdGhleVxuLy8vIG1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXG4vLy8gdXNlZCkuXG4vLy9cbi8vLyBXaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXG4vLy8gaGFwcGVucyBmb3IgdGhlIG5vZGUncyBjaGlsZCBub2RlcywgYW5kIHRoZSBlbnRpcmUgbm9kZSBnZXRzIHRoZVxuLy8vIGdpdmVuIHN0eWxlLlxuLy8vXG4vLy8gSW4gdGhpcyBub3RhdGlvbiwgbm9kZSBuYW1lcyB0aGF0IGNvbnRhaW4gYC9gLCBgIWAsIGAqYCwgb3IgYC4uLmBcbi8vLyBtdXN0IGJlIHF1b3RlZCBhcyBKU09OIHN0cmluZ3MuXG4vLy9cbi8vLyBGb3IgZXhhbXBsZTpcbi8vL1xuLy8vIGBgYGphdmFzY3JpcHRcbi8vLyBwYXJzZXIud2l0aFByb3BzKFxuLy8vICAgc3R5bGVUYWdzKHtcbi8vLyAgICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcbi8vLyAgICAgXCJOdW1iZXIgQmlnTnVtYmVyXCI6IHRhZ3MubnVtYmVyLFxuLy8vICAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuLy8vICAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXG4vLy8gICAgIC8vIFN0eWxlIGFueXRoaW5nIGluc2lkZSBBdHRyaWJ1dGVzIG5vZGVzXG4vLy8gICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuLy8vICAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXG4vLy8gICAgIFwiSXRhbGljLy4uLlwiOiB0YWdzLmVtcGhhc2lzLFxuLy8vICAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuLy8vICAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxuLy8vICAgICAvLyBTdHlsZSB0aGUgbm9kZSBuYW1lZCBcIi9cIiBhcyBwdW5jdHVhdGlvblxuLy8vICAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4vLy8gICB9KVxuLy8vIClcbi8vLyBgYGBcbmZ1bmN0aW9uIHN0eWxlVGFncyhzcGVjKSB7XG4gICAgbGV0IGJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB0YWdzID0gc3BlY1twcm9wXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlcyA9IFtdLCBtb2RlID0gMiAvKiBOb3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE9wYXF1ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBwYXJ0LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gcGllY2VzLmxlbmd0aCAtIDEsIGlubmVyID0gcGllY2VzW2xhc3RdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gbmV3IFJ1bGUodGFncywgbW9kZSwgbGFzdCA+IDAgPyBwaWVjZXMuc2xpY2UoMCwgbGFzdCkgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBieU5hbWVbaW5uZXJdID0gcnVsZS5zb3J0KGJ5TmFtZVtpbm5lcl0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZU5vZGVQcm9wLmFkZChieU5hbWUpO1xufVxuY29uc3QgcnVsZU5vZGVQcm9wID0gbmV3IE5vZGVQcm9wKCk7XG5jbGFzcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzLCBtb2RlLCBjb250ZXh0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIGdldCBvcGFxdWUoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMCAvKiBPcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIEluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBOb3JtYWwgKi8sIG51bGwpO1xuLy8vIERlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxuLy8vIHRhZy9jbGFzcyBwYWlycy4gQ2xhc3NlcyBhc3NvY2lhdGVkIHdpdGggbW9yZSBzcGVjaWZpYyB0YWdzIHdpbGxcbi8vLyB0YWtlIHByZWNlZGVuY2UuXG5mdW5jdGlvbiB0YWdIaWdobGlnaHRlcih0YWdzLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgc3R5bGUgb2YgdGFncykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUudGFnKSlcbiAgICAgICAgICAgIG1hcFtzdHlsZS50YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBzdHlsZS50YWcpXG4gICAgICAgICAgICAgICAgbWFwW3RhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICB9XG4gICAgbGV0IHsgc2NvcGUsIGFsbCA9IG51bGwgfSA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6ICh0YWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2xzID0gYWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2YgdGFnLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFnQ2xhc3MgPSBtYXBbc3ViLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSBjbHMgPyBjbHMgKyBcIiBcIiArIHRhZ0NsYXNzIDogdGFnQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCB0YWdzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIHZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLy8gSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuLy8vIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8vLyBBc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXG4vLy8gb2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG4vLy8gYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbnB1dFN0eWxlLCBcbi8vLyBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvIGhpZ2hsaWdodC5cbmZyb20gPSAwLCBcbi8vLyBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbnRvID0gdHJlZS5sZW5ndGgpIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBIaWdobGlnaHRCdWlsZGVyKGZyb20sIEFycmF5LmlzQXJyYXkoaGlnaGxpZ2h0ZXIpID8gaGlnaGxpZ2h0ZXIgOiBbaGlnaGxpZ2h0ZXJdLCBwdXRTdHlsZSk7XG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xuICAgIGJ1aWxkZXIuZmx1c2godG8pO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIEluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihjdXJzb3IuZnJvbSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIGluaGVyaXRlZENsYXNzLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKHBvcywgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vLyBNYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxuLy8vIHRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbi8vLyBvcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLy8vIFRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cbi8vL1xuLy8vIFRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbi8vLyBhbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuLy8vIGNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbi8vLyB3cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuLy8vIGZhaWxzLCBbb3BlbiBhblxuLy8vIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxuLy8vIG5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxuLy8vIHlvdXIgdXNlIGNhc2UuXG4vLy9cbi8vLyBOb3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xuLy8vIHRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW50XHUyMDE0aWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuLy8vIGRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG4vLy8gaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuLy8vIFxuLy8vIEZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbi8vLyB0aGUgcGFyZW50LlxuY29uc3QgdGFncyA9IHtcbiAgICAvLy8gQSBjb21tZW50LlxuICAgIGNvbW1lbnQsXG4gICAgLy8vIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgIG5hbWUsXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLy8vIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLy8vIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvLy8gQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICBsaXRlcmFsLFxuICAgIC8vLyBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIHN0cmluZyxcbiAgICAvLy8gQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8vLyBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8vLyBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBudW1iZXIsXG4gICAgLy8vIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLy8vIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8vLyBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLy8vIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgLy8vIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAga2V5d29yZCxcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICAvLy8gb2JqZWN0LlxuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIC8vLyBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3IsXG4gICAgLy8vIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvLy8gW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgLy8vIHRoaW5ncy5cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8vLyBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICBicmFja2V0LFxuICAgIC8vLyBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIC8vLyB0b2tlbnMpLlxuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgLy8vIHRva2VucykuXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgLy8vIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLy8vIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvLy8gQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICBjb250ZW50LFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgaGVhZGluZyxcbiAgICAvLy8gQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgLy8vIG1vbm9zcGFjZS5cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIC8vLyBzdHlsZS5cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8vLyBEZWxldGVkIHRleHQuXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8vLyBDaGFuZ2VkIHRleHQuXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8vLyBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8vLyBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgIG1ldGEsXG4gICAgLy8vIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgLy8vIGRvY3VtZW50LlxuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIC8vLyBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIC8vLyBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICAvLy8gdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICAvLy8gc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICAvLy8gYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIC8vLyBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIC8vLyBhcyBhIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgLy8vIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIC8vLyBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICAvLy8gc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgLy8vIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgLy8vIGNvbWUgdXAgYSBsb3QuXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKClcbn07XG4vLy8gVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbi8vLyB0b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuLy8vXG4vLy8gVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbi8vLyAoZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuLy8vXG4vLy8gKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbi8vLyAqIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuLy8vICogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbi8vLyAqIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbi8vLyAqIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuLy8vICogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4vLy8gKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbi8vLyAqIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbi8vLyAqIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbi8vLyAqIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4vLy8gKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbi8vLyAqIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuLy8vICogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuLy8vICogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuLy8vICogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbi8vLyAqIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbi8vLyAqIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbi8vLyAqIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbi8vLyAqIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbi8vLyAqIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4vLy8gKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbi8vLyAqIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuLy8vICogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbi8vLyAqIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuLy8vXG4vLy8gSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcbi8vL1xuLy8vICogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbi8vLyAgIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuLy8vICAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4vLy8gICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4vLy8gKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAgIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4vLy8gKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbi8vLyAqIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuLy8vICogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4vLy8gICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XG4iLCAiaW1wb3J0IHsgTm9kZVByb3AsIEl0ZXJNb2RlLCBUcmVlLCBUcmVlRnJhZ21lbnQsIFBhcnNlciwgTm9kZVR5cGUsIE5vZGVTZXQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgRWRpdG9yU3RhdGUsIGNvdW50Q29sdW1uLCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBFZGl0b3JWaWV3LCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBndXR0ZXIsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiBzdGF0ZS5mYWNldChsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpKSlcbiAgICAgICAgXS5jb25jYXQoZXh0cmFFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGlzIGxhbmd1YWdlIGlzIGFjdGl2ZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpc0FjdGl2ZUF0KHN0YXRlLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zLCBzaWRlKSA9PSB0aGlzLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHJlZ2lvbnMgdGhhdCB3ZXJlIHBhcnNlZCB1c2luZyB0aGlzIGxhbmd1YWdlLlxuICAgIFRoZSByZXR1cm5lZCByZWdpb25zIHdpbGwgX2luY2x1ZGVfIGFueSBuZXN0ZWQgbGFuZ3VhZ2VzIHJvb3RlZFxuICAgIGluIHRoaXMgbGFuZ3VhZ2UsIHdoZW4gdGhvc2UgZXhpc3QuXG4gICAgKi9cbiAgICBmaW5kUmVnaW9ucyhzdGF0ZSkge1xuICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKChsYW5nID09PSBudWxsIHx8IGxhbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhbmcuZGF0YSkgPT0gdGhpcy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IDAsIHRvOiBzdGF0ZS5kb2MubGVuZ3RoIH1dO1xuICAgICAgICBpZiAoIWxhbmcgfHwgIWxhbmcuYWxsb3dzTmVzdGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9ICh0cmVlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW91bnQgPSB0cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICBpZiAobW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQudHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IHIuZnJvbSArIGZyb20sIHRvOiByLnRvICsgZnJvbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IHNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKGNoLCB0cmVlLnBvc2l0aW9uc1tpXSArIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBleHBsb3JlKHN5bnRheFRyZWUoc3RhdGUpLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBhbGxvd3MgbmVzdGVkIGxhbmd1YWdlcy4gVGhlXG4gICAgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRydWUuXG4gICAgKi9cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuTGFuZ3VhZ2Uuc2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5mdW5jdGlvbiBsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICBpZiAoIXRvcExhbmcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmYWNldCA9IHRvcExhbmcuZGF0YTtcbiAgICBpZiAodG9wTGFuZy5hbGxvd3NOZXN0aW5nKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlOyBub2RlOyBub2RlID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSlcbiAgICAgICAgICAgIGZhY2V0ID0gbm9kZS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgfHwgZmFjZXQ7XG4gICAgfVxuICAgIHJldHVybiBmYWNldDtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XG59XG4vKipcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcbm1ldGhvZCB3aWxsIGRvIGF0IG1vc3QgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3b3JrIHRvIHBhcnNlXG51cCB0byB0aGF0IHBvaW50IGlmIHRoZSB0cmVlIGlzbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGVuc3VyZVN5bnRheFRyZWUoc3RhdGUsIHVwdG8sIHRpbWVvdXQgPSA1MCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcbiAgICByZXR1cm4gIXBhcnNlID8gbnVsbCA6IHBhcnNlLmlzRG9uZSh1cHRvKSB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF0XHUyMDE0dGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLy8gTGV6ZXItc3R5bGUgSW5wdXQgb2JqZWN0IGZvciBhIFRleHQgZG9jdW1lbnQuXG5jbGFzcyBEb2NJbnB1dCB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBsZW5ndGggPSBkb2MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICB9XG4gICAgc3luY1RvKHBvcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQocG9zIC0gdGhpcy5jdXJzb3JQb3MpLnZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBjaHVuayhwb3MpIHtcbiAgICAgICAgdGhpcy5zeW5jVG8ocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbSA8IHN0cmluZ1N0YXJ0IHx8IHRvID49IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20gLSBzdHJpbmdTdGFydCwgdG8gLSBzdHJpbmdTdGFydCk7XG4gICAgfVxufVxubGV0IGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbi8qKlxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4qL1xuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxuICAgICovXG4gICAgZnJhZ21lbnRzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlTGVuLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cbiAgICB0aGVyZW9mKS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBmb3Igb3Bwb3J0dW5pc3RpY2FsbHkgYXZvaWRpbmdcbiAgICB3b3JrIChpbiB3aGljaCBjYXNlXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXG4gICAgc2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN1cmUgdGhlIHBhcnNlciBpcyByZXN0YXJ0ZWQgd2hlbiB0aGVcbiAgICBza2lwcGVkIHJlZ2lvbiBiZWNvbWVzIHZpc2libGUpLlxuICAgICovXG4gICAgdmlld3BvcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2tpcHBlZCwgXG4gICAgLyoqXG4gICAgVGhpcyBpcyB3aGVyZSBza2lwcGluZyBwYXJzZXJzIGNhbiByZWdpc3RlciBhIHByb21pc2UgdGhhdCxcbiAgICB3aGVuIHJlc29sdmVkLCB3aWxsIHNjaGVkdWxlIGEgbmV3IHBhcnNlLiBJdCBpcyBjbGVhcmVkIHdoZW5cbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjaGVkdWxlT24pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMudHJlZUxlbiA9IHRyZWVMZW47XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU9uID0gc2NoZWR1bGVPbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyc2VyLCBzdGF0ZSwgdmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQocGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXJ0UGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3b3JrKHVudGlsLCB1cHRvKSB7XG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB1cHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IFRyZWUuZW1wdHkgJiYgdGhpcy5pc0RvbmUodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bnRpbCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgdW50aWw7XG4gICAgICAgICAgICAgICAgdW50aWwgPSAoKSA9PiBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICBpZiAodXB0byAhPSBudWxsICYmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gdXB0bykgJiZcbiAgICAgICAgICAgICAgICB1cHRvIDwgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHVwdG8pO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZShkb25lLCB0aGlzLmZyYWdtZW50cywgdGhpcy5wYXJzZS5zdG9wcGVkQXQgIT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSAoX2EgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUxlbiA8ICh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVudGlsKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdGFrZVRyZWUoKSB7XG4gICAgICAgIGxldCBwb3MsIHRyZWU7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICAgICAgdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7IHdoaWxlICghKHRyZWUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSkpIHsgfSB9KTtcbiAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IHBvcztcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb250ZXh0KGYpIHtcbiAgICAgICAgbGV0IHByZXYgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgdHJlZSA9IFRyZWUuZW1wdHk7XG4gICAgICAgICAgICB0cmVlTGVuID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyBmcm9tOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSkgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Moci5mcm9tLCAxKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyhyLnRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQodGhpcy5wYXJzZXIsIG5ld1N0YXRlLCBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkLCB0aGlzLnNjaGVkdWxlT24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVwZGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gdmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IHZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBzdGFydExlbiA9IHRoaXMuc2tpcHBlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5za2lwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5za2lwcGVkW2ldO1xuICAgICAgICAgICAgaWYgKGZyb20gPCB2aWV3cG9ydC50byAmJiB0byA+IHZpZXdwb3J0LmZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyh0aGlzLmZyYWdtZW50cywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcHBlZC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCA+PSBzdGFydExlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE5vdGlmeSB0aGUgcGFyc2Ugc2NoZWR1bGVyIHRoYXQgdGhlIGdpdmVuIHJlZ2lvbiB3YXMgc2tpcHBlZFxuICAgIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxuICAgICovXG4gICAgc2tpcFVudGlsSW5WaWV3KGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXG4gICAgYXN5bmNocm9ub3VzbHkgbG9hZGluZyBhIG5lc3RlZCBwYXJzZXIuIEl0J2xsIHNraXAgaXRzIGlucHV0IGFuZFxuICAgIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgICBpdCBhZ2Fpbi5cbiAgICBcbiAgICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgICBwcm9taXNlIHJlc29sdmVzLlxuICAgICovXG4gICAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKHVudGlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZEF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQoKSB7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNEb25lKHVwdG8pIHtcbiAgICAgICAgdXB0byA9IE1hdGgubWluKHVwdG8sIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBmcmFncyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlTGVuID49IHVwdG8gJiYgZnJhZ3MubGVuZ3RoICYmIGZyYWdzWzBdLmZyb20gPT0gMCAmJiBmcmFnc1swXS50byA+PSB1cHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KCkgeyByZXR1cm4gY3VycmVudENvbnRleHQ7IH1cbn1cbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSB0ci5zdGFydFN0YXRlLmRvYy5sZW5ndGggPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogTWF0aC5tYXgodHIuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuZXdDeC52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2cFRvID0gTWF0aC5taW4oMzAwMCAvKiBXb3JrLkluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdnBUbykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpLCA1MDAgLyogV29yay5NYXhQYXVzZSAqLyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn07XG5pZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgaWRsZSA9IC0xLCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjaywgeyB0aW1lb3V0OiA1MDAgLyogV29yay5NYXhQYXVzZSAqLyAtIDEwMCAvKiBXb3JrLk1pblBhdXNlICovIH0pO1xuICAgICAgICB9LCAxMDAgLyogV29yay5NaW5QYXVzZSAqLyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpZGxlIDwgMCA/IGNsZWFyVGltZW91dCh0aW1lb3V0KSA6IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlKTtcbiAgICB9O1xuY29uc3QgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgKChfYSA9IG5hdmlnYXRvci5zY2hlZHVsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNJbnB1dFBlbmRpbmcpXG4gICAgPyAoKSA9PiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZygpIDogbnVsbDtcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCA9IDA7XG4gICAgICAgIC8vIEVuZCBvZiB0aGUgY3VycmVudCB0aW1lIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcbiAgICAgICAgLy8gTWlsbGlzZWNvbmRzIG9mIGJ1ZGdldCBsZWZ0IGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAtMTtcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKS5jb250ZXh0O1xuICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IGN4LnRyZWVMZW4pXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaGFzRm9jdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCArPSA1MCAvKiBXb3JrLkNoYW5nZUJvbnVzICovO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShjeCk7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlICE9IGZpZWxkLmNvbnRleHQudHJlZSB8fCAhZmllbGQuY29udGV4dC5pc0RvbmUoc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcgPSByZXF1ZXN0SWRsZSh0aGlzLndvcmspO1xuICAgIH1cbiAgICB3b3JrKGRlYWRsaW5lKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGhpcy5jaHVua0VuZCA9IG5vdyArIDMwMDAwIC8qIFdvcmsuQ2h1bmtUaW1lICovO1xuICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IDMwMDAgLyogV29yay5DaHVua0J1ZGdldCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBObyBtb3JlIGJ1ZGdldFxuICAgICAgICBsZXQgeyBzdGF0ZSwgdmlld3BvcnQ6IHsgdG86IHZwVG8gfSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgPT0gZmllbGQuY29udGV4dC50cmVlICYmIGZpZWxkLmNvbnRleHQuaXNEb25lKHZwVG8gKyAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgTWF0aC5taW4odGhpcy5jaHVua0J1ZGdldCwgMTAwIC8qIFdvcmsuU2xpY2UgKi8sIGRlYWRsaW5lICYmICFpc0lucHV0UGVuZGluZyA/IE1hdGgubWF4KDI1IC8qIFdvcmsuTWluU2xpY2UgKi8sIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSAtIDUpIDogMWU5KTtcbiAgICAgICAgbGV0IHZpZXdwb3J0Rmlyc3QgPSBmaWVsZC5jb250ZXh0LnRyZWVMZW4gPCB2cFRvICYmIHN0YXRlLmRvYy5sZW5ndGggPiB2cFRvICsgMTAwMDtcbiAgICAgICAgbGV0IGRvbmUgPSBmaWVsZC5jb250ZXh0LndvcmsoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzSW5wdXRQZW5kaW5nICYmIGlzSW5wdXRQZW5kaW5nKCkgfHwgRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgIH0sIHZwVG8gKyAodmlld3BvcnRGaXJzdCA/IDAgOiAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPiAwICYmICEoZG9uZSAmJiAhdmlld3BvcnRGaXJzdCkpXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShmaWVsZC5jb250ZXh0KTtcbiAgICB9XG4gICAgY2hlY2tBc3luY1NjaGVkdWxlKGN4KSB7XG4gICAgICAgIGlmIChjeC5zY2hlZHVsZU9uKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQrKztcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT25cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlV29yaygpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLndvcmtTY2hlZHVsZWQtLSk7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nKCk7XG4gICAgfVxuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMud29ya2luZyB8fCB0aGlzLndvcmtTY2hlZHVsZWQgPiAwKTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHsgdGhpcy5zY2hlZHVsZVdvcmsoKTsgfSB9XG59KTtcbi8qKlxuVGhlIGZhY2V0IHVzZWQgdG8gYXNzb2NpYXRlIGEgbGFuZ3VhZ2Ugd2l0aCBhbiBlZGl0b3Igc3RhdGUuIFVzZWRcbmJ5IGBMYW5ndWFnZWAgb2JqZWN0J3MgYGV4dGVuc2lvbmAgcHJvcGVydHkgKHNvIHlvdSBkb24ndCBuZWVkIHRvXG5tYW51YWxseSB3cmFwIHlvdXIgbGFuZ3VhZ2VzIGluIHRoaXMpLiBDYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlXG5jdXJyZW50IGxhbmd1YWdlIG9uIGEgc3RhdGUuXG4qL1xuY29uc3QgbGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGxhbmd1YWdlcykgeyByZXR1cm4gbGFuZ3VhZ2VzLmxlbmd0aCA/IGxhbmd1YWdlc1swXSA6IG51bGw7IH0sXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xuICAgICAgICBMYW5ndWFnZS5zdGF0ZSxcbiAgICAgICAgcGFyc2VXb3JrZXIsXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuY29tcHV0ZShbbGFuZ3VhZ2VdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nICYmIGxhbmcubmFtZSA/IHsgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcubmFtZSB9IDoge307XG4gICAgICAgIH0pXG4gICAgXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgd2l0aCBhblxub3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gTGFuZ3VhZ2UgcGFja2FnZXMgYXJlXG5lbmNvdXJhZ2VkIHRvIGV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgb3B0aW9uYWxseSB0YWtlcyBhXG5jb25maWd1cmF0aW9uIG9iamVjdCBhbmQgcmV0dXJucyBhIGBMYW5ndWFnZVN1cHBvcnRgIGluc3RhbmNlLCBhc1xudGhlIG1haW4gd2F5IGZvciBjbGllbnQgY29kZSB0byB1c2UgdGhlIHBhY2thZ2UuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VTdXBwb3J0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsYW5ndWFnZSBvYmplY3QuXG4gICAgKi9cbiAgICBsYW5ndWFnZSwgXG4gICAgLyoqXG4gICAgQW4gb3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gV2hlbiBuZXN0aW5nIGFcbiAgICBsYW5ndWFnZSBpbiBhbm90aGVyIGxhbmd1YWdlLCB0aGUgb3V0ZXIgbGFuZ3VhZ2UgaXMgZW5jb3VyYWdlZFxuICAgIHRvIGluY2x1ZGUgdGhlIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucyBmb3IgaXRzIGlubmVyIGxhbmd1YWdlc1xuICAgIGluIGl0cyBvd24gc2V0IG9mIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSBbXSkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW2xhbmd1YWdlLCBzdXBwb3J0XTtcbiAgICB9XG59XG4vKipcbkxhbmd1YWdlIGRlc2NyaXB0aW9ucyBhcmUgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBhYm91dCBsYW5ndWFnZXNcbmFuZCB0byBkeW5hbWljYWxseSBsb2FkIHRoZW0uIFRoZWlyIG1haW4gcm9sZSBpcyBmaW5kaW5nIHRoZVxuYXBwcm9wcmlhdGUgbGFuZ3VhZ2UgZm9yIGEgZmlsZW5hbWUgb3IgZHluYW1pY2FsbHkgbG9hZGluZyBuZXN0ZWRcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEFsdGVybmF0aXZlIG5hbWVzIGZvciB0aGUgbW9kZSAobG93ZXJjYXNlZCwgaW5jbHVkZXMgYHRoaXMubmFtZWApLlxuICAgICovXG4gICAgYWxpYXMsIFxuICAgIC8qKlxuICAgIEZpbGUgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGV4dGVuc2lvbnMsIFxuICAgIC8qKlxuICAgIE9wdGlvbmFsIGZpbGVuYW1lIHBhdHRlcm4gdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGZpbGVuYW1lLCBsb2FkRnVuYywgXG4gICAgLyoqXG4gICAgSWYgdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGxvYWRlZCwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxuICAgICovXG4gICAgc3VwcG9ydCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5sb2FkRnVuYyA9IGxvYWRGdW5jO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIGxldCB7IGxvYWQsIHN1cHBvcnQgfSA9IHNwZWM7XG4gICAgICAgIGlmICghbG9hZCkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVzdCBwYXNzIGVpdGhlciAnbG9hZCcgb3IgJ3N1cHBvcnQnIHRvIExhbmd1YWdlRGVzY3JpcHRpb24ub2ZcIik7XG4gICAgICAgICAgICBsb2FkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIGxvYWQsIHN1cHBvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIGluIHRoZSBnaXZlbiBhcnJheSBvZiBkZXNjcmlwdGlvbnMgdGhhdFxuICAgIG1hdGNoZXMgdGhlIGZpbGVuYW1lLiBXaWxsIGZpcnN0IG1hdGNoXG4gICAgW2BmaWxlbmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5maWxlbmFtZSkgcGF0dGVybnMsXG4gICAgYW5kIHRoZW4gW2V4dGVuc2lvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSxcbiAgICBhbmQgcmV0dXJuIHRoZSBmaXJzdCBsYW5ndWFnZSB0aGF0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hGaWxlbmFtZShkZXNjcywgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmZpbGVuYW1lICYmIGQuZmlsZW5hbWUudGVzdChmaWxlbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGxldCBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBpZiAoZC5leHRlbnNpb25zLmluZGV4T2YoZXh0WzFdKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZSBvciBhbGlhcyBtYXRjaGVzIHRoZSB0aGUgZ2l2ZW5cbiAgICBuYW1lIChjYXNlLWluc2Vuc2l0aXZlbHkpLiBJZiBgZnV6enlgIGlzIHRydWUsIGFuZCBubyBkaXJlY3RcbiAgICBtYXRjaHMgaXMgZm91bmQsIHRoaXMnbGwgYWxzbyBzZWFyY2ggZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZVxuICAgIG9yIGFsaWFzIG9jY3VycyBpbiB0aGUgc3RyaW5nIChmb3IgbmFtZXMgc2hvcnRlciB0aGFuIHRocmVlXG4gICAgY2hhcmFjdGVycywgb25seSB3aGVuIHN1cnJvdW5kZWQgYnkgbm9uLXdvcmQgY2hhcmFjdGVycykuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hMYW5ndWFnZU5hbWUoZGVzY3MsIG5hbWUsIGZ1enp5ID0gdHJ1ZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuYWxpYXMuc29tZShhID0+IGEgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGlmIChmdXp6eSlcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSBvZiBkLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IG5hbWUuaW5kZXhPZihhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgKGEubGVuZ3RoID4gMiB8fCAhL1xcdy8udGVzdChuYW1lW2ZvdW5kIC0gMV0pICYmICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgKyBhLmxlbmd0aF0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbkZhY2V0IHRoYXQgZGVmaW5lcyBhIHdheSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGVcbmFwcHJvcHJpYXRlIGluZGVudGF0aW9uIGRlcHRoLCBhcyBhIGNvbHVtbiBudW1iZXIgKHNlZVxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpLCBhdCB0aGUgc3RhcnQgb2YgYSBnaXZlblxubGluZS4gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIGluZGljYXRlcyBubyBpbmRlbnRhdGlvbiBjYW4gYmVcbmRldGVybWluZWQsIGFuZCB0aGUgbGluZSBzaG91bGQgaW5oZXJpdCB0aGUgaW5kZW50YXRpb24gb2YgdGhlIG9uZVxuYWJvdmUgaXQuIEEgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGRlZmVycyB0byB0aGUgbmV4dCBpbmRlbnRcbnNlcnZpY2UuXG4qL1xuY29uc3QgaW5kZW50U2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgZm9yIG92ZXJyaWRpbmcgdGhlIHVuaXQgYnkgd2hpY2ggaW5kZW50YXRpb24gaGFwcGVucy5cblNob3VsZCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiBzcGFjZXMgb3JcbmVudGlyZWx5IG9mIHRhYnMuIFdoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgaWYgKCEvXig/OiArfFxcdCspJC8udGVzdCh2YWx1ZXNbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemU7XG4gICAgaWYgKHN0YXRlLmZhY2V0KGluZGVudFVuaXQpLmNoYXJDb2RlQXQoMCkgPT0gOSlcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgaSsrKVxuICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuR2V0IHRoZSBpbmRlbnRhdGlvbiwgYXMgYSBjb2x1bW4gbnVtYmVyLCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5XaWxsIGZpcnN0IGNvbnN1bHQgYW55IFtpbmRlbnQgc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSlcbnRoYXQgYXJlIHJlZ2lzdGVyZWQsIGFuZCBpZiBub25lIG9mIHRob3NlIHJldHVybiBhbiBpbmRlbnRhdGlvbixcbnRoaXMgd2lsbCBjaGVjayB0aGUgc3ludGF4IHRyZWUgZm9yIHRoZSBbaW5kZW50IG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3ApIGFuZCB1c2UgdGhhdCBpZiBmb3VuZC4gUmV0dXJucyBhXG5udW1iZXIgd2hlbiBhbiBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLCBhbmQgbnVsbFxub3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKGNvbnRleHQsIHBvcykge1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWRpdG9yU3RhdGUpXG4gICAgICAgIGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIGNvbnRleHQuc3RhdGUuZmFjZXQoaW5kZW50U2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2UoY29udGV4dCwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpO1xuICAgIHJldHVybiB0cmVlID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgcmV0dXJuIGluZGVudEZyb20oYXN0LnJlc29sdmVJbm5lcihwb3MpLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyksIHBvcywgY3gpO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW5kZW50RnJvbShub2RlLCBwb3MsIGJhc2UpIHtcbiAgICBmb3IgKDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxldCBzdHJhdGVneSA9IGluZGVudFN0cmF0ZWd5KG5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgc3ludGF4IHRyZWUgbm9kZSB0byB3aGljaCB0aGUgaW5kZW50YXRpb24gc3RyYXRlZ3lcbiAgICBhcHBsaWVzLlxuICAgICovXG4gICAgbm9kZSkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLm5vZGUuZnJvbSk7XG4gICAgICAgIC8vIFNraXAgbGluZSBzdGFydHMgdGhhdCBhcmUgY292ZXJlZCBieSBhIHNpYmxpbmcgKG9yIGNvdXNpbiwgZXRjKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRCcmVhayA9IHRoaXMubm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIHRoaXMubm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBwYXJlbnQgPyBpbmRlbnRGcm9tKHBhcmVudCwgdGhpcy5wb3MsIHRoaXMuYmFzZSkgOiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudCwgb2YpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAocGFyZW50ID09IGN1cilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIENoZWNrIHdoZXRoZXIgYSBkZWxpbWl0ZWQgbm9kZSBpcyBhbGlnbmVkIChtZWFuaW5nIHRoZXJlIGFyZVxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcbi8vIGlmIHNvLCByZXR1cm4gdGhlIG9wZW5pbmcgdG9rZW4uXG5mdW5jdGlvbiBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIHtcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcbiAgICBsZXQgb3BlblRva2VuID0gdHJlZS5jaGlsZEFmdGVyKHRyZWUuZnJvbSksIGxhc3QgPSB0cmVlLmxhc3RDaGlsZDtcbiAgICBpZiAoIW9wZW5Ub2tlbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNpbSA9IGNvbnRleHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrO1xuICAgIGxldCBvcGVuTGluZSA9IGNvbnRleHQuc3RhdGUuZG9jLmxpbmVBdChvcGVuVG9rZW4uZnJvbSk7XG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XG4gICAgZm9yIChsZXQgcG9zID0gb3BlblRva2VuLnRvOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSB0cmVlLmNoaWxkQWZ0ZXIocG9zKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHQudHlwZS5pc1NraXBwZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5mcm9tIDwgbGluZUVuZCA/IG9wZW5Ub2tlbiA6IG51bGw7XG4gICAgICAgIHBvcyA9IG5leHQudG87XG4gICAgfVxufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSBmb3IgZGVsaW1pdGVkICh1c3VhbGx5IGJyYWNrZXRlZCkgbm9kZXMuXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXG5pbmRlbnQgdW5sZXNzIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgY2xvc2luZyB0b2tlbi4gV2hlbiBgYWxpZ25gXG5pcyB0cnVlIGFuZCB0aGVyZSBhcmUgbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIG5vZGUncyBvcGVuaW5nXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxub3BlbmluZyBub2RlLCBsaWtlIHRoaXM6XG5cbiAgICBmb28oYmFyLFxuICAgICAgICBiYXopXG4qL1xuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcbiAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgc3BhY2UgPSBhZnRlci5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcgJiYgYWZ0ZXIuc2xpY2Uoc3BhY2UsIHNwYWNlICsgY2xvc2luZy5sZW5ndGgpID09IGNsb3NpbmcgfHwgY2xvc2VkQXQgPT0gY29udGV4dC5wb3MgKyBzcGFjZTtcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XG4gICAgaWYgKGFsaWduZWQpXG4gICAgICAgIHJldHVybiBjbG9zZWQgPyBjb250ZXh0LmNvbHVtbihhbGlnbmVkLmZyb20pIDogY29udGV4dC5jb2x1bW4oYWxpZ25lZC50byk7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXG5pbmRlbnRhdGlvbi5cbiovXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcbi8qKlxuQ3JlYXRlcyBhbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0LCBieSBkZWZhdWx0LCBpbmRlbnRzXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cbllvdSBjYW4gcHJvdmlkZSBgZXhjZXB0YCB0byBwcmV2ZW50IGluZGVudGF0aW9uIG9mIGxpbmVzIHRoYXRcbm1hdGNoIGEgcGF0dGVybiAoZm9yIGV4YW1wbGUgYC9eZWxzZVxcYi9gIGluIGBpZmAvYGVsc2VgXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxuYHVuaXRzYCBvcHRpb24uXG4qL1xuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaEV4Y2VwdCA9IGV4Y2VwdCAmJiBleGNlcHQudGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xuICAgIH07XG59XG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xuLyoqXG5FbmFibGVzIHJlaW5kZW50YXRpb24gb24gaW5wdXQuIFdoZW4gYSBsYW5ndWFnZSBkZWZpbmVzIGFuXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCksIHdoaWNoIG11c3QgaG9sZCBhIHJlZ3VsYXJcbmV4cHJlc3Npb24sIHRoZSBsaW5lIGF0IHRoZSBjdXJzb3Igd2lsbCBiZSByZWluZGVudGVkIHdoZW5ldmVyIG5ld1xudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxuY3Vyc29yIG1hdGNoZXMgdGhhdCByZWdleHAuXG5cblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXG5yZWdleHAgd2l0aCBgXmAgKHVzdWFsbHkgZm9sbG93ZWQgYnkgYFxccypgKSwgYW5kIGVuZCBpdCB3aXRoIGAkYC5cbkZvciBleGFtcGxlLCBgL15cXHMqXFx9JC9gIHdpbGwgcmVpbmRlbnQgd2hlbiBhIGNsb3NpbmcgYnJhY2UgaXNcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXG4qL1xuZnVuY3Rpb24gaW5kZW50T25JbnB1dCgpIHtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgfHwgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xuICAgICAgICBpZiAoaGVhZCA+IGxpbmUuZnJvbSArIERvbnRJbmRlbnRCZXlvbmQpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5zb21lKHIgPT4gci50ZXN0KGxpbmVTdGFydCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsYXN0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzLCBzZXF1ZW50aWFsOiB0cnVlIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5UaGlzIG5vZGUgcHJvcCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBmb2xkaW5nIGluZm9ybWF0aW9uIHdpdGhcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxudGhhdCB0cmVlIGlzIGZvbGRhYmxlIGFuZCByZXR1cm4gdGhlIHJhbmdlIHRoYXQgY2FuIGJlIGNvbGxhcHNlZFxud2hlbiBpdCBpcy5cbiovXG5jb25zdCBmb2xkTm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxudGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBhIHN5bnRheCBub2RlLiBVc2VmdWwgZm9yIG5vZGVzXG50aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCBkZWxpbWl0ZXJzLlxuKi9cbmZ1bmN0aW9uIGZvbGRJbnNpZGUobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XG59XG5mdW5jdGlvbiBzeW50YXhGb2xkaW5nKHN0YXRlLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBpZiAodHJlZS5sZW5ndGggPCBlbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbm5lciA9IHRyZWUucmVzb2x2ZUlubmVyKGVuZCwgMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGlmIChjdXIudG8gPD0gZW5kIHx8IGN1ci5mcm9tID4gZW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiBjdXIuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBwcm9wID0gY3VyLnR5cGUucHJvcChmb2xkTm9kZVByb3ApO1xuICAgICAgICBpZiAocHJvcCAmJiAoY3VyLnRvIDwgdHJlZS5sZW5ndGggLSA1MCB8fCB0cmVlLmxlbmd0aCA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8ICFpc1VuZmluaXNoZWQoY3VyKSkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZnJvbSA8PSBlbmQgJiYgdmFsdWUuZnJvbSA+PSBzdGFydCAmJiB2YWx1ZS50byA+IGVuZClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGlzVW5maW5pc2hlZChub2RlKSB7XG4gICAgbGV0IGNoID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGNoICYmIGNoLnRvID09IG5vZGUudG8gJiYgY2gudHlwZS5pc0Vycm9yO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBsaW5lIGlzIGZvbGRhYmxlLiBGaXJzdCBhc2tzIGFueSBmb2xkXG5zZXJ2aWNlcyByZWdpc3RlcmVkIHRocm91Z2hcbltgZm9sZFNlcnZpY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRTZXJ2aWNlKSwgYW5kIGlmIG5vbmUgb2YgdGhlbSByZXR1cm5cbmEgcmVzdWx0LCB0cmllcyB0byBxdWVyeSB0aGUgW2ZvbGQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIG9mIHN5bnRheCBub2RlcyB0aGF0IGNvdmVyIHRoZSBlbmRcbm9mIHRoZSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGZvbGRhYmxlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIHN0YXRlLmZhY2V0KGZvbGRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzeW50YXhGb2xkaW5nKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xufVxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcbiAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLnRvLCAtMSk7XG4gICAgcmV0dXJuIGZyb20gPj0gdG8gPyB1bmRlZmluZWQgOiB7IGZyb20sIHRvIH07XG59XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGZvbGQgdGhlXG5naXZlbiByYW5nZS4gKFlvdSBwcm9iYWJseSBvbmx5IG5lZWQgdGhpcyBpbiBleGNlcHRpb25hbFxuY2lyY3Vtc3RhbmNlc1x1MjAxNHVzdWFsbHkgeW91J2xsIGp1c3Qgd2FudCB0byBsZXRcbltgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKSBhbmQgdGhlIFtmb2xkXG5ndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcikgY3JlYXRlIHRoZSB0cmFuc2FjdGlvbnMuKVxuKi9cbmNvbnN0IGZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgdW5mb2xkcyB0aGUgZ2l2ZW4gcmFuZ2UgKGlmIGl0IHdhcyBmb2xkZWQpLlxuKi9cbmNvbnN0IHVuZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lcyh2aWV3KSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW5lcy5zb21lKGwgPT4gbC5mcm9tIDw9IGhlYWQgJiYgbC50byA+PSBoZWFkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsaW5lcy5wdXNoKHZpZXcubGluZUJsb2NrQXQoaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB0aGF0IHN0b3JlcyB0aGUgZm9sZGVkIHJhbmdlcyAoYXMgYSBbZGVjb3JhdGlvblxuc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkpLiBDYW4gYmUgcGFzc2VkIHRvXG5bYEVkaXRvclN0YXRlLnRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBhbmRcbltgZnJvbUpTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSB0byBzZXJpYWxpemUgdGhlIGZvbGRcbnN0YXRlLlxuKi9cbmNvbnN0IGZvbGRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH0sXG4gICAgdXBkYXRlKGZvbGRlZCwgdHIpIHtcbiAgICAgICAgZm9sZGVkID0gZm9sZGVkLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW2ZvbGRXaWRnZXQucmFuZ2UoZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKV0gfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlLmlzKHVuZm9sZEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBlLnZhbHVlLmZyb20sIGZpbHRlclRvOiBlLnZhbHVlLnRvIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IG9uU2VsZWN0aW9uID0gZmFsc2UsIHsgaGVhZCB9ID0gdHIuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBmb2xkZWQuYmV0d2VlbihoZWFkLCBoZWFkLCAoYSwgYikgPT4geyBpZiAoYSA8IGhlYWQgJiYgYiA+IGhlYWQpXG4gICAgICAgICAgICAgICAgb25TZWxlY3Rpb24gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVG86IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogKGEsIGIpID0+IGIgPD0gaGVhZCB8fCBhID49IGhlYWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9sZGVkO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiksXG4gICAgdG9KU09OKGZvbGRlZCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb2xkZWQuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgcmFuZ2VzLnB1c2goZnJvbSwgdG8pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9LFxuICAgIGZyb21KU09OKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICUgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2YWx1ZVtpKytdLCB0byA9IHZhbHVlW2krK107XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGZvbGRXaWRnZXQucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLCB0cnVlKTtcbiAgICB9XG59KTtcbi8qKlxuR2V0IGEgW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgY29udGFpbmluZyB0aGUgZm9sZGVkIHJhbmdlc1xuaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZvbGRlZFJhbmdlcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBSYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8qKlxuRm9sZCB0aGUgbGluZXMgdGhhdCBhcmUgc2VsZWN0ZWQsIGlmIHBvc3NpYmxlLlxuKi9cbmNvbnN0IGZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIFtmb2xkRWZmZWN0Lm9mKHJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlKV0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgdW5mb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA+IDA7XG59O1xuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS5udW1iZXIsIGxpbmVUbyA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50bykubnVtYmVyO1xuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKGZvbGQgPyBcIkZvbGRlZCBsaW5lc1wiIDogXCJVbmZvbGRlZCBsaW5lc1wiKX0gJHtsaW5lRnJvbX0gJHt2aWV3LnN0YXRlLnBocmFzZShcInRvXCIpfSAke2xpbmVUb30uYCk7XG59XG4vKipcbkZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuIE5vdGUgdGhhdCwgaW4gbW9zdCBjYXNlcyxcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcbnRyZWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSksIGFuZCBmb2xkaW5nIGV2ZXJ5dGhpbmcgbWF5IG5vdCB3b3JrXG5yZWxpYWJseSB3aGVuIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiBmdWxseSBwYXJzZWQgKGVpdGhlclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXG5kb2N1bWVudCBpcyBzbyBiaWcgdGhhdCB0aGUgcGFyc2VyIGRlY2lkZWQgbm90IHRvIHBhcnNlIGl0XG5lbnRpcmVseSkuXG4qL1xuY29uc3QgZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyksIHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcubGluZUJsb2NrQXQocmFuZ2UudG8pIDogbGluZSkudG8gKyAxO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcblVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG4qL1xuY29uc3QgdW5mb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiBcIlx1MjAyNlwiXG59O1xuY29uc3QgZm9sZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgZGVmYXVsdENvbmZpZyk7IH1cbn0pO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG4qL1xuZnVuY3Rpb24gY29kZUZvbGRpbmcoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtmb2xkU3RhdGUsIGJhc2VUaGVtZSQxXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgICAgICAgICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQodmlldy5wb3NBdERPTShldmVudC50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29uZi5wbGFjZWhvbGRlckRPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrKTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xuICAgICAgICAgICAgZWxlbWVudC50aXRsZSA9IHN0YXRlLnBocmFzZShcInVuZm9sZFwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICAgICAgICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH0gfSk7XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwiXHUyMzA0XCIsXG4gICAgY2xvc2VkVGV4dDogXCJcdTIwM0FcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjN2E3NTdhXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbmZ1bmN0aW9uIG1hdGNoaW5nTm9kZXMobm9kZSwgZGlyLCBicmFja2V0cykge1xuICAgIGxldCBieVByb3AgPSBub2RlLnByb3AoZGlyIDwgMCA/IE5vZGVQcm9wLm9wZW5lZEJ5IDogTm9kZVByb3AuY2xvc2VkQnkpO1xuICAgIGlmIChieVByb3ApXG4gICAgICAgIHJldHVybiBieVByb3A7XG4gICAgaWYgKG5vZGUubmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4ICUgMiA9PSAoZGlyIDwgMCA/IDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBbYnJhY2tldHNbaW5kZXggKyBkaXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bylcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY3VyLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIG1hdGNoaW5nLCBicmFja2V0cykge1xuICAgIGxldCBwYXJlbnQgPSB0b2tlbi5wYXJlbnQsIGZpcnN0VG9rZW4gPSB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0b2tlbi50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IHsgZnJvbTogY3Vyc29yLmZyb20sIHRvOiBjdXJzb3IudG8gfSwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogY3Vyc29yLmZyb20gPT0gY3Vyc29yLnRvID8gdW5kZWZpbmVkIDogeyBmcm9tOiBjdXJzb3IuZnJvbSwgdG86IGN1cnNvci50byB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2wodGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBpbnB1dCBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAgKHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIGEgYF5gKS4gUmV0dXJuIHRydWUgb3IgdGhlIHJlZ2V4cCBtYXRjaFxuICAgIGlmIGl0IG1hdGNoZXMuXG4gICAgXG4gICAgVW5sZXNzIGBjb25zdW1lYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhpcyB3aWxsIG1vdmUgYHRoaXMucG9zYFxuICAgIHBhc3QgdGhlIG1hdGNoZWQgdGV4dC5cbiAgICBcbiAgICBXaGVuIG1hdGNoaW5nIGEgc3RyaW5nIGBjYXNlSW5zZW5zaXRpdmVgIGNhbiBiZSBzZXQgdG8gdHJ1ZSB0b1xuICAgIG1ha2UgdGhlIG1hdGNoIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBjYXNlZCA9IChzdHIpID0+IGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO1xuICAgICAgICAgICAgbGV0IHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IHRva2VuLlxuICAgICovXG4gICAgY3VycmVudCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKTsgfVxufVxuXG5mdW5jdGlvbiBmdWxsUGFyc2VyKHNwZWMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzcGVjLm5hbWUgfHwgXCJcIixcbiAgICAgICAgdG9rZW46IHNwZWMudG9rZW4sXG4gICAgICAgIGJsYW5rTGluZTogc3BlYy5ibGFua0xpbmUgfHwgKCgpID0+IHsgfSksXG4gICAgICAgIHN0YXJ0U3RhdGU6IHNwZWMuc3RhcnRTdGF0ZSB8fCAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIGNvcHlTdGF0ZTogc3BlYy5jb3B5U3RhdGUgfHwgZGVmYXVsdENvcHlTdGF0ZSxcbiAgICAgICAgaW5kZW50OiBzcGVjLmluZGVudCB8fCAoKCkgPT4gbnVsbCksXG4gICAgICAgIGxhbmd1YWdlRGF0YTogc3BlYy5sYW5ndWFnZURhdGEgfHwge30sXG4gICAgICAgIHRva2VuVGFibGU6IHNwZWMudG9rZW5UYWJsZSB8fCBub1Rva2Vuc1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG4vKipcbkEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBjbGFzcyBiYXNlZCBvbiBhIENvZGVNaXJyb3JcbjUtc3R5bGUgW3N0cmVhbWluZyBwYXJzZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtUGFyc2VyKS5cbiovXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHBhcnNlci5sYW5ndWFnZURhdGEpO1xuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbaW5kZW50U2VydmljZS5vZigoY3gsIHBvcykgPT4gdGhpcy5nZXRJbmRlbnQoY3gsIHBvcykpXSwgcGFyc2VyLm5hbWUpO1xuICAgICAgICB0aGlzLnRvcE5vZGUgPSBkb2NJRChkYXRhKTtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcbiAgICAgICAgdGhpcy5zdGF0ZUFmdGVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy50b2tlblRhYmxlID0gcGFyc2VyLnRva2VuVGFibGUgPyBuZXcgVG9rZW5UYWJsZShwLnRva2VuVGFibGUpIDogZGVmYXVsdFRva2VuVGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0cmVhbSBsYW5ndWFnZS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykgeyByZXR1cm4gbmV3IFN0cmVhbUxhbmd1YWdlKHNwZWMpOyB9XG4gICAgZ2V0SW5kZW50KGN4LCBwb3MpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGN4LnN0YXRlKSwgYXQgPSB0cmVlLnJlc29sdmUocG9zKTtcbiAgICAgICAgd2hpbGUgKGF0ICYmIGF0LnR5cGUgIT0gdGhpcy50b3BOb2RlKVxuICAgICAgICAgICAgYXQgPSBhdC5wYXJlbnQ7XG4gICAgICAgIGlmICghYXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIHRyZWUsIDAsIGF0LmZyb20sIHBvcyksIHN0YXRlUG9zLCBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBzdGFydC5wb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGN4LnVuaXQpO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgcG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihwb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjeC5zdGF0ZS50YWJTaXplLCBjeC51bml0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgdGV4dCB9ID0gY3gubGluZUF0KHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbVBhcnNlci5pbmRlbnQoc3RhdGUsIC9eXFxzKiguKikvLmV4ZWModGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiB0cmVlLnR5cGUgPT0gbGFuZy50b3BOb2RlKVxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBwb3MgPSB0cmVlLnBvc2l0aW9uc1tpXSwgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBpbm5lcjtcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgaWYgKCEoaW5uZXIgPSBjdXRUcmVlKGxhbmcsIGNoaWxkLCBmcm9tIC0gcG9zLCB0byAtIHBvcywgaW5zaWRlKSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4gIWluc2lkZSA/IGlubmVyXG4gICAgICAgICAgICAgICAgOiBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4uc2xpY2UoMCwgaSkuY29uY2F0KGlubmVyKSwgdHJlZS5wb3NpdGlvbnMuc2xpY2UoMCwgaSArIDEpLCBwb3MgKyBpbm5lci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBzdGFydFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBUcmVlLmVtcHR5IH07XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IobGFuZywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZyA9IGxhbmc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCksIGZyb20gPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgbGV0IHsgc3RhdGUsIHRyZWUgfSA9IGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgZnJvbSwgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRoaXMuY2h1bmtTdGFydCA9IGZyb20gKyB0cmVlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRyZWUucG9zaXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgY29udGV4dC52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocGFyc2VFbmQsIHRoaXMuY2h1bmtTdGFydCArIDIwNDggLyogQy5DaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUluZGV4KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50byA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogQy5NYXhMaW5lTGVuZ3RoICovKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGVuZDtcbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPCB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MrKztcbiAgICB9XG4gICAgZmluaXNoQ2h1bmsoKSB7XG4gICAgICAgIGxldCB0cmVlID0gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY2h1bmssXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLnBhcnNlZFBvcyAtIHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIG5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogMCxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHRhZ1N0ci5zcGxpdChcIi5cIikpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gKGV4dHJhW3BhcnRdIHx8IHRhZ3NbcGFydF0pO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIXRhZylcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgTW9kaWZpZXIgJHtwYXJ0fSB1c2VkIGF0IHN0YXJ0IG9mIHRhZ2ApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbHVlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGFnKVxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBUYWcgJHtwYXJ0fSB1c2VkIGFzIG1vZGlmaWVyYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YWcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgaWQ6IHR5cGVBcnJheS5sZW5ndGgsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3BzOiBbc3R5bGVUYWdzKHsgW25hbWVdOiB0YWcgfSldXG4gICAgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGUuaWQ7XG59XG5mdW5jdGlvbiBkb2NJRChkYXRhKSB7XG4gICAgbGV0IHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoeyBpZDogdHlwZUFycmF5Lmxlbmd0aCwgbmFtZTogXCJEb2N1bWVudFwiLCBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKCgpID0+IGRhdGEpXSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IHsgSGlnaGxpZ2h0U3R5bGUsIEluZGVudENvbnRleHQsIExSTGFuZ3VhZ2UsIExhbmd1YWdlLCBMYW5ndWFnZURlc2NyaXB0aW9uLCBMYW5ndWFnZVN1cHBvcnQsIFBhcnNlQ29udGV4dCwgU3RyZWFtTGFuZ3VhZ2UsIFN0cmluZ1N0cmVhbSwgVHJlZUluZGVudENvbnRleHQsIGJyYWNrZXRNYXRjaGluZywgY29kZUZvbGRpbmcsIGNvbnRpbnVlZEluZGVudCwgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRBbGwsIGZvbGRDb2RlLCBmb2xkRWZmZWN0LCBmb2xkR3V0dGVyLCBmb2xkSW5zaWRlLCBmb2xkS2V5bWFwLCBmb2xkTm9kZVByb3AsIGZvbGRTZXJ2aWNlLCBmb2xkU3RhdGUsIGZvbGRhYmxlLCBmb2xkZWRSYW5nZXMsIGZvcmNlUGFyc2luZywgZ2V0SW5kZW50VW5pdCwgZ2V0SW5kZW50YXRpb24sIGhpZ2hsaWdodGluZ0ZvciwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFJhbmdlLCBpbmRlbnRTZXJ2aWNlLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGxhbmd1YWdlLCBsYW5ndWFnZURhdGFQcm9wLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iLCAiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGdldEluZGVudFVuaXQsIG1hdGNoQnJhY2tldHMsIHN5bnRheFRyZWUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xuaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGluZyBiYWNrIHRvIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xuICAgIGxldCBjb25maWcgPSBnZXRDb25maWcodGFyZ2V0LnN0YXRlKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZVVuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gLypAX19QVVJFX18qL2NvbW1hbmQoKG8sIHMpID0+IGNoYW5nZUJsb2NrQ29tbWVudChvLCBzLCBzZWxlY3RlZExpbmVSYW5nZXMocykpLCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbmZ1bmN0aW9uIGdldENvbmZpZyhzdGF0ZSwgcG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0udG8gPiBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgcmFuZ2VzW2xhc3RdLnRvID0gdG9MaW5lLnRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGZyb21MaW5lLmZyb20sIHRvOiB0b0xpbmUudG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgdG9rZW5zID0gcmFuZ2VzLm1hcChyID0+IGdldENvbmZpZyhzdGF0ZSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgdG9rZW5zW2ldLCByLmZyb20sIHIudG8pKTtcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogc3RhdGUuY2hhbmdlcyhyYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRva2Vuc1tpXS5vcGVuICsgXCIgXCIgfSwgeyBmcm9tOiByYW5nZS50bywgaW5zZXJ0OiBcIiBcIiArIHRva2Vuc1tpXS5jbG9zZSB9XTtcbiAgICAgICAgICAgIH0pKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydEkgPSBsaW5lcy5sZW5ndGgsIG1pbkluZGVudCA9IDFlOTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gcHJldkxpbmUgJiYgKGZyb20gPT0gdG8gfHwgdG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpLmxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZW1wdHkgPSBpbmRlbnQgPT0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IGxpbmUudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCAmJiAoIWwuZW1wdHkgfHwgbC5zaW5nbGUpKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgIWVtcHR5KVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogY2hhbmdlU2V0LCBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCAxKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA+PSAwKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoY29tbWVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBsaW5lLmZyb20gKyBjb21tZW50LCB0byA9IGZyb20gKyB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGFubm90YXRpb24gdGhhdCB3aWxsIHByZXZlbnQgdGhhdCB0cmFuc2FjdGlvbiBmcm9tXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxuYFwiYmVmb3JlXCJgLCBpdCdsbCBwcmV2ZW50IG1lcmdpbmcgd2l0aCBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFdpdGhcbmBcImFmdGVyXCJgLCBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucyB3b24ndCBiZSBjb21iaW5lZCB3aXRoIHRoaXNcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cbiovXG5jb25zdCBpc29sYXRlSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaGlzdG9yeUNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwXG4gICAgICAgIH0sIHsgbWluRGVwdGg6IE1hdGgubWF4LCBuZXdHcm91cERlbGF5OiBNYXRoLm1pbiB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGNoYW5nZUVuZChjaGFuZ2VzKSB7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoXywgdG8pID0+IGVuZCA9IHRvKTtcbiAgICByZXR1cm4gZW5kO1xufVxuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gSGlzdG9yeVN0YXRlLmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5kb2NDaGFuZ2VkID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjaGFuZ2VFbmQodHIuY2hhbmdlcykpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBzdGF0ZS51bmRvbmUgOiBzdGF0ZS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XG4gICAgICAgIGxldCBldmVudCA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICBsZXQgdGltZSA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udGltZSksIHVzZXJFdmVudCA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5LCBjb25maWcubWluRGVwdGgpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIHRvSlNPTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcbiAgICB9XG59KTtcbi8qKlxuQ3JlYXRlIGEgaGlzdG9yeSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaGlzdG9yeUZpZWxkXyxcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBFZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgZmFsc2UpO1xuLyoqXG5SZWRvIGEgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXAgd2FzXG5hdmFpbGFibGUuXG4qL1xuY29uc3QgcmVkbyA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgdW5kb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5sZW5ndGggLSAoYnJhbmNoLmxlbmd0aCAmJiAhYnJhbmNoWzBdLmNoYW5nZXMgPyAxIDogMCk7XG4gICAgfTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHVuZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyk7XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCByZWRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXksIG1heExlbikge1xuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZG9uZSwgbGFzdEV2ZW50ID0gZG9uZVtkb25lLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmICFsYXN0RXZlbnQuY2hhbmdlcy5lbXB0eSAmJiBldmVudC5jaGFuZ2VzICYmXG4gICAgICAgICAgICAoIXVzZXJFdmVudCB8fCBqb2luYWJsZVVzZXJFdmVudC50ZXN0KHVzZXJFdmVudCkpICYmXG4gICAgICAgICAgICAoKCFsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQobGFzdEV2ZW50LmNoYW5nZXMsIGV2ZW50LmNoYW5nZXMpKSB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciBjb21wb3NlIChidXQgbm90IGNvbXBvc2Uuc3RhcnQpIGV2ZW50cywgYWx3YXlzIGpvaW4gd2l0aCBwcmV2aW91cyBldmVudFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCAtIDEsIG1heExlbiwgbmV3IEhpc3RFdmVudChldmVudC5jaGFuZ2VzLmNvbXBvc2UobGFzdEV2ZW50LmNoYW5nZXMpLCBjb25jKGV2ZW50LmVmZmVjdHMsIGxhc3RFdmVudC5lZmZlY3RzKSwgbGFzdEV2ZW50Lm1hcHBlZCwgbGFzdEV2ZW50LnN0YXJ0U2VsZWN0aW9uLCBub25lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoLCBtYXhMZW4sIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRTZWxlY3Rpb24oc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xuICAgICAgICBpZiAobGFzdC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwic2VsZWN0LnVuZG9cIiA6IFwic2VsZWN0LnJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwidW5kb1wiIDogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuSGlzdG9yeVN0YXRlLmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBIaXN0b3J5U3RhdGUobm9uZSwgbm9uZSk7XG4vKipcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxuXG4tIE1vZC16OiBbYHVuZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG8pLlxuLSBNb2QteSAoTW9kLVNoaWZ0LXogb24gbWFjT1MpICsgQ3RybC1TaGlmdC16IG9uIExpbnV4OiBbYHJlZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG8pLlxuLSBNb2QtdTogW2B1bmRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvU2VsZWN0aW9uKS5cbi0gQWx0LXUgKE1vZC1TaGlmdC11IG9uIG1hY09TKTogW2ByZWRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvU2VsZWN0aW9uKS5cbiovXG5jb25zdCBoaXN0b3J5S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC16XCIsIHJ1bjogdW5kbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QteVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbGludXg6IFwiQ3RybC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtdVwiLCBydW46IHVuZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXTtcblxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLm1hcChieSksIHNlbC5tYWluSW5kZXgpO1xufVxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xufVxuZnVuY3Rpb24gbW92ZVNlbCh7IHN0YXRlLCBkaXNwYXRjaCB9LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgaG93KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gcmFuZ2UudG8gOiByYW5nZS5mcm9tKTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbmZ1bmN0aW9uIGx0ckF0Q3Vyc29yKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSA9PSBEaXJlY3Rpb24uTFRSO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCAod2hpY2ggaXMgYmFja3dhcmQgaW5cbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBsZWZ0IGFjcm9zcyBvbmUgZ3JvdXAgb2Ygd29yZCBvclxubm9uLXdvcmQgKGJ1dCBhbHNvIG5vbi1zcGFjZSkgY2hhcmFjdGVycy5cbiovXG5jb25zdCBjdXJzb3JHcm91cExlZnQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcbiAgICByZXR1cm4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkLCBzdGFydCA9PiB7XG4gICAgICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb207XG4gICAgICAgIGxldCBkb25lID0gZmFsc2UsIHNhd1VwcGVyID0gZmFsc2UsIHNhd0xvd2VyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCksIGFoZWFkO1xuICAgICAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzYXdMb3dlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2F3VXBwZXIgJiYgZm9yd2FyZCAmJiBjYXRlZ29yaXplKGFoZWFkID0gdmlldy5zdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2F3VXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBzdGVwKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUhlaWdodCh2aWV3KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZpZXcuZGVmYXVsdExpbmVIZWlnaHQsIE1hdGgubWluKHZpZXcuZG9tLmNsaWVudEhlaWdodCwgaW5uZXJIZWlnaHQpIC0gNSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VIZWlnaHQodmlldykpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZWZmZWN0O1xuICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxSZWN0LnRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxSZWN0LmJvdHRvbSAmJlxuICAgICAgICBzdGFydFBvcy50b3AgLSBzY3JvbGxSZWN0LnRvcCA8PSB2aWV3LnNjcm9sbERPTS5zY3JvbGxIZWlnaHQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpXG4gICAgICAgIGVmZmVjdCA9IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLm1haW4uaGVhZCwgeyB5OiBcInN0YXJ0XCIsIHlNYXJnaW46IHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFJlY3QudG9wIH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodmlldywgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbik7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbCh2aWV3LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSGVpZ2h0KHZpZXcpKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VVcCA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lU3RhcnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVFbmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IHsgYW5jaG9yOiAwLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBjb3ZlciBlbnRpcmUgbGluZXMuXG4qL1xuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCBNYXRoLm1pbih0byArIDEsIHN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyksIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxuc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayBpbnNvZmFyIGFzIHRoZSBsYW5ndWFnZVxuW3Byb3ZpZGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlKSB5b3UgdXNlIGJ1aWxkcyB1cCBhIGZ1bGxcbnN5bnRheCB0cmVlLlxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudFN5bnRheCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihyYW5nZS5oZWFkLCAxKTtcbiAgICAgICAgd2hpbGUgKCEoKGNvbnRleHQuZnJvbSA8IHJhbmdlLmZyb20gJiYgY29udGV4dC50byA+PSByYW5nZS50bykgfHxcbiAgICAgICAgICAgIChjb250ZXh0LnRvID4gcmFuZ2UudG8gJiYgY29udGV4dC5mcm9tIDw9IHJhbmdlLmZyb20pIHx8XG4gICAgICAgICAgICAhKChfYSA9IGNvbnRleHQucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50KSkpXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY29udGV4dC50bywgY29udGV4dC5mcm9tKTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgbGV0IHRvd2FyZHMgPSBieShmcm9tKTtcbiAgICAgICAgICAgIGlmICh0b3dhcmRzIDwgZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuYmFja3dhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvd2FyZHMgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5mb3J3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihmcm9tLCB0b3dhcmRzKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIHRvd2FyZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHNraXBBdG9taWModGFyZ2V0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgICAgICB0byA9IHNraXBBdG9taWModGFyZ2V0LCB0bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSkgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IGV2ZW50LFxuICAgICAgICBlZmZlY3RzOiBldmVudCA9PSBcImRlbGV0ZS5zZWxlY3Rpb25cIiA/IEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwiU2VsZWN0aW9uIGRlbGV0ZWRcIikpIDogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2tpcEF0b21pYyh0YXJnZXQsIHBvcywgZm9yd2FyZCkge1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFZGl0b3JWaWV3KVxuICAgICAgICBmb3IgKGxldCByYW5nZXMgb2YgdGFyZ2V0LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHRhcmdldCkpKVxuICAgICAgICAgICAgcmFuZ2VzLmJldHdlZW4ocG9zLCBwb3MsIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBmb3J3YXJkID8gdG8gOiBmcm9tO1xuICAgICAgICAgICAgfSk7XG4gICAgcmV0dXJuIHBvcztcbn1cbmNvbnN0IGRlbGV0ZUJ5Q2hhciA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcG9zID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmUsIHRhcmdldFBvcztcbiAgICBpZiAoIWZvcndhcmQgJiYgcG9zID4gbGluZS5mcm9tICYmIHBvcyA8IGxpbmUuZnJvbSArIDIwMCAmJlxuICAgICAgICAhL1teIFxcdF0vLnRlc3QoYmVmb3JlID0gbGluZS50ZXh0LnNsaWNlKDAsIHBvcyAtIGxpbmUuZnJvbSkpKSB7XG4gICAgICAgIGlmIChiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdID09IFwiXFx0XCIpXG4gICAgICAgICAgICByZXR1cm4gcG9zIC0gMTtcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKGJlZm9yZSwgc3RhdGUudGFiU2l6ZSksIGRyb3AgPSBjb2wgJSBnZXRJbmRlbnRVbml0KHN0YXRlKSB8fCBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgdGFyZ2V0UG9zID0gcG9zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0UG9zID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGZvciBjdXJzb3Igc2VsZWN0aW9ucywgdGhlIGNoYXJhY3RlclxuYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCB0cnVlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHN0YXJ0ID0+IHtcbiAgICBsZXQgcG9zID0gc3RhcnQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKGNhdCAhPSBudWxsICYmIG5leHRDYXQgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPSBcIiBcIiB8fCBwb3MgIT0gc3RhcnQpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGJhY2t3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHRcbltncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5R3JvdXApLCBvbmx5IHNraXBwaW5nIGdyb3VwcyBvZlxud2hpdGVzcGFjZSB3aGVuIHRoZXkgY29uc2lzdCBvZiBhIHNpbmdsZSBzcGFjZS5cbiovXG5jb25zdCBkZWxldGVHcm91cEJhY2t3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGZvcndhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBkZWxldGVHcm91cEZvcndhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIHRydWUpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBlbmQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lRW5kID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCBwb3MgPT4ge1xuICAgIGxldCBsaW5lRW5kID0gdmlldy5saW5lQmxvY2tBdChwb3MpLnRvO1xuICAgIHJldHVybiBwb3MgPCBsaW5lRW5kID8gbGluZUVuZCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcG9zICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBiZWZvcmUgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lU3RhcnQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubGluZUJsb2NrQXQocG9zKS5mcm9tO1xuICAgIHJldHVybiBwb3MgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCBwb3MgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcbmRvY3VtZW50LlxuKi9cbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBwcmV2ID0gXCJcIiwgaXRlciA9IHN0YXRlLmRvYy5pdGVyKCk7Oykge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nID0gcHJldi5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmcgPiAtMSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XG4gICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJldiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaXRlci52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogVGV4dC5vZihbXCJcIiwgXCJcIl0pIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cbiovXG5jb25zdCB0cmFuc3Bvc2VDaGFycyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShwb3MsIHRvKS5hcHBlbmQoc3RhdGUuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIHRvOiBuZXh0TGluZS50byB9LCB7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogbmV4dExpbmUudGV4dCArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmFuY2hvciArIHNpemUpLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmhlYWQgKyBzaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dExpbmUuZnJvbSwgdG86IGJsb2NrLmZyb20gfSwgeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgdXAgb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb3B5bGluZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfSkpO1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCB0cnVlKSkubWFwKGNoYW5nZXMpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzLCBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmxpbmVcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXG4gICAgICAgIHN0YXRlLmRvYy5saW5lQXQoYmVmb3JlLnRvKS5mcm9tID09IHN0YXRlLmRvYy5saW5lQXQoYWZ0ZXIuZnJvbSkuZnJvbSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogYmVmb3JlLnRvLCB0bzogYWZ0ZXIuZnJvbSB9O1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxubGluZShzKS4gSWYgdGhlIGN1cnJlbnQgbGluZSBjb25zaXN0cyBvbmx5IG9mIHdoaXRlc3BhY2UsIHRoaXNcbndpbGwgYWxzbyBkZWxldGUgdGhhdCB3aGl0ZXNwYWNlLiBXaGVuIHRoZSBjdXJzb3IgaXMgYmV0d2VlblxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXG50aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQodHJ1ZSk7XG5mdW5jdGlvbiBuZXdsaW5lQW5kSW5kZW50KGF0RW9mKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9ICFhdEVvZiAmJiBmcm9tID09IHRvICYmIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChhdEVvZilcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gPSAodG8gPD0gbGluZS50byA/IGxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KGZyb20pLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGluZGVudFN0cmluZyhzdGF0ZSwgY3gubGluZUluZGVudChsaW5lLmZyb20sIC0xKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIGYpIHtcbiAgICBsZXQgYXRMaW5lID0gLTE7XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5mcm9tOyBwb3MgPD0gcmFuZ2UudG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xuICAgIH0pO1xufVxuLyoqXG5BdXRvLWluZGVudCB0aGUgc2VsZWN0ZWQgbGluZXMuIFRoaXMgdXNlcyB0aGUgW2luZGVudGF0aW9uIHNlcnZpY2VcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIGFzIHNvdXJjZSBmb3IgYXV0by1pbmRlbnRcbmluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGluZGVudFNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdXBkYXRlZFtzdGFydF07XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPT0gbnVsbCA/IC0xIDogZm91bmQ7XG4gICAgICAgIH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMsIHJhbmdlKSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oc3BhY2UsIHN0YXRlLnRhYlNpemUpLCBrZWVwID0gMDtcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBzcGFjZS5sZW5ndGggJiYga2VlcCA8IGluc2VydC5sZW5ndGggJiYgc3BhY2UuY2hhckNvZGVBdChrZWVwKSA9PSBpbnNlcnQuY2hhckNvZGVBdChrZWVwKSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JbnNlcnQgYSB0YWIgY2hhcmFjdGVyIGF0IHRoZSBjdXJzb3Igb3IsIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCxcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXG5zZWxlY3Rpb24uXG4qL1xuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNvbnRhaW5pbmcgdGhlIEVtYWNzLXN0eWxlIGJpbmRpbmdzIHRoYXQgYXJlXG5hdmFpbGFibGUgb24gbWFjT1MgYnkgZGVmYXVsdC5cblxuIC0gQ3RybC1iOiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1mOiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLW46IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDdHJsLWE6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWQ6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1oOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxuIC0gQ3RybC1BbHQtaDogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1vOiBbYHNwbGl0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRMaW5lKVxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcbiAtIEN0cmwtdjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pXG4gLSBBbHQtdjogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcClcbiovXG5jb25zdCBlbWFjc1N0eWxlS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtYlwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1oXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtdFwiLCBydW46IHRyYW5zcG9zZUNoYXJzIH0sXG4gICAgeyBrZXk6IFwiQ3RybC12XCIsIHJ1bjogY3Vyc29yUGFnZURvd24gfSxcbl07XG4vKipcbkFuIGFycmF5IG9mIGtleSBiaW5kaW5ncyBjbG9zZWx5IHN0aWNraW5nIHRvIHBsYXRmb3JtLXN0YW5kYXJkIG9yXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cbltgZW1hY3NTdHlsZUtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZW1hY3NTdHlsZUtleW1hcCksIHdpdGggdGhlaXIgYGtleWBcbnByb3BlcnR5IGNoYW5nZWQgdG8gYG1hY2AuKVxuXG4gLSBBcnJvd0xlZnQ6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1JpZ2h0OiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93UmlnaHQgKEFsdC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cFJpZ2h0KSAoW2BzZWxlY3RHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cFJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93TGVmdCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEFycm93VXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dEb3duOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZVVwOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIFBhZ2VEb3duOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcbiAtIEVuZDogW2BjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1Ib21lIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVUb0xpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lU3RhcnQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKS5cbiovXG5jb25zdCBzdGFuZGFyZEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93RG93blwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIkhvbWVcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1Ib21lXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1FbmRcIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgfSxcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCwgc2hpZnQ6IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLUJhY2tzcGFjZVwiLCBtYWM6IFwiQWx0LUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtRGVsZXRlXCIsIG1hYzogXCJBbHQtRGVsZXRlXCIsIHJ1bjogZGVsZXRlR3JvdXBGb3J3YXJkIH0sXG4gICAgeyBtYWM6IFwiTW9kLUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZVRvTGluZVN0YXJ0IH0sXG4gICAgeyBtYWM6IFwiTW9kLURlbGV0ZVwiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9XG5dLmNvbmNhdCgvKkBfX1BVUkVfXyovZW1hY3NTdHlsZUtleW1hcC5tYXAoYiA9PiAoeyBtYWM6IGIua2V5LCBydW46IGIucnVuLCBzaGlmdDogYi5zaGlmdCB9KSkpO1xuLyoqXG5UaGUgZGVmYXVsdCBrZXltYXAuIEluY2x1ZGVzIGFsbCBiaW5kaW5ncyBmcm9tXG5bYHN0YW5kYXJkS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zdGFuZGFyZEtleW1hcCkgcGx1cyB0aGUgZm9sbG93aW5nOlxuXG4tIEFsdC1BcnJvd0xlZnQgKEN0cmwtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhMZWZ0KSAoW2BzZWxlY3RTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhMZWZ0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dSaWdodCAoQ3RybC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4UmlnaHQpIChbYHNlbGVjdFN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhSaWdodCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93VXA6IFtgbW92ZUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVVcClcbi0gQWx0LUFycm93RG93bjogW2Btb3ZlTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lRG93bilcbi0gU2hpZnQtQWx0LUFycm93VXA6IFtgY29weUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVVcClcbi0gU2hpZnQtQWx0LUFycm93RG93bjogW2Bjb3B5TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lRG93bilcbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcbi0gQ3RybC1FbnRlciAoQ29tZC1FbnRlciBvbiBtYWNPUyk6IFtgaW5zZXJ0QmxhbmtMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRCbGFua0xpbmUpXG4tIEFsdC1sIChDdHJsLWwgb24gbWFjT1MpOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbi0gQ3RybC0vIChDbWQtLyBvbiBtYWNPUyk6IFtgdG9nZ2xlQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQ29tbWVudCkuXG4tIFNoaWZ0LUFsdC1hOiBbYHRvZ2dsZUJsb2NrQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQmxvY2tDb21tZW50KS5cbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBbHQtQXJyb3dMZWZ0XCIsIG1hYzogXCJDdHJsLUFycm93TGVmdFwiLCBydW46IGN1cnNvclN5bnRheExlZnQsIHNoaWZ0OiBzZWxlY3RTeW50YXhMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93UmlnaHRcIiwgbWFjOiBcIkN0cmwtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvclN5bnRheFJpZ2h0LCBzaGlmdDogc2VsZWN0U3ludGF4UmlnaHQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dVcFwiLCBydW46IGNvcHlMaW5lVXAgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dEb3duXCIsIHJ1bjogbW92ZUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IHNpbXBsaWZ5U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVudGVyXCIsIHJ1bjogaW5zZXJ0QmxhbmtMaW5lIH0sXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtW1wiLCBydW46IGluZGVudExlc3MgfSxcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LVxcXFxcIiwgcnVuOiBpbmRlbnRTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2Qta1wiLCBydW46IGRlbGV0ZUxpbmUgfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9LFxuICAgIHsga2V5OiBcIk1vZC0vXCIsIHJ1bjogdG9nZ2xlQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkFsdC1BXCIsIHJ1bjogdG9nZ2xlQmxvY2tDb21tZW50IH1cbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgYW5kXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cblBsZWFzZSBzZWUgdGhlIFtUYWIgZXhhbXBsZV0oLi4vLi4vZXhhbXBsZXMvdGFiLykgYmVmb3JlIHVzaW5nXG50aGlzLlxuKi9cbmNvbnN0IGluZGVudFdpdGhUYWIgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbmRlbnRNb3JlLCBzaGlmdDogaW5kZW50TGVzcyB9O1xuXG5leHBvcnQgeyBibG9ja0NvbW1lbnQsIGJsb2NrVW5jb21tZW50LCBjb3B5TGluZURvd24sIGNvcHlMaW5lVXAsIGN1cnNvckNoYXJCYWNrd2FyZCwgY3Vyc29yQ2hhckZvcndhcmQsIGN1cnNvckNoYXJMZWZ0LCBjdXJzb3JDaGFyUmlnaHQsIGN1cnNvckRvY0VuZCwgY3Vyc29yRG9jU3RhcnQsIGN1cnNvckdyb3VwQmFja3dhcmQsIGN1cnNvckdyb3VwRm9yd2FyZCwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVMaW5lLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBMZWZ0LCBzZWxlY3RHcm91cFJpZ2h0LCBzZWxlY3RMaW5lLCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHNlbGVjdExpbmVEb3duLCBzZWxlY3RMaW5lRW5kLCBzZWxlY3RMaW5lU3RhcnQsIHNlbGVjdExpbmVVcCwgc2VsZWN0TWF0Y2hpbmdCcmFja2V0LCBzZWxlY3RQYWdlRG93biwgc2VsZWN0UGFnZVVwLCBzZWxlY3RQYXJlbnRTeW50YXgsIHNlbGVjdFN1YndvcmRCYWNrd2FyZCwgc2VsZWN0U3Vid29yZEZvcndhcmQsIHNlbGVjdFN5bnRheExlZnQsIHNlbGVjdFN5bnRheFJpZ2h0LCBzaW1wbGlmeVNlbGVjdGlvbiwgc3BsaXRMaW5lLCBzdGFuZGFyZEtleW1hcCwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0cmFuc3Bvc2VDaGFycywgdW5kbywgdW5kb0RlcHRoLCB1bmRvU2VsZWN0aW9uIH07XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlbHQoKSB7XG4gIHZhciBlbHQgPSBhcmd1bWVudHNbMF1cbiAgaWYgKHR5cGVvZiBlbHQgPT0gXCJzdHJpbmdcIikgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbHQpXG4gIHZhciBpID0gMSwgbmV4dCA9IGFyZ3VtZW50c1sxXVxuICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcIm9iamVjdFwiICYmIG5leHQubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbmV4dCkgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0LCBuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV4dFtuYW1lXVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkgZWx0W25hbWVdID0gdmFsdWVcbiAgICB9XG4gICAgaSsrXG4gIH1cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFkZChlbHQsIGFyZ3VtZW50c1tpXSlcbiAgcmV0dXJuIGVsdFxufVxuXG5mdW5jdGlvbiBhZGQoZWx0LCBjaGlsZCkge1xuICBpZiAodHlwZW9mIGNoaWxkID09IFwic3RyaW5nXCIpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKVxuICB9IGVsc2UgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGNoaWxkKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKykgYWRkKGVsdCwgY2hpbGRbaV0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGlsZCBub2RlOiBcIiArIGNoaWxkKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IG5vcm0uY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IG5vcm0ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChjb2RlLCBwb3MpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNbaV0rKztcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdCgwKSA9PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogcG9zLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMudGVzdCAmJiAhdGhpcy50ZXN0KG1hdGNoLmZyb20sIG1hdGNoLnRvLCB0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5jb25zdCBkaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKGRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwgPyBjcmVhdGVMaW5lRGlhbG9nIDogbnVsbClcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cblxuVGhlIGRpYWxvZyBjYW4gYmUgc3R5bGVkIHdpdGggdGhlIGBwYW5lbC5nb3RvTGluZWAgdGhlbWVcbnNlbGVjdG9yLlxuKi9cbmNvbnN0IGdvdG9MaW5lID0gdmlldyA9PiB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IFtkaWFsb2dFZmZlY3Qub2YodHJ1ZSldO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpID09IG51bGwpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIH1cbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICYmIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayB8fCBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgZnJvbSA8PSByYW5nZS5mcm9tICYmIHRvID49IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1haW5NYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5sZW5ndGggPiBjb25mLm1heE1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTlmZjc3ODBcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoIC5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiIH1cbn0pO1xuLy8gU2VsZWN0IHRoZSB3b3JkcyBhcm91bmQgdGhlIGN1cnNvcnMuXG5jb25zdCBzZWxlY3RXb3JkID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgIGxldCBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKSB8fCBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQpKSwgc2VsZWN0aW9uLm1haW5JbmRleCk7XG4gICAgaWYgKG5ld1NlbC5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBuZXdTZWwgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgbmV4dCBvY2N1cnJlbmNlIG9mIHF1ZXJ5IHJlbGF0aXZlIHRvIGxhc3QgY3Vyc29yLiBXcmFwIGFyb3VuZFxuLy8gdGhlIGRvY3VtZW50IGlmIHRoZXJlIGFyZSBubyBtb3JlIG1hdGNoZXMuXG5mdW5jdGlvbiBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHF1ZXJ5KSB7XG4gICAgbGV0IHsgbWFpbiwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQobWFpbi5oZWFkKSwgZnVsbFdvcmQgPSB3b3JkICYmIHdvcmQuZnJvbSA9PSBtYWluLmZyb20gJiYgd29yZC50byA9PSBtYWluLnRvO1xuICAgIGZvciAobGV0IGN5Y2xlZCA9IGZhbHNlLCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG8pOzspIHtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCAwLCBNYXRoLm1heCgwLCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmZyb20gLSAxKSk7XG4gICAgICAgICAgICBjeWNsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZCAmJiByYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBjdXJzb3IudmFsdWUuZnJvbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZnVsbFdvcmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChjdXJzb3IudmFsdWUuZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQuZnJvbSAhPSBjdXJzb3IudmFsdWUuZnJvbSB8fCB3b3JkLnRvICE9IGN1cnNvci52YWx1ZS50bylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5TZWxlY3QgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRXhwYW5kIHNlbGVjdGlvblxudG8gdGhlIHN1cnJvdW5kaW5nIHdvcmQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuKi9cbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2VzWzBdLmZyb20sIHJhbmdlc1swXS50byk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHN0YXRlLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgc2VhcmNoZWRUZXh0KTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24uYWRkUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlYXJjaENvbmZpZ0ZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuQWRkIHNlYXJjaCBzdGF0ZSB0byB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24sIGFuZCBvcHRpb25hbGx5XG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXG4oW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIHdpbGwgYXV0b21hdGljYWxseVxuZW5hYmxlIHRoaXMgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbikuXG4qL1xuZnVuY3Rpb24gc2VhcmNoKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKSwgc2VhcmNoRXh0ZW5zaW9uc10gOiBzZWFyY2hFeHRlbnNpb25zO1xufVxuLyoqXG5BIHNlYXJjaCBxdWVyeS4gUGFydCBvZiB0aGUgZWRpdG9yJ3Mgc2VhcmNoIHN0YXRlLlxuKi9cbmNsYXNzIFNlYXJjaFF1ZXJ5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSAhIWNvbmZpZy5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmxpdGVyYWwgPSAhIWNvbmZpZy5saXRlcmFsO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcbiAgICAgICAgdGhpcy5yZXBsYWNlID0gY29uZmlnLnJlcGxhY2UgfHwgXCJcIjtcbiAgICAgICAgdGhpcy52YWxpZCA9ICEhdGhpcy5zZWFyY2ggJiYgKCF0aGlzLnJlZ2V4cCB8fCB2YWxpZFJlZ0V4cCh0aGlzLnNlYXJjaCkpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aG9sZVdvcmQgPSAhIWNvbmZpZy53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdW5xdW90ZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwgPyB0ZXh0IDpcbiAgICAgICAgICAgIHRleHQucmVwbGFjZSgvXFxcXChbbnJ0XFxcXF0pL2csIChfLCBjaCkgPT4gY2ggPT0gXCJuXCIgPyBcIlxcblwiIDogY2ggPT0gXCJyXCIgPyBcIlxcclwiIDogY2ggPT0gXCJ0XCIgPyBcIlxcdFwiIDogXCJcXFxcXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcXVlcnkgdG8gYW5vdGhlciBxdWVyeS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaCA9PSBvdGhlci5zZWFyY2ggJiYgdGhpcy5yZXBsYWNlID09IG90aGVyLnJlcGxhY2UgJiZcbiAgICAgICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9PSBvdGhlci5jYXNlU2Vuc2l0aXZlICYmIHRoaXMucmVnZXhwID09IG90aGVyLnJlZ2V4cCAmJlxuICAgICAgICAgICAgdGhpcy53aG9sZVdvcmQgPT0gb3RoZXIud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gbmV3IFJlZ0V4cFF1ZXJ5KHRoaXMpIDogbmV3IFN0cmluZ1F1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBzZWFyY2ggY3Vyc29yIGZvciB0aGlzIHF1ZXJ5LCBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgZ2l2ZW5cbiAgICByYW5nZSBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXRDdXJzb3Ioc3RhdGUsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBsZXQgc3QgPSBzdGF0ZS5kb2MgPyBzdGF0ZSA6IEVkaXRvclN0YXRlLmNyZWF0ZSh7IGRvYzogc3RhdGUgfSk7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSBzdC5kb2MubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyByZWdleHBDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKSA6IHN0cmluZ0N1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ0N1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMudW5xdW90ZWQsIGZyb20sIHRvLCBzcGVjLmNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiB4ID0+IHgudG9Mb3dlckNhc2UoKSwgc3BlYy53aG9sZVdvcmQgPyBzdHJpbmdXb3JkVGVzdChzdGF0ZS5kb2MsIHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gc3RyaW5nV29yZFRlc3QoZG9jLCBjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIGJ1ZiwgYnVmUG9zKSA9PiB7XG4gICAgICAgIGlmIChidWZQb3MgPiBmcm9tIHx8IGJ1ZlBvcyArIGJ1Zi5sZW5ndGggPCB0bykge1xuICAgICAgICAgICAgYnVmUG9zID0gTWF0aC5tYXgoMCwgZnJvbSAtIDIpO1xuICAgICAgICAgICAgYnVmID0gZG9jLnNsaWNlU3RyaW5nKGJ1ZlBvcywgTWF0aC5taW4oZG9jLmxlbmd0aCwgdG8gKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbiAgICB9O1xufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgfVxuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pKTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeSxcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XG5vZiB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBlbmQgYWdhaW4uXG4qL1xuY29uc3QgZmluZFByZXZpb3VzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCByYW5nZSA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiByYW5nZS5mcm9tLCBoZWFkOiByYW5nZS50byB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2VNYXRjaCh2aWV3LCByYW5nZSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCBzZWxlY3Rpb24sIHJlcGxhY2VtZW50O1xuICAgIGxldCBhbm5vdW5jZSA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgYW5ub3VuY2UucHVzaChFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcInJlcGxhY2VkIG1hdGNoIG9uIGxpbmUgJFwiLCBzdGF0ZS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbmV4dC50byA/IDAgOiBuZXh0LnRvIC0gbmV4dC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSB7IGFuY2hvcjogbmV4dC5mcm9tIC0gb2ZmLCBoZWFkOiBuZXh0LnRvIC0gb2ZmIH07XG4gICAgICAgIGFubm91bmNlLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2UsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBzZWxUZXh0ID0gc2VsLmVtcHR5IHx8IHNlbC50byA+IHNlbC5mcm9tICsgMTAwID8gXCJcIiA6IHN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBzZWwudG8pO1xuICAgIGlmIChmYWxsYmFjayAmJiAhc2VsVGV4dClcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGxldCBjb25maWcgPSBzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgIHNlYXJjaDogKChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25maWcubGl0ZXJhbCkgPyBzZWxUZXh0IDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogKF9iID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmNhc2VTZW5zaXRpdmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbmZpZy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICBsaXRlcmFsOiAoX2MgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29uZmlnLmxpdGVyYWwsXG4gICAgICAgIHdob2xlV29yZDogKF9kID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuLyoqXG5NYWtlIHN1cmUgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGFuZCBmb2N1c2VkLlxuKi9cbmNvbnN0IG9wZW5TZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucGFuZWwpIHtcbiAgICAgICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgICAgICBpZiAoIXBhbmVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIlttYWluLWZpZWxkXVwiKTtcbiAgICAgICAgaWYgKHNlYXJjaElucHV0ICYmIHNlYXJjaElucHV0ICE9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYyk7XG4gICAgICAgICAgICBpZiAocXVlcnkudmFsaWQpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbC5vZih0cnVlKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA/IHNldFNlYXJjaFF1ZXJ5Lm9mKGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKSkgOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcbiAgICAgICAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cbiovXG5jb25zdCBjbG9zZVNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY29udGFpbnModmlldy5yb290LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkRlZmF1bHQgc2VhcmNoLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBNb2QtZjogW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpXG4gLSBGMywgTW9kLWc6IFtgZmluZE5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kTmV4dClcbiAtIFNoaWZ0LUYzLCBTaGlmdC1Nb2QtZzogW2BmaW5kUHJldmlvdXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kUHJldmlvdXMpXG4gLSBBbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1kXCIsIHJ1bjogc2VsZWN0TmV4dE9jY3VycmVuY2UsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG5dO1xuY2xhc3MgU2VhcmNoUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XG4gICAgICAgIHRoaXMuY29tbWl0ID0gdGhpcy5jb21taXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5yZXBsYWNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LnJlZ2V4cCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JkRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS53aG9sZVdvcmQsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcbiAgICAgICAgICAgIC4uLnZpZXcuc3RhdGUucmVhZE9ubHkgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICBlbHQoXCJiclwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZVwiKV0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2UgYWxsXCIpXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJjbG9zZVwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICB9LCBbXCJcdTAwRDdcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIChlLnNoaWZ0S2V5ID8gZmluZFByZXZpb3VzIDogZmluZE5leHQpKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMucmVwbGFjZUZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlID0gcXVlcnkucmVwbGFjZTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xuICAgICAgICB0aGlzLndvcmRGaWVsZC5jaGVja2VkID0gcXVlcnkud2hvbGVXb3JkO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC5zZWxlY3QoKTtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkudG9wOyB9XG59XG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XG5jb25zdCBBbm5vdW5jZU1hcmdpbiA9IDMwO1xuY29uc3QgQnJlYWsgPSAvW1xcc1xcLiw6Oz8hXS87XG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZS5mcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMGZmZmY4YVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjZhMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxufSk7XG5jb25zdCBzZWFyY2hFeHRlbnNpb25zID0gW1xuICAgIHNlYXJjaFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9QcmVjLmxvd2VzdChzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnQgeyBSZWdFeHBDdXJzb3IsIFNlYXJjaEN1cnNvciwgU2VhcmNoUXVlcnksIGNsb3NlU2VhcmNoUGFuZWwsIGZpbmROZXh0LCBmaW5kUHJldmlvdXMsIGdldFNlYXJjaFF1ZXJ5LCBnb3RvTGluZSwgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgb3BlblNlYXJjaFBhbmVsLCByZXBsYWNlQWxsLCByZXBsYWNlTmV4dCwgc2VhcmNoLCBzZWFyY2hLZXltYXAsIHNlYXJjaFBhbmVsT3Blbiwgc2VsZWN0TWF0Y2hlcywgc2VsZWN0TmV4dE9jY3VycmVuY2UsIHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMsIHNldFNlYXJjaFF1ZXJ5IH07XG4iLCAiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBQcmVjLCBUZXh0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgbG9nRXhjZXB0aW9uLCBEaXJlY3Rpb24sIHNob3dUb29sdGlwLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBnZXRUb29sdGlwLCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc1x1MjAxNGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQsIGNvbnRlbnQsIGFuZCAoaWYgdGhlcmUgaXMgYSB0b2tlbikgdHlwZSBvZiB0aGVcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIHRva2VuQmVmb3JlKHR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZUlubmVyKHRoaXMucG9zLCAtMSk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAmJiB0eXBlcy5pbmRleE9mKHRva2VuLm5hbWUpIDwgMClcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4ucGFyZW50O1xuICAgICAgICByZXR1cm4gdG9rZW4gPyB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0aGlzLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuc3RhdGUuc2xpY2VEb2ModG9rZW4uZnJvbSwgdGhpcy5wb3MpLFxuICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSB9IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXRjaCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkaXJlY3RseSBiZWZvcmUgdGhlXG4gICAgY3Vyc29yLlxuICAgICovXG4gICAgbWF0Y2hCZWZvcmUoZXhwcikge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgdGhpcy5wb3MgLSAyNTApO1xuICAgICAgICBsZXQgc3RyID0gbGluZS50ZXh0LnNsaWNlKHN0YXJ0IC0gbGluZS5mcm9tLCB0aGlzLnBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBmb3VuZCA9IHN0ci5zZWFyY2goZW5zdXJlQW5jaG9yKGV4cHIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogeyBmcm9tOiBzdGFydCArIGZvdW5kLCB0bzogdGhpcy5wb3MsIHRleHQ6IHN0ci5zbGljZShmb3VuZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgWWllbGRzIHRydWUgd2hlbiB0aGUgcXVlcnkgaGFzIGJlZW4gYWJvcnRlZC4gQ2FuIGJlIHVzZWZ1bCBpblxuICAgIGFzeW5jaHJvbm91cyBxdWVyaWVzIHRvIGF2b2lkIGRvaW5nIHdvcmsgdGhhdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHsgcmV0dXJuIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICB0aGUgcXVlcnkgaXNcbiAgICBbYWJvcnRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbkNvbnRleHQuYWJvcnRlZCkuXG4gICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiYWJvcnRcIiAmJiB0aGlzLmFib3J0TGlzdGVuZXJzKVxuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NldChjaGFycykge1xuICAgIGxldCBmbGF0ID0gT2JqZWN0LmtleXMoY2hhcnMpLmpvaW4oXCJcIik7XG4gICAgbGV0IHdvcmRzID0gL1xcdy8udGVzdChmbGF0KTtcbiAgICBpZiAod29yZHMpXG4gICAgICAgIGZsYXQgPSBmbGF0LnJlcGxhY2UoL1xcdy9nLCBcIlwiKTtcbiAgICByZXR1cm4gYFske3dvcmRzID8gXCJcXFxcd1wiIDogXCJcIn0ke2ZsYXQucmVwbGFjZSgvW15cXHdcXHNdL2csIFwiXFxcXCQmXCIpfV1gO1xufVxuZnVuY3Rpb24gcHJlZml4TWF0Y2gob3B0aW9ucykge1xuICAgIGxldCBmaXJzdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJlc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHsgbGFiZWwgfSBvZiBvcHRpb25zKSB7XG4gICAgICAgIGZpcnN0W2xhYmVsWzBdXSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN0W2xhYmVsW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGxldCBzb3VyY2UgPSB0b1NldChmaXJzdCkgKyB0b1NldChyZXN0KSArIFwiKiRcIjtcbiAgICByZXR1cm4gW25ldyBSZWdFeHAoXCJeXCIgKyBzb3VyY2UpLCBuZXcgUmVnRXhwKHNvdXJjZSldO1xufVxuLyoqXG5HaXZlbiBhIGEgZml4ZWQgYXJyYXkgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGF1dG9jb21wbGV0ZXIgdGhhdFxuY29tcGxldGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24gY29tcGxldGVGcm9tTGlzdChsaXN0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBsaXN0Lm1hcChvID0+IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyB7IGxhYmVsOiBvIH0gOiBvKTtcbiAgICBsZXQgW3ZhbGlkRm9yLCBtYXRjaF0gPSBvcHRpb25zLmV2ZXJ5KG8gPT4gL15cXHcrJC8udGVzdChvLmxhYmVsKSkgPyBbL1xcdyokLywgL1xcdyskL10gOiBwcmVmaXhNYXRjaChvcHRpb25zKTtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXRjaCk7XG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBjb250ZXh0LmV4cGxpY2l0ID8geyBmcm9tOiB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcywgb3B0aW9ucywgdmFsaWRGb3IgfSA6IG51bGw7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG9ubHkgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmSW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpXG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KVxuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgfTtcbn1cbmNsYXNzIE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29tcGxldGlvbiwgc291cmNlLCBtYXRjaCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSBjb21wbGV0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1cihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDsgfVxuLy8gTWFrZSBzdXJlIHRoZSBnaXZlbiByZWdleHAgaGFzIGEgJCBhdCBpdHMgZW5kIGFuZCwgaWYgYHN0YXJ0YCBpc1xuLy8gdHJ1ZSwgYSBeIGF0IGl0cyBzdGFydC5cbmZ1bmN0aW9uIGVuc3VyZUFuY2hvcihleHByLCBzdGFydCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBzb3VyY2UgfSA9IGV4cHI7XG4gICAgbGV0IGFkZFN0YXJ0ID0gc3RhcnQgJiYgc291cmNlWzBdICE9IFwiXlwiLCBhZGRFbmQgPSBzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9IFwiJFwiO1xuICAgIGlmICghYWRkU3RhcnQgJiYgIWFkZEVuZClcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7YWRkU3RhcnQgPyBcIl5cIiA6IFwiXCJ9KD86JHtzb3VyY2V9KSR7YWRkRW5kID8gXCIkXCIgOiBcIlwifWAsIChfYSA9IGV4cHIuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChleHByLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpKTtcbn1cbi8qKlxuVGhpcyBhbm5vdGF0aW9uIGlzIGFkZGVkIHRvIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBwcm9kdWNlZCBieVxucGlja2luZyBhIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgcGlja2VkQ29tcGxldGlvbiA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCBpbnNlcnRzIGFcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxuc2VsZWN0aW9uIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIHRleHQgaW4gZnJvbnQgb2YgaXQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbilcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBmcm9tLCB0bzogdG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyB0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHxcbiAgICAgICAgICAgIGxlbiAmJiBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tIC0gbGVuLCByYW5nZS5mcm9tKSAhPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tIC0gbGVuLCB0bzogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tIC0gbGVuICsgdGV4dC5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgfSkpLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiIH0pO1xufVxuZnVuY3Rpb24gYXBwbHlDb21wbGV0aW9uKHZpZXcsIG9wdGlvbikge1xuICAgIGNvbnN0IGFwcGx5ID0gb3B0aW9uLmNvbXBsZXRpb24uYXBwbHkgfHwgb3B0aW9uLmNvbXBsZXRpb24ubGFiZWw7XG4gICAgbGV0IHJlc3VsdCA9IG9wdGlvbi5zb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBhcHBseSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zZXJ0Q29tcGxldGlvblRleHQodmlldy5zdGF0ZSwgYXBwbHksIHJlc3VsdC5mcm9tLCByZXN1bHQudG8pKSwgeyBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbikgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgYXBwbHkodmlldywgb3B0aW9uLmNvbXBsZXRpb24sIHJlc3VsdC5mcm9tLCByZXN1bHQudG8pO1xufVxuY29uc3QgU291cmNlQ2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFzU291cmNlKHNvdXJjZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCBrbm93biA9IFNvdXJjZUNhY2hlLmdldChzb3VyY2UpO1xuICAgIGlmICgha25vd24pXG4gICAgICAgIFNvdXJjZUNhY2hlLnNldChzb3VyY2UsIGtub3duID0gY29tcGxldGVGcm9tTGlzdChzb3VyY2UpKTtcbiAgICByZXR1cm4ga25vd247XG59XG5cbi8vIEEgcGF0dGVybiBtYXRjaGVyIGZvciBmdXp6eSBjb21wbGV0aW9uIG1hdGNoaW5nLiBDcmVhdGUgYW4gaW5zdGFuY2Vcbi8vIG9uY2UgZm9yIGEgcGF0dGVybiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gbWF0Y2ggYW55IG51bWJlciBvZlxuLy8gY29tcGxldGlvbnMuXG5jbGFzcyBGdXp6eU1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgICB0aGlzLmZvbGRlZCA9IFtdO1xuICAgICAgICAvLyBCdWZmZXJzIHJldXNlZCBieSBjYWxscyB0byBgbWF0Y2hgIHRvIHRyYWNrIG1hdGNoZWQgY2hhcmFjdGVyXG4gICAgICAgIC8vIHBvc2l0aW9ucy5cbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gW107XG4gICAgICAgIHRoaXMuYnlXb3JkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBNYXRjaGVzIGEgZ2l2ZW4gd29yZCAoY29tcGxldGlvbikgYWdhaW5zdCB0aGUgcGF0dGVybiAoaW5wdXQpLlxuICAgIC8vIFdpbGwgcmV0dXJuIG51bGwgZm9yIG5vIG1hdGNoLCBhbmQgb3RoZXJ3aXNlIGFuIGFycmF5IHRoYXQgc3RhcnRzXG4gICAgLy8gd2l0aCB0aGUgbWF0Y2ggc2NvcmUsIGZvbGxvd2VkIGJ5IGFueSBudW1iZXIgb2YgYGZyb20sIHRvYCBwYWlyc1xuICAgIC8vIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcbiAgICAgICAgLy8gRm9yIHNpbmdsZS1jaGFyYWN0ZXIgcXVlcmllcywgb25seSBtYXRjaCB3aGVuIHRoZXkgb2NjdXIgcmlnaHRcbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0XG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gY29kZVBvaW50QXQod29yZCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT0gY2hhcnNbMF0gPyBbMCwgMCwgY29kZVBvaW50U2l6ZShmaXJzdCldXG4gICAgICAgICAgICAgICAgOiBmaXJzdCA9PSBmb2xkZWRbMF0gPyBbLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovLCAwLCBjb2RlUG9pbnRTaXplKGZpcnN0KV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXJlY3QgPSB3b3JkLmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRpcmVjdCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswLCAwLCB0aGlzLnBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgbGV0IGxlbiA9IGNoYXJzLmxlbmd0aCwgYW55VG8gPSAwO1xuICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKTsgaSA8IGUgJiYgYW55VG8gPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thbnlUb10gfHwgbmV4dCA9PSBmb2xkZWRbYW55VG9dKVxuICAgICAgICAgICAgICAgICAgICBhbnlbYW55VG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGkgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG1hdGNoLCBleGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoYW55VG8gPCBsZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFja3MgdGhlIGV4dGVudCBvZiB0aGUgcHJlY2lzZSAobm9uLWZvbGRlZCwgbm90XG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGFkamFjZW50KSBtYXRjaFxuICAgICAgICBsZXQgcHJlY2lzZVRvID0gMDtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXRjaCB0aGF0IGhpdHMgb25seSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gYXBwZWFyIHRvIGJlIHN0YXJ0aW5nIHdvcmRzLiBgYnlXb3JkRm9sZGVkYCBpcyBzZXQgdG8gdHJ1ZSB3aGVuXG4gICAgICAgIC8vIGEgY2FzZSBmb2xkZWQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIHN1Y2ggYSBtYXRjaFxuICAgICAgICBsZXQgYnlXb3JkVG8gPSAwLCBieVdvcmRGb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgYSBwYXJ0aWFsIGFkamFjZW50IG1hdGNoLCB0aGVzZSB0cmFjayBpdHMgc3RhdGVcbiAgICAgICAgbGV0IGFkamFjZW50VG8gPSAwLCBhZGphY2VudFN0YXJ0ID0gLTEsIGFkamFjZW50RW5kID0gLTE7XG4gICAgICAgIGxldCBoYXNMb3dlciA9IC9bYS16XS8udGVzdCh3b3JkKSwgd29yZEFkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gR28gb3ZlciB0aGUgb3B0aW9uJ3MgdGV4dCwgc2Nhbm5pbmcgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIG1hdGNoZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKSwgcHJldlR5cGUgPSAwIC8qIFRwLk5vbldvcmQgKi87IGkgPCBlICYmIGJ5V29yZFRvIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2VUbyA8IGxlbiAmJiBuZXh0ID09IGNoYXJzW3ByZWNpc2VUb10pXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2VbcHJlY2lzZVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thZGphY2VudFRvXSB8fCBuZXh0ID09IGZvbGRlZFthZGphY2VudFRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50RW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaCwgdHlwZSA9IG5leHQgPCAweGZmXG4gICAgICAgICAgICAgICAgPyAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3IHx8IG5leHQgPj0gOTcgJiYgbmV4dCA8PSAxMjIgPyAyIC8qIFRwLkxvd2VyICovIDogbmV4dCA+PSA2NSAmJiBuZXh0IDw9IDkwID8gMSAvKiBUcC5VcHBlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLylcbiAgICAgICAgICAgICAgICA6ICgoY2ggPSBmcm9tQ29kZVBvaW50KG5leHQpKSAhPSBjaC50b0xvd2VyQ2FzZSgpID8gMSAvKiBUcC5VcHBlciAqLyA6IGNoICE9IGNoLnRvVXBwZXJDYXNlKCkgPyAyIC8qIFRwLkxvd2VyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKTtcbiAgICAgICAgICAgIGlmICghaSB8fCB0eXBlID09IDEgLyogVHAuVXBwZXIgKi8gJiYgaGFzTG93ZXIgfHwgcHJldlR5cGUgPT0gMCAvKiBUcC5Ob25Xb3JkICovICYmIHR5cGUgIT0gMCAvKiBUcC5Ob25Xb3JkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzW2J5V29yZFRvXSA9PSBuZXh0IHx8IChmb2xkZWRbYnlXb3JkVG9dID09IG5leHQgJiYgKGJ5V29yZEZvbGRlZCA9IHRydWUpKSlcbiAgICAgICAgICAgICAgICAgICAgYnlXb3JkW2J5V29yZFRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieVdvcmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3b3JkQWRqYWNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGkgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuICYmIGJ5V29yZFswXSA9PSAwICYmIHdvcmRBZGphY2VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4gJiYgYWRqYWNlbnRTdGFydCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFstMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gLSB3b3JkLmxlbmd0aCwgMCwgYWRqYWNlbnRFbmRdO1xuICAgICAgICBpZiAoZGlyZWN0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gWy03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBhZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF07XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXG4gICAgICAgICAgICAgICAgKHdvcmRBZGphY2VudCA/IDAgOiAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLyksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIHJldHVybiBjaGFycy5sZW5ndGggPT0gMiA/IG51bGwgOiB0aGlzLnJlc3VsdCgoYW55WzBdID8gLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLywgYW55LCB3b3JkKTtcbiAgICB9XG4gICAgcmVzdWx0KHNjb3JlLCBwb3NpdGlvbnMsIHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtzY29yZSAtIHdvcmQubGVuZ3RoXSwgaSA9IDE7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpID4gMSAmJiByZXN1bHRbaSAtIDFdID09IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHRbaSAtIDFdID0gdG87XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5jb25zdCBjb21wbGV0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmc6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBjb21wYXJlQ29tcGxldGlvbnM6IChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRlbGF5OiA3NVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoYSwgYikgPT4gYyA9PiBqb2luQ2xhc3MoYShjKSwgYihjKSksXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IChhLCBiKSA9PiBhLmNvbmNhdChiKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Db250ZW50KGNvbmZpZykge1xuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmFkZFRvT3B0aW9ucy5zbGljZSgpO1xuICAgIGlmIChjb25maWcuaWNvbnMpXG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uSWNvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoLi4uY29tcGxldGlvbi50eXBlLnNwbGl0KC9cXHMrL2cpLm1hcChjbHMgPT4gXCJjbS1jb21wbGV0aW9uSWNvbi1cIiArIGNscykpO1xuICAgICAgICAgICAgICAgIGljb24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAyMFxuICAgICAgICB9KTtcbiAgICBjb250ZW50LnB1c2goe1xuICAgICAgICByZW5kZXIoY29tcGxldGlvbiwgX3MsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgeyBsYWJlbCB9ID0gY29tcGxldGlvbiwgb2ZmID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbWF0Y2gubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbWF0Y2hbaisrXSwgdG8gPSBtYXRjaFtqKytdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gb2ZmKVxuICAgICAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYsIGZyb20pKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNwYW4gPSBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShmcm9tLCB0bykpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI7XG4gICAgICAgICAgICAgICAgb2ZmID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2ZmIDwgbGFiZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZikpKTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IDUwXG4gICAgfSwge1xuICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xuICAgICAgICAgICAgaWYgKCFjb21wbGV0aW9uLmRldGFpbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZXRhaWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGRldGFpbEVsdC5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25EZXRhaWxcIjtcbiAgICAgICAgICAgIGRldGFpbEVsdC50ZXh0Q29udGVudCA9IGNvbXBsZXRpb24uZGV0YWlsO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbEVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IDgwXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQuc29ydCgoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb24pLm1hcChhID0+IGEucmVuZGVyKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQXJvdW5kU2VsZWN0ZWQodG90YWwsIHNlbGVjdGVkLCBtYXgpIHtcbiAgICBpZiAodG90YWwgPD0gbWF4KVxuICAgICAgICByZXR1cm4geyBmcm9tOiAwLCB0bzogdG90YWwgfTtcbiAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICBzZWxlY3RlZCA9IDA7XG4gICAgaWYgKHNlbGVjdGVkIDw9ICh0b3RhbCA+PiAxKSkge1xuICAgICAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcihzZWxlY3RlZCAvIG1heCk7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZiAqIG1heCwgdG86IChvZmYgKyAxKSAqIG1heCB9O1xuICAgIH1cbiAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcigodG90YWwgLSBzZWxlY3RlZCkgLyBtYXgpO1xuICAgIHJldHVybiB7IGZyb206IHRvdGFsIC0gKG9mZiArIDEpICogbWF4LCB0bzogdG90YWwgLSBvZmYgKiBtYXggfTtcbn1cbmNsYXNzIENvbXBsZXRpb25Ub29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGF0ZUZpZWxkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucG9zaXRpb25JbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNvbnRlbnQgPSBvcHRpb25Db250ZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ2xhc3MgPSBjb25maWcub3B0aW9uQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gPSBlLnRhcmdldCwgbWF0Y2g7IGRvbSAmJiBkb20gIT0gdGhpcy5kb207IGRvbSA9IGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKG1hdGNoID0gLy0oXFxkKykkLy5leGVjKGRvbS5pZCkpICYmICttYXRjaFsxXSA8IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgY1N0YXRlLmlkLCB0aGlzLnJhbmdlKSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vdW50KCkgeyB0aGlzLnVwZGF0ZVNlbCgpOyB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgaWYgKGNTdGF0ZSAhPSBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgICAgICAgICBpZiAoKChfYSA9IGNTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZWQpICE9ICgoX2IgPSBwcmV2U3RhdGUub3BlbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2FibGVkKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWRcIiwgISEoKF9jID0gY1N0YXRlLm9wZW4pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNhYmxlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3Blbi5vcHRpb25zLmxlbmd0aCwgb3Blbi5zZWxlY3RlZCwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3Blbi5vcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24gfSA9IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpbmZvKSA6IGluZm8oY29tcGxldGlvbik7XG4gICAgICAgICAgICBpZiAoIWluZm9SZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCd0aGVuJyBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCBmYWxzZSkgPT0gY1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbmZvUGFuZShub2RlKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mb1wiO1xuICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIGxldCBzZXQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBvcHQgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZCwgaSA9IHRoaXMucmFuZ2UuZnJvbTsgb3B0OyBvcHQgPSBvcHQubmV4dFNpYmxpbmcsIGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3B0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldClcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMubGlzdCwgc2V0KTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgbWVhc3VyZUluZm8oKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbS5xdWVyeVNlbGVjdG9yKFwiW2FyaWEtc2VsZWN0ZWRdXCIpO1xuICAgICAgICBpZiAoIXNlbCB8fCAhdGhpcy5pbmZvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsaXN0UmVjdCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgaW5mb1JlY3QgPSB0aGlzLmluZm8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzZWxSZWN0ID0gc2VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc3BhY2UgPSB0aGlzLnNwYWNlO1xuICAgICAgICBpZiAoIXNwYWNlKSB7XG4gICAgICAgICAgICBsZXQgd2luID0gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgICAgICAgICBzcGFjZSA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbFJlY3QudG9wID4gTWF0aC5taW4oc3BhY2UuYm90dG9tLCBsaXN0UmVjdC5ib3R0b20pIC0gMTAgfHxcbiAgICAgICAgICAgIHNlbFJlY3QuYm90dG9tIDwgTWF0aC5tYXgoc3BhY2UudG9wLCBsaXN0UmVjdC50b3ApICsgMTApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJ0bCA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlLCBtYXhXaWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IFwiXCIsIGJvdHRvbSA9IFwiXCI7XG4gICAgICAgIGxldCBzcGFjZUxlZnQgPSBsaXN0UmVjdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdFJlY3QucmlnaHQ7XG4gICAgICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9SZWN0LndpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIWxlZnQgJiYgc3BhY2VSaWdodCA8IE1hdGgubWluKGluZm9SZWN0LndpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICAgICAgbGVmdCA9IHRydWU7XG4gICAgICAgIGlmIChpbmZvUmVjdC53aWR0aCA8PSAobGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpKSB7XG4gICAgICAgICAgICB0b3AgPSAoTWF0aC5tYXgoc3BhY2UudG9wLCBNYXRoLm1pbihzZWxSZWN0LnRvcCwgc3BhY2UuYm90dG9tIC0gaW5mb1JlY3QuaGVpZ2h0KSkgLSBsaXN0UmVjdC50b3ApICsgXCJweFwiO1xuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4oNDAwIC8qIEluZm8uV2lkdGggKi8sIChydGwgPyBsaXN0UmVjdC5yaWdodCA6IHNwYWNlLnJpZ2h0IC0gbGlzdFJlY3QubGVmdCkgLSAzMCAvKiBJbmZvLk1hcmdpbiAqLykgKyBcInB4XCI7XG4gICAgICAgICAgICBsZXQgc3BhY2VCZWxvdyA9IHNwYWNlLmJvdHRvbSAtIGxpc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9SZWN0LmhlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdFJlY3QudG9wKSAvLyBCZWxvdyB0aGUgY29tcGxldGlvblxuICAgICAgICAgICAgICAgIHRvcCA9IChzZWxSZWN0LmJvdHRvbSAtIGxpc3RSZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHNlIC8vIEFib3ZlIGl0XG4gICAgICAgICAgICAgICAgYm90dG9tID0gKGxpc3RSZWN0LmJvdHRvbSAtIHNlbFJlY3QudG9wKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLCBib3R0b20sIG1heFdpZHRoLFxuICAgICAgICAgICAgY2xhc3M6IG5hcnJvdyA/IChydGwgPyBcImxlZnQtbmFycm93XCIgOiBcInJpZ2h0LW5hcnJvd1wiKSA6IGxlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcG9zaXRpb25JbmZvKHBvcykge1xuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLnRvcCA9IHBvcy50b3A7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLmJvdHRvbSA9IHBvcy5ib3R0b207XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLm1heFdpZHRoID0gcG9zLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm8gY20tY29tcGxldGlvbkluZm8tXCIgKyBwb3MuY2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUudG9wID0gXCItMWU2cHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGlkLCByYW5nZSkge1xuICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcbiAgICAgICAgdWwuaWQgPSBpZDtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImxpc3Rib3hcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJDb21wbGV0aW9uc1wiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5nZS5mcm9tOyBpIDwgcmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiwgbWF0Y2ggfSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5mcm9tKVxuICAgICAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKTtcbiAgICAgICAgaWYgKHJhbmdlLnRvIDwgb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tXCIpO1xuICAgICAgICByZXR1cm4gdWw7XG4gICAgfVxufVxuLy8gV2UgYWxsb2NhdGUgYSBuZXcgZnVuY3Rpb24gaW5zdGFuY2UgZXZlcnkgdGltZSB0aGUgY29tcGxldGlvblxuLy8gY2hhbmdlcyB0byBmb3JjZSByZWRyYXdpbmcvcmVwb3NpdGlvbmluZyBvZiB0aGUgdG9vbHRpcFxuZnVuY3Rpb24gY29tcGxldGlvblRvb2x0aXAoc3RhdGVGaWVsZCkge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQpO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSBwYXJlbnQudG9wIC0gc2VsZi50b3A7XG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbTtcbn1cblxuLy8gVXNlZCB0byBwaWNrIGEgcHJlZmVycmVkIG9wdGlvbiB3aGVuIHR3byBvcHRpb25zIHdpdGggdGhlIHNhbWVcbi8vIGxhYmVsIG9jY3VyIGluIHRoZSByZXN1bHQuXG5mdW5jdGlvbiBzY29yZShvcHRpb24pIHtcbiAgICByZXR1cm4gKG9wdGlvbi5ib29zdCB8fCAwKSAqIDEwMCArIChvcHRpb24uYXBwbHkgPyAxMCA6IDApICsgKG9wdGlvbi5pbmZvID8gNSA6IDApICtcbiAgICAgICAgKG9wdGlvbi50eXBlID8gMSA6IDApO1xufVxuZnVuY3Rpb24gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSkge1xuICAgIGxldCBvcHRpb25zID0gW10sIGkgPSAwO1xuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxuICAgICAgICBpZiAoYS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgaWYgKGEucmVzdWx0LmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBbMWU5IC0gaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldE1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbiBvZiBnZXRNYXRjaChvcHRpb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChuZXcgT3B0aW9uKG9wdGlvbiwgYSwgbWF0Y2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlciA9IG5ldyBGdXp6eU1hdGNoZXIoc3RhdGUuc2xpY2VEb2MoYS5mcm9tLCBhLnRvKSksIG1hdGNoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uYm9vc3QgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSArPSBvcHRpb24uYm9vc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gobmV3IE9wdGlvbihvcHRpb24sIGEsIG1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGxldCByZXN1bHQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgbGV0IGNvbXBhcmUgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jb21wYXJlQ29tcGxldGlvbnM7XG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIubWF0Y2hbMF0gLSBhLm1hdGNoWzBdKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcbiAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYubGFiZWwgIT0gb3B0LmNvbXBsZXRpb24ubGFiZWwgfHwgcHJldi5kZXRhaWwgIT0gb3B0LmNvbXBsZXRpb24uZGV0YWlsIHx8XG4gICAgICAgICAgICAocHJldi50eXBlICE9IG51bGwgJiYgb3B0LmNvbXBsZXRpb24udHlwZSAhPSBudWxsICYmIHByZXYudHlwZSAhPSBvcHQuY29tcGxldGlvbi50eXBlKSB8fFxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBvcHQuY29tcGxldGlvbi5hcHBseSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdCk7XG4gICAgICAgIGVsc2UgaWYgKHNjb3JlKG9wdC5jb21wbGV0aW9uKSA+IHNjb3JlKHByZXYpKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcbiAgICAgICAgcHJldiA9IG9wdC5jb21wbGV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQ29tcGxldGlvbkRpYWxvZyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYsIGNvbmYpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXYgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykgP1xuICAgICAgICAgICAgICAgIG5ldyBDb21wbGV0aW9uRGlhbG9nKHByZXYub3B0aW9ucywgcHJldi5hdHRycywgcHJldi50b29sdGlwLCBwcmV2LnRpbWVzdGFtcCwgcHJldi5zZWxlY3RlZCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnNlbGVjdE9uT3BlbiA/IDAgOiAtMTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldi5zZWxlY3RlZCAhPSBzZWxlY3RlZCAmJiBwcmV2LnNlbGVjdGVkICE9IC0xKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByZXYub3B0aW9uc1twcmV2LnNlbGVjdGVkXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLmNvbXBsZXRpb24gPT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2cob3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHtcbiAgICAgICAgICAgIHBvczogYWN0aXZlLnJlZHVjZSgoYSwgYikgPT4gYi5oYXNSZXN1bHQoKSA/IE1hdGgubWluKGEsIGIuZnJvbSkgOiBhLCAxZTgpLFxuICAgICAgICAgICAgY3JlYXRlOiBjb21wbGV0aW9uVG9vbHRpcChjb21wbGV0aW9uU3RhdGUpLFxuICAgICAgICAgICAgYWJvdmU6IGNvbmYuYWJvdmVDdXJzb3IsXG4gICAgICAgIH0sIHByZXYgPyBwcmV2LnRpbWVzdGFtcCA6IERhdGUubm93KCksIHNlbGVjdGVkLCBmYWxzZSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIHRoaXMuYXR0cnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50b29sdGlwKSwgeyBwb3M6IGNoYW5nZXMubWFwUG9zKHRoaXMudG9vbHRpcC5wb3MpIH0pLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGxldGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGlkLCBvcGVuKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uU3RhdGUobm9uZSwgXCJjbS1hYy1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDJlNikudG9TdHJpbmcoMzYpLCBudWxsKTtcbiAgICB9XG4gICAgdXBkYXRlKHRyKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgY29uZiA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBsZXQgc291cmNlcyA9IGNvbmYub3ZlcnJpZGUgfHxcbiAgICAgICAgICAgIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiYXV0b2NvbXBsZXRlXCIsIGN1cihzdGF0ZSkpLm1hcChhc1NvdXJjZSk7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzb3VyY2VzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5hY3RpdmUuZmluZChzID0+IHMuc291cmNlID09IHNvdXJjZSkgfHxcbiAgICAgICAgICAgICAgICBuZXcgQWN0aXZlU291cmNlKHNvdXJjZSwgdGhpcy5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggPT0gdGhpcy5hY3RpdmUubGVuZ3RoICYmIGFjdGl2ZS5ldmVyeSgoYSwgaSkgPT4gYSA9PSB0aGlzLmFjdGl2ZVtpXSkpXG4gICAgICAgICAgICBhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLm9wZW47XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24gfHwgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGEuZnJvbSwgYS50bykpIHx8XG4gICAgICAgICAgICAhc2FtZVJlc3VsdHMoYWN0aXZlLCB0aGlzLmFjdGl2ZSkpXG4gICAgICAgICAgICBvcGVuID0gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCB0aGlzLm9wZW4sIGNvbmYpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICBvcGVuID0gb3Blbi5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiBhLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLykgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS5tYXAoYSA9PiBhLmhhc1Jlc3VsdCgpID8gbmV3IEFjdGl2ZVNvdXJjZShhLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgOiBhKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlbGVjdGVkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBvcGVuID0gb3BlbiAmJiBvcGVuLnNldFNlbGVjdGVkKGVmZmVjdC52YWx1ZSwgdGhpcy5pZCk7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5hY3RpdmUgJiYgb3BlbiA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IENvbXBsZXRpb25TdGF0ZShhY3RpdmUsIHRoaXMuaWQsIG9wZW4pO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi50b29sdGlwIDogbnVsbDsgfVxuICAgIGdldCBhdHRycygpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi5hdHRycyA6IGJhc2VBdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlBKys7XG4gICAgICAgIHdoaWxlIChpQiA8IGIubGVuZ3RoICYmICFiW2lCXS5oYXNSZXN1bHQpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVzZXJFdmVudCh0cikge1xuICAgIHJldHVybiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgPyBcImlucHV0XCIgOiB0ci5pc1VzZXJFdmVudChcImRlbGV0ZS5iYWNrd2FyZFwiKSA/IFwiZGVsZXRlXCIgOiBudWxsO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdFBvcyA9IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXRQb3MgPSBleHBsaWNpdFBvcztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gZ2V0VXNlckV2ZW50KHRyKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZVVzZXJFdmVudCh0ciwgZXZlbnQsIGNvbmYpO1xuICAgICAgICBlbHNlIGlmICh0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVDaGFuZ2UodHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24gJiYgdmFsdWUuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlID8gY3VyKHRyLnN0YXRlKSA6IC0xKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyRXZlbnQodHIsIHR5cGUsIGNvbmYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJkZWxldGVcIiB8fCAhY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gdGhpcy5tYXAodHIuY2hhbmdlcykgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGFydFN0YXRlKSkgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHRoaXMgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0aGlzLnN0YXRlLCBjaGFuZ2VzLm1hcFBvcyh0aGlzLmV4cGxpY2l0UG9zKSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlUmVzdWx0IGV4dGVuZHMgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGV4cGxpY2l0UG9zLCByZXN1bHQsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMiAvKiBTdGF0ZS5SZXN1bHQgKi8sIGV4cGxpY2l0UG9zKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmICgodGhpcy5leHBsaWNpdFBvcyA8IDAgPyBwb3MgPD0gZnJvbSA6IHBvcyA8IHRoaXMuZnJvbSkgfHxcbiAgICAgICAgICAgIHBvcyA+IHRvIHx8XG4gICAgICAgICAgICB0eXBlID09IFwiZGVsZXRlXCIgJiYgY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlID09IFwiaW5wdXRcIiAmJiBjb25mLmFjdGl2YXRlT25UeXBpbmcgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgbGV0IGV4cGxpY2l0UG9zID0gdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB1cGRhdGVkO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZCh0aGlzLnJlc3VsdC52YWxpZEZvciwgdHIuc3RhdGUsIGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdGhpcy5yZXN1bHQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHVwZGF0ZWQgPSB0aGlzLnJlc3VsdC51cGRhdGUodGhpcy5yZXN1bHQsIGZyb20sIHRvLCBuZXcgQ29tcGxldGlvbkNvbnRleHQodHIuc3RhdGUsIHBvcywgZXhwbGljaXRQb3MgPj0gMCkpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdXBkYXRlZCwgdXBkYXRlZC5mcm9tLCAoX2EgPSB1cGRhdGVkLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIodHIuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZXhwbGljaXRQb3MpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbWFwcGluZy5lbXB0eSA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IG1hcHBpbmcubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB0aGlzLnJlc3VsdCwgbWFwcGluZy5tYXBQb3ModGhpcy5mcm9tKSwgbWFwcGluZy5tYXBQb3ModGhpcy50bywgMSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQodmFsaWRGb3IsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGlmICghdmFsaWRGb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbGlkRm9yID09IFwiZnVuY3Rpb25cIiA/IHZhbGlkRm9yKHRleHQsIGZyb20sIHRvLCBzdGF0ZSkgOiBlbnN1cmVBbmNob3IodmFsaWRGb3IsIHRydWUpLnRlc3QodGV4dCk7XG59XG5jb25zdCBzdGFydENvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZUNvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAoc291cmNlcywgbWFwcGluZykgeyByZXR1cm4gc291cmNlcy5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSk7IH1cbn0pO1xuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjb21wbGV0aW9uU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIENvbXBsZXRpb25TdGF0ZS5zdGFydCgpOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHsgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0cik7IH0sXG4gICAgcHJvdmlkZTogZiA9PiBbXG4gICAgICAgIHNob3dUb29sdGlwLmZyb20oZiwgdmFsID0+IHZhbC50b29sdGlwKSxcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxuICAgIF1cbn0pO1xuXG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgbW92ZXMgdGhlIGNvbXBsZXRpb24gc2VsZWN0aW9uIGZvcndhcmQgb3JcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4qL1xuZnVuY3Rpb24gbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZm9yd2FyZCwgYnkgPSBcIm9wdGlvblwiKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gMSwgdG9vbHRpcDtcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY2NlcHQgdGhlIGN1cnJlbnQgY29tcGxldGlvbi5cbiovXG5jb25zdCBhY2NlcHRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHxcbiAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY1N0YXRlLm9wZW4uZGlzYWJsZWQpXG4gICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBjU3RhdGUub3Blbi5vcHRpb25zW2NTdGF0ZS5vcGVuLnNlbGVjdGVkXSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBsaWNpdGx5IHN0YXJ0IGF1dG9jb21wbGV0aW9uLlxuKi9cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKHRydWUpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcGxldGlvbi5cbiovXG5jb25zdCBjbG9zZUNvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jbGFzcyBSdW5uaW5nUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIC8vIE5vdGUgdGhhdCAndW5kZWZpbmVkJyBtZWFucyAnbm90IGRvbmUgeWV0Jywgd2hlcmVhcyAnbnVsbCcgbWVhbnNcbiAgICAgICAgLy8gJ3F1ZXJ5IHJldHVybmVkIG51bGwnLlxuICAgICAgICB0aGlzLmRvbmUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY29uc3QgRGVib3VuY2VUaW1lID0gNTAsIE1heFVwZGF0ZUNvdW50ID0gNTAsIE1pbkFib3J0VGltZSA9IDEwMDA7XG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgIWdldFVzZXJFdmVudCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCBEZWJvdW5jZVRpbWUpIDogLTE7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAhPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLylcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VXNlckV2ZW50KHRyKSA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0UG9zID09IHBvcyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcuZXZlcnkocSA9PiBxLmRvbmUgIT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIERlYm91bmNlVGltZSk7XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAgIC8vIG9yLCBpZiBhcHByb3ByaWF0ZSwgcmVzdGFydCB0aGUgcXVlcnkuXG4gICAgYWNjZXB0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0ID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUFjY2VwdCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXRQb3MsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKSk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBhbmQgc2VlIGlmIHRoYXQgcHJlc2VydmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGJsdXIoKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIENvbXBvc2l0aW9uU3RhdGUuU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGluc2lkZSBhbiB1cGRhdGUsIHNvIGRpc3BhdGNoIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZihmYWxzZSkgfSksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm1pbig3MDBweCwgOTV2dylcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjI1MHB4XCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxuICAgICAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggM3B4XCIsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiXHUwMEI3XHUwMEI3XHUwMEI3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTAxOTInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY2xhc3NcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTI1Q0InXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24taW50ZXJmYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUNDJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXZhcmlhYmxlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHVEODM1XHVEQzY1J1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHVEODM1XHVEQzM2J1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXR5cGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdUQ4MzVcdURDNjEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZW51bVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjIyQSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1wcm9wZXJ0eVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjVBMSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1rZXl3b3JkXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHVEODNEXHVERDExXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTI1QTInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20sIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIHJldHVybiBmcm9tID09IG51bGwgfHwgdG8gPT0gbnVsbCA/IG51bGwgOiBuZXcgRmllbGRSYW5nZSh0aGlzLmZpZWxkLCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCBuYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgbmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVzYzsgZXNjID0gLyhbJCNdKVxcXFx7Ly5leGVjKGxpbmUpOykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGVzYy5pbmRleCkgKyBlc2NbMV0gKyBcIntcIiArIGxpbmUuc2xpY2UoZXNjLmluZGV4ICsgZXNjWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5saW5lID09IGxpbmVzLmxlbmd0aCAmJiBwb3MuZnJvbSA+IGVzYy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU25pcHBldChsaW5lcywgcG9zaXRpb25zKTtcbiAgICB9XG59XG5sZXQgZmllbGRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNuaXBwZXRGaWVsZFwiIH0pO1xuY2xhc3MgQWN0aXZlU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNuaXBwZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogRGVjb3JhdGlvbi5ub25lKVxufSk7XG5mdW5jdGlvbiBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmZpbHRlcihyID0+IHIuZmllbGQgPT0gZmllbGQpLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSk7XG59XG4vKipcbkNvbnZlcnQgYSBzbmlwcGV0IHRlbXBsYXRlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW5cblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXG51c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXG5cbkVhY2ggYCR7fWAgcGxhY2Vob2xkZXIgKHlvdSBtYXkgYWxzbyB1c2UgYCN7fWApIGluZGljYXRlcyBhIGZpZWxkXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XG5jb250ZW50IGZvciB0aGUgZmllbGQuXG5cbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxudGhlIGNvZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBOZXdsaW5lcyBpbiB0aGVcbnRlbXBsYXRlIGFyZSBpbmRlbnRlZCBieSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN0YXJ0IGxpbmUsIHBsdXNcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcbnRoZSBuZXdsaW5lLlxuXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cblRoZSB1c2VyIGNhbiBtb3ZlIGJldHdlZW4gZmllbGRzIHdpdGggVGFiIGFuZCBTaGlmdC1UYWIgYXMgbG9uZyBhc1xudGhlIGZpZWxkcyBhcmUgYWN0aXZlLiBNb3ZpbmcgdG8gdGhlIGxhc3QgZmllbGQgb3IgbW92aW5nIHRoZVxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxuXG5UaGUgb3JkZXIgb2YgZmllbGRzIGRlZmF1bHRzIHRvIHRleHR1YWwgb3JkZXIsIGJ1dCB5b3UgY2FuIGFkZFxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcbmEgY3VzdG9tIG9yZGVyLlxuXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBgJHtgIG9yIGAje2AgaW4geW91ciB0ZW1wbGF0ZSwgcHV0IGFcbmJhY2tzbGFzaCBhZnRlciB0aGUgZG9sbGFyIG9yIGhhc2ggYW5kIGJlZm9yZSB0aGUgYnJhY2UgKGAkXFxcXHtgKS5cblRoaXMgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgc2VxdWVuY2Ugd2lsbCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYVxucGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIF9jb21wbGV0aW9uLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICBsZXQgeyB0ZXh0LCByYW5nZXMgfSA9IHNuaXBwZXQuaW5zdGFudGlhdGUoZWRpdG9yLnN0YXRlLCBmcm9tKTtcbiAgICAgICAgbGV0IHNwZWMgPSB7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YodGV4dCkgfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYy5zZWxlY3Rpb24gPSBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIDApO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIDApO1xuICAgICAgICAgICAgbGV0IGVmZmVjdHMgPSBzcGVjLmVmZmVjdHMgPSBbc2V0QWN0aXZlLm9mKGFjdGl2ZSldO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW3NuaXBwZXRTdGF0ZSwgYWRkU25pcHBldEtleW1hcCwgc25pcHBldFBvaW50ZXJIYW5kbGVyLCBiYXNlVGhlbWVdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGVkaXRvci5zdGF0ZS51cGRhdGUoc3BlYykpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlRmllbGQoZGlyKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyIDwgMCAmJiBhY3RpdmUuYWN0aXZlID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0ID0gYWN0aXZlLmFjdGl2ZSArIGRpciwgbGFzdCA9IGRpciA+IDAgJiYgIWFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gbmV4dCArIGRpcik7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG5leHQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGxhc3QgPyBudWxsIDogbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbmV4dCkpXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIHRoYXQgY2xlYXJzIHRoZSBhY3RpdmUgc25pcHBldCwgaWYgYW55LlxuKi9cbmNvbnN0IGNsZWFyU25pcHBldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgZWZmZWN0czogc2V0QWN0aXZlLm9mKG51bGwpIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IG5leHRTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB3b3JkUkUod29yZENoYXJzKSB7XG4gICAgbGV0IGVzY2FwZWQgPSB3b3JkQ2hhcnMucmVwbGFjZSgvW1xcXFxbLisqPygpe3xeJF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB2YWx1ZS5sZW5ndGggKyAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RXb3Jkcyhkb2MsIGNhY2hlLCB3b3JkUkUsIHRvLCBpZ25vcmVBdCkge1xuICAgIGxldCBiaWcgPSBkb2MubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLztcbiAgICBsZXQgY2FjaGVkID0gYmlnICYmIGNhY2hlLmdldChkb2MpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgIGNhY2hlLnNldChkb2MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuQSBjb21wbGV0aW9uIHNvdXJjZSB0aGF0IHdpbGwgc2NhbiB0aGUgZG9jdW1lbnQgZm9yIHdvcmRzICh1c2luZyBhXG5bY2hhcmFjdGVyIGNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikpLCBhbmRcbnJldHVybiB0aG9zZSBhcyBjb21wbGV0aW9ucy5cbiovXG5jb25zdCBjb21wbGV0ZUFueVdvcmQgPSBjb250ZXh0ID0+IHtcbiAgICBsZXQgd29yZENoYXJzID0gY29udGV4dC5zdGF0ZS5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBjb250ZXh0LnBvcykuam9pbihcIlwiKTtcbiAgICBsZXQgcmUgPSB3b3JkUkUod29yZENoYXJzKTtcbiAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hcFJFKHJlLCBzID0+IHMgKyBcIiRcIikpO1xuICAgIGlmICghdG9rZW4gJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3M7XG4gICAgbGV0IG9wdGlvbnMgPSBjb2xsZWN0V29yZHMoY29udGV4dC5zdGF0ZS5kb2MsIHdvcmRDYWNoZSh3b3JkQ2hhcnMpLCByZSwgNTAwMDAgLyogQy5SYW5nZSAqLywgZnJvbSk7XG4gICAgcmV0dXJuIHsgZnJvbSwgb3B0aW9ucywgdmFsaWRGb3I6IG1hcFJFKHJlLCBzID0+IFwiXlwiICsgcykgfTtcbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICAgIGJlZm9yZTogXCIpXX06Oz5cIixcbiAgICBzdHJpbmdQcmVmaXhlczogW11cbn07XG5jb25zdCBjbG9zZUJyYWNrZXRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IG1hcHBpbmcubWFwUG9zKHZhbHVlLCAtMSwgTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWFwcGVkO1xuICAgIH1cbn0pO1xuY29uc3Qgc2tpcEJyYWNrZXRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHsgcmV0dXJuIG1hcHBpbmcubWFwUG9zKHZhbHVlKTsgfVxufSk7XG5jb25zdCBjbG9zZWRCcmFja2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFJhbmdlVmFsdWUge1xufTtcbmNsb3NlZEJyYWNrZXQuc3RhcnRTaWRlID0gMTtcbmNsb3NlZEJyYWNrZXQuZW5kU2lkZSA9IC0xO1xuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBsZXQgcHJldkxpbmVTdGFydCA9IHRyLnN0YXJ0U3RhdGUuZG9jLmxpbmVBdCh0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ICE9IHRyLmNoYW5nZXMubWFwUG9zKHByZXZMaW5lU3RhcnQsIC0xKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFJhbmdlU2V0LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhza2lwQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBmaWx0ZXI6IGZyb20gPT4gZnJvbSAhPSBlZmZlY3QudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIGJyYWNrZXQtY2xvc2luZyBiZWhhdmlvci4gV2hlbiBhIGNsb3NlYWJsZVxuYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxuYWZ0ZXIgdGhlIGN1cnNvci4gV2hlbiBjbG9zaW5nIGEgYnJhY2tldCBkaXJlY3RseSBpbiBmcm9udCBvZiBhXG5jbG9zaW5nIGJyYWNrZXQgaW5zZXJ0ZWQgYnkgdGhlIGV4dGVuc2lvbiwgdGhlIGN1cnNvciBtb3ZlcyBvdmVyXG50aGF0IGJyYWNrZXQuXG4qL1xuZnVuY3Rpb24gY2xvc2VCcmFja2V0cygpIHtcbiAgICByZXR1cm4gW2lucHV0SGFuZGxlciwgYnJhY2tldFN0YXRlXTtcbn1cbmNvbnN0IGRlZmluZWRDbG9zaW5nID0gXCIoKVtde308PlwiO1xuZnVuY3Rpb24gY2xvc2luZyhjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmaW5lZENsb3NpbmcubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChkZWZpbmVkQ2xvc2luZy5jaGFyQ29kZUF0KGkpID09IGNoKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRDbG9zaW5nLmNoYXJBdChpICsgMSk7XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY2ggPCAxMjggPyBjaCA6IGNoICsgMSk7XG59XG5mdW5jdGlvbiBjb25maWcoc3RhdGUsIHBvcykge1xuICAgIHJldHVybiBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNsb3NlQnJhY2tldHNcIiwgcG9zKVswXSB8fCBkZWZhdWx0cztcbn1cbmNvbnN0IGFuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgaW5zZXJ0KSA9PiB7XG4gICAgaWYgKChhbmRyb2lkID8gdmlldy5jb21wb3NpbmcgOiB2aWV3LmNvbXBvc2l0aW9uU3RhcnRlZCkgfHwgdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChpbnNlcnQubGVuZ3RoID4gMiB8fCBpbnNlcnQubGVuZ3RoID09IDIgJiYgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChpbnNlcnQsIDApKSA9PSAxIHx8XG4gICAgICAgIGZyb20gIT0gc2VsLmZyb20gfHwgdG8gIT0gc2VsLnRvKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRyID0gaW5zZXJ0QnJhY2tldCh2aWV3LnN0YXRlLCBpbnNlcnQpO1xuICAgIGlmICghdHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgaW1wbGVtZW50cyBkZWxldGluZyBhIHBhaXIgb2YgbWF0Y2hpbmcgYnJhY2tldHMgd2hlblxudGhlIGN1cnNvciBpcyBiZXR3ZWVuIHRoZW0uXG4qL1xuY29uc3QgZGVsZXRlQnJhY2tldFBhaXIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gcHJldkNoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBiZWZvcmUgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zaW5nKGNvZGVQb2ludEF0KHRva2VuLCAwKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCwgdG86IHJhbmdlLmhlYWQgKyB0b2tlbi5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmICghZG9udClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUuYmFja3dhcmRcIiB9KSk7XG4gICAgcmV0dXJuICFkb250O1xufTtcbi8qKlxuQ2xvc2UtYnJhY2tldHMgcmVsYXRlZCBrZXkgYmluZGluZ3MuIEJpbmRzIEJhY2tzcGFjZSB0b1xuW2BkZWxldGVCcmFja2V0UGFpcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmRlbGV0ZUJyYWNrZXRQYWlyKS5cbiovXG5jb25zdCBjbG9zZUJyYWNrZXRzS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUJyYWNrZXRQYWlyIH1cbl07XG4vKipcbkltcGxlbWVudHMgdGhlIGV4dGVuc2lvbidzIGJlaGF2aW9yIG9uIHRleHQgaW5zZXJ0aW9uLiBJZiB0aGVcbmdpdmVuIHN0cmluZyBjb3VudHMgYXMgYSBicmFja2V0IGluIHRoZSBsYW5ndWFnZSBhcm91bmQgdGhlXG5zZWxlY3Rpb24sIGFuZCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGl0IHJlcXVpcmVzIGN1c3RvbVxuYmVoYXZpb3IgKGluc2VydGluZyBhIGNsb3NpbmcgdmVyc2lvbiBvciBza2lwcGluZyBwYXN0IGFcbnByZXZpb3VzbHktY2xvc2VkIGJyYWNrZXQpLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50aW5nIHRoYXQgY3VzdG9tIGJlaGF2aW9yLiAoWW91IG9ubHkgbmVlZCB0aGlzIGlmIHlvdSB3YW50XG50byBwcm9ncmFtbWF0aWNhbGx5IGluc2VydCBicmFja2V0c1x1MjAxNHRoZVxuW2BjbG9zZUJyYWNrZXRzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VCcmFja2V0cykgZXh0ZW5zaW9uIHdpbGxcbnRha2UgY2FyZSBvZiBydW5uaW5nIHRoaXMgZm9yIHVzZXIgaW5wdXQuKVxuKi9cbmZ1bmN0aW9uIGluc2VydEJyYWNrZXQoc3RhdGUsIGJyYWNrZXQpIHtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgZm9yIChsZXQgdG9rIG9mIHRva2Vucykge1xuICAgICAgICBsZXQgY2xvc2VkID0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2ssIDApKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gdG9rKVxuICAgICAgICAgICAgcmV0dXJuIGNsb3NlZCA9PSB0b2sgPyBoYW5kbGVTYW1lKHN0YXRlLCB0b2ssIHRva2Vucy5pbmRleE9mKHRvayArIHRvayArIHRvaykgPiAtMSwgY29uZilcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU9wZW4oc3RhdGUsIHRvaywgY2xvc2VkLCBjb25mLmJlZm9yZSB8fCBkZWZhdWx0cy5iZWZvcmUpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSBjbG9zZWQgJiYgY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDbG9zZShzdGF0ZSwgdG9rLCBjbG9zZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgc3RhdGUuZmllbGQoYnJhY2tldFN0YXRlKS5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIGZyb20gPT4ge1xuICAgICAgICBpZiAoZnJvbSA9PSBwb3MpXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbmV4dENoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgbmV4dCA9IGRvYy5zbGljZVN0cmluZyhwb3MsIHBvcyArIDIpO1xuICAgIHJldHVybiBuZXh0LnNsaWNlKDAsIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQobmV4dCwgMCkpKTtcbn1cbmZ1bmN0aW9uIHByZXZDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IHByZXYgPSBkb2Muc2xpY2VTdHJpbmcocG9zIC0gMiwgcG9zKTtcbiAgICByZXR1cm4gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChwcmV2LCAwKSkgPT0gcHJldi5sZW5ndGggPyBwcmV2IDogcHJldi5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wZW4oc3RhdGUsIG9wZW4sIGNsb3NlLCBjbG9zZUJlZm9yZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiBvcGVuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiBjbG9zZSwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgb3Blbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICBpZiAoIW5leHQgfHwgL1xccy8udGVzdChuZXh0KSB8fCBjbG9zZUJlZm9yZS5pbmRleE9mKG5leHQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogb3BlbiArIGNsb3NlLCBmcm9tOiByYW5nZS5oZWFkIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsb3NlKHN0YXRlLCBfb3BlbiwgY2xvc2UpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIG1vdmVkID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZG9udCA9IHJhbmdlO1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShtb3ZlZCwgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLm1hcCgoeyBmcm9tIH0pID0+IHNraXBCcmFja2V0RWZmZWN0Lm9mKGZyb20pKVxuICAgIH0pO1xufVxuLy8gSGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgb3BlbiBhbmQgY2xvc2UgdG9rZW4gYXJlIHRoZSBzYW1lLCBhbmRcbi8vIHBvc3NpYmx5IHRyaXBsZSBxdW90ZXMgKGFzIGluIGBcIlwiXCJhYmNcIlwiXCJgLXN0eWxlIHF1b3RpbmcpLlxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHBvcyksIHN0YXJ0O1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCAqIChpc1RyaXBsZSA/IDMgOiAxKSksXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IHNraXBCcmFja2V0RWZmZWN0Lm9mKHBvcykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBwb3MpID09IHRva2VuICsgdG9rZW4gJiZcbiAgICAgICAgICAgIChzdGFydCA9IGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlLCBzdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuICsgdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAoY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBzdHJpbmdQcmVmaXhlcykgPiAtMSAmJiAhcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCB0b2tlbiwgc3RyaW5nUHJlZml4ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFydChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zICsgMSk7XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIHRyZWUuZnJvbSA9PSBwb3M7XG59XG5mdW5jdGlvbiBwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHF1b3RlVG9rZW4sIHByZWZpeGVzKSB7XG4gICAgbGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgbGV0IG1heFByZWZpeCA9IHByZWZpeGVzLnJlZHVjZSgobSwgcCkgPT4gTWF0aC5tYXgobSwgcC5sZW5ndGgpLCAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIE1hdGgubWluKG5vZGUudG8sIG5vZGUuZnJvbSArIHF1b3RlVG9rZW4ubGVuZ3RoICsgbWF4UHJlZml4KSk7XG4gICAgICAgIGxldCBxdW90ZVBvcyA9IHN0YXJ0LmluZGV4T2YocXVvdGVUb2tlbik7XG4gICAgICAgIGlmICghcXVvdGVQb3MgfHwgcXVvdGVQb3MgPiAtMSAmJiBwcmVmaXhlcy5pbmRleE9mKHN0YXJ0LnNsaWNlKDAsIHF1b3RlUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGZpcnN0ICYmIGZpcnN0LmZyb20gPT0gbm9kZS5mcm9tICYmIGZpcnN0LnRvIC0gZmlyc3QuZnJvbSA+IHF1b3RlVG9rZW4ubGVuZ3RoICsgcXVvdGVQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2MoZmlyc3QudG8gLSBxdW90ZVRva2VuLmxlbmd0aCwgZmlyc3QudG8pID09IHF1b3RlVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZpcnN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS50byA9PSBwb3MgJiYgbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgcHJlZml4ZXMpIHtcbiAgICBsZXQgY2hhckNhdCA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGlmIChjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGZvciAobGV0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUuc2xpY2VEb2Moc3RhcnQgLSAxLCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGF1dG9jb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29tcGxldGlvblN0YXRlLFxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGNvbXBsZXRpb25QbHVnaW4sXG4gICAgICAgIGNvbXBsZXRpb25LZXltYXBFeHQsXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF07XG59XG4vKipcbkJhc2ljIGtleWJpbmRpbmdzIGZvciBhdXRvY29tcGxldGlvbi5cblxuIC0gQ3RybC1TcGFjZTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUpIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSkgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogYWNjZXB0Q29tcGxldGlvbiB9XG5dO1xuY29uc3QgY29tcGxldGlvbktleW1hcEV4dCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlTihbY29tcGxldGlvbkNvbmZpZ10sIHN0YXRlID0+IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmRlZmF1bHRLZXltYXAgPyBbY29tcGxldGlvbktleW1hcF0gOiBbXSkpO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgY29tcGxldGlvbiBzdGF0dXMuIFdoZW4gY29tcGxldGlvbnMgYXJlIGF2YWlsYWJsZSxcbnRoaXMgd2lsbCByZXR1cm4gYFwiYWN0aXZlXCJgLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBwZW5kaW5nIChpbiB0aGVcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XG5yZXR1cm5zIGBudWxsYC5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XG4gICAgbGV0IGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pID8gXCJwZW5kaW5nXCJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xufVxuY29uc3QgY29tcGxldGlvbkFycmF5Q2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXA7XG4vKipcblJldHVybnMgdGhlIGF2YWlsYWJsZSBjb21wbGV0aW9ucyBhcyBhbiBhcnJheS5cbiovXG5mdW5jdGlvbiBjdXJyZW50Q29tcGxldGlvbnMoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgaWYgKCFvcGVuIHx8IG9wZW4uZGlzYWJsZWQpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb21wbGV0aW9uQXJyYXlDYWNoZS5nZXQob3Blbi5vcHRpb25zKTtcbiAgICBpZiAoIWNvbXBsZXRpb25zKVxuICAgICAgICBjb21wbGV0aW9uQXJyYXlDYWNoZS5zZXQob3Blbi5vcHRpb25zLCBjb21wbGV0aW9ucyA9IG9wZW4ub3B0aW9ucy5tYXAobyA9PiBvLmNvbXBsZXRpb24pKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG4vKipcblJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24sIGlmIGFueS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb24oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdLmNvbXBsZXRpb24gOiBudWxsO1xufVxuLyoqXG5SZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcG9zaXRpb24gaW4gdGhlIGFjdGl2ZSBjb21wbGV0aW9uXG5saXN0LCBvciBudWxsIGlmIG5vIGNvbXBsZXRpb25zIGFyZSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5zZWxlY3RlZCA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhbiBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBjaGFuZ2VcbnRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBzZXRTZWxlY3RlZENvbXBsZXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gc2V0U2VsZWN0ZWRFZmZlY3Qub2YoaW5kZXgpO1xufVxuXG5leHBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCwgYWNjZXB0Q29tcGxldGlvbiwgYXV0b2NvbXBsZXRpb24sIGNsZWFyU25pcHBldCwgY2xvc2VCcmFja2V0cywgY2xvc2VCcmFja2V0c0tleW1hcCwgY2xvc2VDb21wbGV0aW9uLCBjb21wbGV0ZUFueVdvcmQsIGNvbXBsZXRlRnJvbUxpc3QsIGNvbXBsZXRpb25LZXltYXAsIGNvbXBsZXRpb25TdGF0dXMsIGN1cnJlbnRDb21wbGV0aW9ucywgZGVsZXRlQnJhY2tldFBhaXIsIGlmSW4sIGlmTm90SW4sIGluc2VydEJyYWNrZXQsIGluc2VydENvbXBsZXRpb25UZXh0LCBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiwgbmV4dFNuaXBwZXRGaWVsZCwgcGlja2VkQ29tcGxldGlvbiwgcHJldlNuaXBwZXRGaWVsZCwgc2VsZWN0ZWRDb21wbGV0aW9uLCBzZWxlY3RlZENvbXBsZXRpb25JbmRleCwgc2V0U2VsZWN0ZWRDb21wbGV0aW9uLCBzbmlwcGV0LCBzbmlwcGV0Q29tcGxldGlvbiwgc25pcHBldEtleW1hcCwgc3RhcnRDb21wbGV0aW9uIH07XG4iLCAiaW1wb3J0IHsgRGVjb3JhdGlvbiwgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIGd1dHRlciwgc2hvd1Rvb2x0aXAsIGdldFBhbmVsLCBXaWRnZXRUeXBlLCBob3ZlclRvb2x0aXAsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jbGFzcyBTZWxlY3RlZERpYWdub3N0aWMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICB9XG59XG5jbGFzcyBMaW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzLCBwYW5lbCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoZGlhZ25vc3RpY3MsIHBhbmVsLCBzdGF0ZSkge1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIGxpc3Qgb2YgZGlhZ25vc3RpY3MgZm9yIHdoaWNoIHRvIGNyZWF0ZSBtYXJrZXJzXG4gICAgICAgIGxldCBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIobWFya2VkRGlhZ25vc3RpY3MpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gRGVjb3JhdGlvbi5zZXQobWFya2VkRGlhZ25vc3RpY3MubWFwKChkKSA9PiB7XG4gICAgICAgICAgICAvLyBGb3IgemVyby1sZW5ndGggcmFuZ2VzIG9yIHJhbmdlcyBjb3ZlcmluZyBvbmx5IGEgbGluZSBicmVhaywgY3JlYXRlIGEgd2lkZ2V0XG4gICAgICAgICAgICByZXR1cm4gZC5mcm9tID09IGQudG8gfHwgKGQuZnJvbSA9PSBkLnRvIC0gMSAmJiBzdGF0ZS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKVxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KGQpLFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLVwiICsgZC5zZXZlcml0eSB9LFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShyYW5nZXMsIHBhbmVsLCBmaW5kRGlhZ25vc3RpYyhyYW5nZXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZGlhZ25vc3RpYyA9IG51bGwsIGFmdGVyID0gMCkge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZGlhZ25vc3RpY3MuYmV0d2VlbihhZnRlciwgMWU5LCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChkaWFnbm9zdGljICYmIHNwZWMuZGlhZ25vc3RpYyAhPSBkaWFnbm9zdGljKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3VuZCA9IG5ldyBTZWxlY3RlZERpYWdub3N0aWMoZnJvbSwgdG8sIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkge1xuICAgIHJldHVybiAhISh0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkgfHwgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodG9vbHRpcC5wb3MpKTtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlTGludChzdGF0ZSwgZWZmZWN0cykge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKSA/IGVmZmVjdHMgOiBlZmZlY3RzLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW1xuICAgICAgICBsaW50U3RhdGUsXG4gICAgICAgIEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuY29tcHV0ZShbbGludFN0YXRlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuICFzZWxlY3RlZCB8fCAhcGFuZWwgfHwgc2VsZWN0ZWQuZnJvbSA9PSBzZWxlY3RlZC50byA/IERlY29yYXRpb24ubm9uZSA6IERlY29yYXRpb24uc2V0KFtcbiAgICAgICAgICAgICAgICBhY3RpdmVNYXJrLnJhbmdlKHNlbGVjdGVkLmZyb20sIHNlbGVjdGVkLnRvKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pLFxuICAgICAgICBob3ZlclRvb2x0aXAobGludFRvb2x0aXAsIHsgaGlkZU9uOiBoaWRlVG9vbHRpcCB9KSxcbiAgICAgICAgYmFzZVRoZW1lXG4gICAgXSkpO1xufVxuLyoqXG5SZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCB1cGRhdGVzIHRoZSBjdXJyZW50IHNldCBvZlxuZGlhZ25vc3RpY3MsIGFuZCBlbmFibGVzIHRoZSBsaW50IGV4dGVuc2lvbiBpZiBpZiB3YXNuJ3QgYWxyZWFkeVxuYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNldERpYWdub3N0aWNzKHN0YXRlLCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVmZmVjdHM6IG1heWJlRW5hYmxlTGludChzdGF0ZSwgW3NldERpYWdub3N0aWNzRWZmZWN0Lm9mKGRpYWdub3N0aWNzKV0pXG4gICAgfTtcbn1cbi8qKlxuVGhlIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIHNldCBvZiBhY3RpdmUgZGlhZ25vc3RpY3MuIENhblxuYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBhbiBleHRlbnNpb24gdGhhdCBuZWVkcyB0byB0cmFjayB0aGVzZS5cbiovXG5jb25zdCBzZXREaWFnbm9zdGljc0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbW92ZVBhbmVsU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKERlY29yYXRpb24ubm9uZSwgbnVsbCwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgdmFsdWUucGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExpbnRTdGF0ZS5pbml0KGVmZmVjdC52YWx1ZSwgdmFsdWUucGFuZWwsIHRyLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIGVmZmVjdC52YWx1ZSA/IExpbnRQYW5lbC5vcGVuIDogbnVsbCwgdmFsdWUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKG1vdmVQYW5lbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIHZhbHVlLnBhbmVsLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW3Nob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpLFxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgcyA9PiBzLmRpYWdub3N0aWNzKV1cbn0pO1xuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aXZlIGxpbnQgZGlhZ25vc3RpY3MgaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGRpYWdub3N0aWNDb3VudChzdGF0ZSkge1xuICAgIGxldCBsaW50ID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xufVxuY29uc3QgYWN0aXZlTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLWFjdGl2ZVwiIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQgPSBbXSwgc3RhY2tTdGFydCA9IDJlOCwgc3RhY2tFbmQgPSAwO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgIHN0YWNrU3RhcnQgPSBNYXRoLm1pbihmcm9tLCBzdGFja1N0YXJ0KTtcbiAgICAgICAgICAgIHN0YWNrRW5kID0gTWF0aC5tYXgodG8sIHN0YWNrRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICBmb3VuZCA9IGRpYWdub3N0aWNGaWx0ZXIoZm91bmQpO1xuICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YWNrU3RhcnQsXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhY2tTdGFydCkudG8gPCBzdGFja0VuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIGVsdChcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZGlhZ25vc3RpY3MubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXcuc3RhdGUsIFt0b2dnbGVQYW5lbC5vZih0cnVlKV0pIH0pO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIExpbnRQYW5lbC5vcGVuKTtcbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkEgc2V0IG9mIGRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgbGludCBmdW5jdGlvbmFsaXR5LlxuXG4tIEN0cmwtU2hpZnQtbSAoQ21kLVNoaWZ0LW0gb24gbWFjT1MpOiBbYG9wZW5MaW50UGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQub3BlbkxpbnRQYW5lbClcbi0gRjg6IFtgbmV4dERpYWdub3N0aWNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubmV4dERpYWdub3N0aWMpXG4qL1xuY29uc3QgbGludEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbVwiLCBydW46IG9wZW5MaW50UGFuZWwsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRjhcIiwgcnVuOiBuZXh0RGlhZ25vc3RpYyB9XG5dO1xuY29uc3QgbGludFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXQgPSB0cnVlO1xuICAgICAgICBsZXQgeyBkZWxheSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCkgKyBkZWxheTtcbiAgICAgICAgdGhpcy5ydW4gPSB0aGlzLnJ1bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBkZWxheSk7XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPCB0aGlzLmxpbnRUaW1lIC0gMTApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5ydW4sIHRoaXMubGludFRpbWUgLSBub3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHsgc291cmNlcyB9ID0gc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChzb3VyY2VzLm1hcChzb3VyY2UgPT4gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZSh0aGlzLnZpZXcpKSkpLnRoZW4oYW5ub3RhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBhbGwgPSBhbm5vdGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyA9PSBzdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChzZXREaWFnbm9zdGljcyh0aGlzLnZpZXcuc3RhdGUsIGFsbCkpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4geyBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnJvcik7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IGNvbmZpZyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW50Q29uZmlnKSkge1xuICAgICAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCkgKyBjb25maWcuZGVsYXk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGNvbmZpZy5kZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldCkge1xuICAgICAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbn0pO1xuY29uc3QgbGludENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBzb3VyY2VzOiBpbnB1dC5tYXAoaSA9PiBpLnNvdXJjZSkgfSwgY29tYmluZUNvbmZpZyhpbnB1dC5tYXAoaSA9PiBpLmNvbmZpZyksIHtcbiAgICAgICAgICAgIGRlbGF5OiA3NTAsXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXG4gICAgICAgIH0pKTtcbiAgICB9LFxuICAgIGVuYWJsZXM6IGxpbnRQbHVnaW5cbn0pO1xuLyoqXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcbmVuYWJsZXMgbGludGluZyB3aXRoIHRoYXQgc291cmNlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbmVkaXRvciBpcyBpZGxlIChhZnRlciBpdHMgY29udGVudCBjaGFuZ2VkKS5cbiovXG5mdW5jdGlvbiBsaW50ZXIoc291cmNlLCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBsaW50Q29uZmlnLm9mKHsgc291cmNlLCBjb25maWcgfSk7XG59XG4vKipcbkZvcmNlcyBhbnkgbGludGVycyBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcikgdG8gcnVuIHdoZW4gdGhlXG5lZGl0b3IgaXMgaWRsZSB0byBydW4gcmlnaHQgYXdheS5cbiovXG5mdW5jdGlvbiBmb3JjZUxpbnRpbmcodmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihsaW50UGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4uZm9yY2UoKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbktleXMoYWN0aW9ucykge1xuICAgIGxldCBhc3NpZ25lZCA9IFtdO1xuICAgIGlmIChhY3Rpb25zKVxuICAgICAgICBhY3Rpb25zOiBmb3IgKGxldCB7IG5hbWUgfSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBuYW1lW2ldO1xuICAgICAgICAgICAgICAgIGlmICgvW2EtekEtWl0vLnRlc3QoY2gpICYmICFhc3NpZ25lZC5zb21lKGMgPT4gYy50b0xvd2VyQ2FzZSgpID09IGNoLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhY3Rpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICByZXR1cm4gYXNzaWduZWQ7XG59XG5mdW5jdGlvbiByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIGluUGFuZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGtleXMgPSBpblBhbmVsID8gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpIDogW107XG4gICAgcmV0dXJuIGVsdChcImxpXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpYyBjbS1kaWFnbm9zdGljLVwiICsgZGlhZ25vc3RpYy5zZXZlcml0eSB9LCBlbHQoXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1RleHRcIiB9LCBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UgPyBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UoKSA6IGRpYWdub3N0aWMubWVzc2FnZSksIChfYSA9IGRpYWdub3N0aWMuYWN0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoYWN0aW9uLCBpKSA9PiB7XG4gICAgICAgIGxldCBjbGljayA9IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IGFjdGlvbiwga2V5SW5kZXggPSBrZXlzW2ldID8gbmFtZS5pbmRleE9mKGtleXNbaV0pIDogLTE7XG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcbiAgICAgICAgICAgIGVsdChcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1kaWFnbm9zdGljQWN0aW9uXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcbiAgICAgICAgICAgIG9ubW91c2Vkb3duOiBjbGljayxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBgIEFjdGlvbjogJHtuYW1lfSR7a2V5SW5kZXggPCAwID8gXCJcIiA6IGAgKGFjY2VzcyBrZXkgXCIke2tleXNbaV19KVwiYH0uYFxuICAgICAgICB9LCBuYW1lRWx0KTtcbiAgICB9KSwgZGlhZ25vc3RpYy5zb3VyY2UgJiYgZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuZGlhZ25vc3RpYyA9PSB0aGlzLmRpYWdub3N0aWM7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1saW50UG9pbnQgY20tbGludFBvaW50LVwiICsgdGhpcy5kaWFnbm9zdGljLnNldmVyaXR5IH0pO1xuICAgIH1cbn1cbmNsYXNzIFBhbmVsSXRlbSB7XG4gICAgY29uc3RydWN0b3IodmlldywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgICAgICB0aGlzLmlkID0gXCJpdGVtX1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICB0aGlzLmRvbSA9IHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tLmlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICB9XG59XG5jbGFzcyBMaW50UGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBsZXQgb25rZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCB8fCBldmVudC5rZXlDb2RlID09IDMzKSB7IC8vIEFycm93VXAsIFBhZ2VVcFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4IC0gMSArIHRoaXMuaXRlbXMubGVuZ3RoKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDAgfHwgZXZlbnQua2V5Q29kZSA9PSAzNCkgeyAvLyBBcnJvd0Rvd24sIFBhZ2VEb3duXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzYpIHsgLy8gSG9tZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzUpIHsgLy8gRW5kXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID49IDY1ICYmIGV2ZW50LmtleUNvZGUgPD0gOTAgJiYgdGhpcy5zZWxlY3RlZEluZGV4ID49IDApIHsgLy8gQS1aXG4gICAgICAgICAgICAgICAgbGV0IHsgZGlhZ25vc3RpYyB9ID0gdGhpcy5pdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLCBrZXlzID0gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApID09IGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljLmFjdGlvbnNbaV0uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gZWx0KFwidWxcIiwge1xuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXG4gICAgICAgICAgICBvbmtleWRvd24sXG4gICAgICAgICAgICBvbmNsaWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLXBhbmVsLWxpbnRcIiB9LCB0aGlzLmxpc3QsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlTGludFBhbmVsKHRoaXMudmlldylcbiAgICAgICAgfSwgXCJcdTAwRDdcIikpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuc2VsZWN0ZWQ7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB7IGRpYWdub3N0aWNzLCBzZWxlY3RlZCB9ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBpID0gMCwgbmVlZHNTeW5jID0gZmFsc2UsIG5ld1NlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIGRpYWdub3N0aWNzLmJldHdlZW4oMCwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChfc3RhcnQsIF9lbmQsIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMSwgaXRlbTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tqXS5kaWFnbm9zdGljID09IHNwZWMuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIGZvdW5kIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIGl0ZW0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiAhKHRoaXMuaXRlbXMubGVuZ3RoID09IDEgJiYgdGhpcy5pdGVtc1swXS5kaWFnbm9zdGljLmZyb20gPCAwKSkge1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFuZWxJdGVtKHRoaXMudmlldywge1xuICAgICAgICAgICAgICAgIGZyb206IC0xLCB0bzogLTEsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJObyBkaWFnbm9zdGljc1wiKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5ld1NlbGVjdGVkSXRlbS5pZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoe1xuICAgICAgICAgICAgICAgIGtleTogdGhpcyxcbiAgICAgICAgICAgICAgICByZWFkOiAoKSA9PiAoeyBzZWw6IG5ld1NlbGVjdGVkSXRlbS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHBhbmVsOiB0aGlzLmxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfSksXG4gICAgICAgICAgICAgICAgd3JpdGU6ICh7IHNlbCwgcGFuZWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLnRvcCA8IHBhbmVsLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgLT0gcGFuZWwudG9wIC0gc2VsLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLmJvdHRvbSA+IHBhbmVsLmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gc2VsLmJvdHRvbSAtIHBhbmVsLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1N5bmMpXG4gICAgICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgbGV0IGRvbVBvcyA9IHRoaXMubGlzdC5maXJzdENoaWxkO1xuICAgICAgICBmdW5jdGlvbiBybSgpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZG9tUG9zO1xuICAgICAgICAgICAgZG9tUG9zID0gcHJldi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHByZXYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tUG9zICE9IGl0ZW0uZG9tKVxuICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgIGRvbVBvcyA9IGl0ZW0uZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Lmluc2VydEJlZm9yZShpdGVtLmRvbSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZG9tUG9zKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9XG4gICAgbW92ZVNlbGVjdGlvbihzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGZpbmREaWFnbm9zdGljKGZpZWxkLmRpYWdub3N0aWNzLCB0aGlzLml0ZW1zW3NlbGVjdGVkSW5kZXhdLmRpYWdub3N0aWMpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHNlbGVjdGlvbi5mcm9tLCBoZWFkOiBzZWxlY3Rpb24udG8gfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgZWZmZWN0czogbW92ZVBhbmVsU2VsZWN0aW9uLm9mKHNlbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBvcGVuKHZpZXcpIHsgcmV0dXJuIG5ldyBMaW50UGFuZWwodmlldyk7IH1cbn1cbmZ1bmN0aW9uIHN2Zyhjb250ZW50LCBhdHRycyA9IGB2aWV3Qm94PVwiMCAwIDQwIDQwXCJgKSB7XG4gICAgcmV0dXJuIGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAke2F0dHJzfT4ke2VuY29kZVVSSUNvbXBvbmVudChjb250ZW50KX08L3N2Zz4nKWA7XG59XG5mdW5jdGlvbiB1bmRlcmxpbmUoY29sb3IpIHtcbiAgICByZXR1cm4gc3ZnKGA8cGF0aCBkPVwibTAgMi41IGwyIC0xLjUgbDEgMCBsMiAxLjUgbDEgMFwiIHN0cm9rZT1cIiR7Y29sb3J9XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIuN1wiLz5gLCBgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiM1wiYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWRpYWdub3N0aWNcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0xcHhcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtZXJyb3JcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjZDExXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaW5mb1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM5OTlcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNBY3Rpb25cIjoge1xuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIzcHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY1NvdXJjZVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBvcGFjaXR5OiAuN1xuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImxlZnQgYm90dG9tXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwicmVwZWF0LXhcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWVycm9yXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiI2QxMVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS13YXJuaW5nXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWluZm9cIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjOTk5XCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWFjdGl2ZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZkZDk5ODBcIiB9LFxuICAgIFwiLmNtLXRvb2x0aXAtbGludFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCI0cHggc29saWQgI2QxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC13YXJuaW5nXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwib3JhbmdlXCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWluZm9cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjOTk5XCIgfVxuICAgIH0sXG4gICAgXCIuY20tcGFuZWwuY20tcGFuZWwtbGludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiB1bFwiOiB7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiLFxuICAgICAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjpmb2N1cyBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRfZmFsbGJhY2s6IFwiI2JkZlwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICBjb2xvcl9mYWxsYmFjazogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIkhpZ2hsaWdodFRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwibm9uZVwiIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCIycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9XG4gICAgfVxufSk7XG5jbGFzcyBMaW50R3V0dGVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBkaWFnbm9zdGljcy5yZWR1Y2UoKG1heCwgZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHMgPSBkLnNldmVyaXR5O1xuICAgICAgICAgICAgcmV0dXJuIHMgPT0gXCJlcnJvclwiIHx8IHMgPT0gXCJ3YXJuaW5nXCIgJiYgbWF4ID09IFwiaW5mb1wiID8gcyA6IG1heDtcbiAgICAgICAgfSwgXCJpbmZvXCIpO1xuICAgIH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1saW50LW1hcmtlciBjbS1saW50LW1hcmtlci1cIiArIHRoaXMuc2V2ZXJpdHk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IHRoaXMuZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljc0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzRmlsdGVyKVxuICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljc0ZpbHRlcihkaWFnbm9zdGljcyk7XG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXG4gICAgICAgICAgICBlbHQub25tb3VzZW92ZXIgPSAoKSA9PiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgZWx0LCBkaWFnbm9zdGljcyk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcikge1xuICAgIGxldCBtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYID4gcmVjdC5sZWZ0IC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFggPCByZWN0LnJpZ2h0ICsgMTAgLyogSG92ZXIuTWFyZ2luICovICYmXG4gICAgICAgICAgICBldmVudC5jbGllbnRZID4gcmVjdC50b3AgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICsgMTAgLyogSG92ZXIuTWFyZ2luICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7IHRhcmdldDsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcC1saW50XCIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyVG9vbHRpcCkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2YobnVsbCkgfSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xufVxuZnVuY3Rpb24gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIG1hcmtlciwgZGlhZ25vc3RpY3MpIHtcbiAgICBmdW5jdGlvbiBob3ZlcmVkKCkge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyA1IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgIGNvbnN0IGxpbmVQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChsaW5lUG9zKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2Yoe1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGxpbmUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb29yZHM6ICgpID0+IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcik7XG4gICAgfVxuICAgIGxldCB7IGhvdmVyVGltZSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKTtcbiAgICBsZXQgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgIH07XG4gICAgbWFya2VyLm9ubW91c2Vtb3ZlID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrZXJzRm9yRGlhZ25vc3RpY3MoZG9jLCBkaWFnbm9zdGljcykge1xuICAgIGxldCBieUxpbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGRpYWdub3N0aWMgb2YgZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KGRpYWdub3N0aWMuZnJvbSk7XG4gICAgICAgIChieUxpbmVbbGluZS5mcm9tXSB8fCAoYnlMaW5lW2xpbmUuZnJvbV0gPSBbXSkpLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgfVxuICAgIGxldCBtYXJrZXJzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBpbiBieUxpbmUpIHtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5ldyBMaW50R3V0dGVyTWFya2VyKGJ5TGluZVtsaW5lXSkucmFuZ2UoK2xpbmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtlcnMsIHRydWUpO1xufVxuY29uc3QgbGludEd1dHRlckV4dGVuc2lvbiA9IC8qQF9fUFVSRV9fKi9ndXR0ZXIoe1xuICAgIGNsYXNzOiBcImNtLWd1dHRlci1saW50XCIsXG4gICAgbWFya2VyczogdmlldyA9PiB2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJNYXJrZXJzKSxcbn0pO1xuY29uc3QgbGludEd1dHRlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKG1hcmtlcnMsIHRyKSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB0ci5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBkaWFnbm9zdGljcyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzID0gbWFya2Vyc0ZvckRpYWdub3N0aWNzKHRyLnN0YXRlLmRvYywgZGlhZ25vc3RpY3Muc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbn0pO1xuY29uc3Qgc2V0TGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodG9vbHRpcCwgdHIpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKCh0LCBlKSA9PiBlLmlzKHNldExpbnRHdXR0ZXJUb29sdGlwKSA/IGUudmFsdWUgOiB0LCB0b29sdGlwKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHNob3dUb29sdGlwLmZyb20oZmllbGQpXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xuICAgICAgICB3aWR0aDogXCIxLjRlbVwiLFxuICAgICAgICBcIiYgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1pbmZvXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNhYWZcIiBzdHJva2U9XCIjNzdlXCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk01IDVMMzUgNUwzNSAzNUw1IDM1WlwiLz5gKVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItd2FybmluZ1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjZmU4XCIgc3Ryb2tlPVwiI2ZkN1wiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjAgNkwzNyAzNUwzIDM1WlwiLz5gKSxcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWVycm9yXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxNVwiIGZpbGw9XCIjZjg3XCIgc3Ryb2tlPVwiI2Y0M1wiIHN0cm9rZS13aWR0aD1cIjZcIi8+YClcbiAgICB9LFxufSk7XG5jb25zdCBsaW50R3V0dGVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGhvdmVyVGltZTogMzAwIC8qIEhvdmVyLlRpbWUgKi8sXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGEgZ3V0dGVyIHNob3dpbmcgbWFya2VycyBmb3JcbmVhY2ggbGluZSB0aGF0IGhhcyBkaWFnbm9zdGljcywgd2hpY2ggY2FuIGJlIGhvdmVyZWQgb3ZlciB0byBzZWVcbnRoZSBkaWFnbm9zdGljcy5cbiovXG5mdW5jdGlvbiBsaW50R3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtsaW50R3V0dGVyQ29uZmlnLm9mKGNvbmZpZyksIGxpbnRHdXR0ZXJNYXJrZXJzLCBsaW50R3V0dGVyRXh0ZW5zaW9uLCBsaW50R3V0dGVyVGhlbWUsIGxpbnRHdXR0ZXJUb29sdGlwXTtcbn1cbi8qKlxuSXRlcmF0ZSBvdmVyIHRoZSBtYXJrZWQgZGlhZ25vc3RpY3MgZm9yIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUsXG5jYWxsaW5nIGBmYCBmb3IgZWFjaCBvZiB0aGVtLiBOb3RlIHRoYXQsIGlmIHRoZSBkb2N1bWVudCBjaGFuZ2VkXG5zaW5jZSB0aGUgZGlhZ25vc3RpY3Mgd2VyZWNyZWF0ZWQsIHRoZSBgRGlhZ25vc3RpY2Agb2JqZWN0IHdpbGxcbmhvbGQgdGhlIG9yaWdpbmFsIG91dGRhdGVkIHBvc2l0aW9uLCB3aGVyZWFzIHRoZSBgdG9gIGFuZCBgZnJvbWBcbmFyZ3VtZW50cyBob2xkIHRoZSBkaWFnbm9zdGljJ3MgY3VycmVudCBwb3NpdGlvbi5cbiovXG5mdW5jdGlvbiBmb3JFYWNoRGlhZ25vc3RpYyhzdGF0ZSwgZikge1xuICAgIGxldCBsU3RhdGUgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAobFN0YXRlICYmIGxTdGF0ZS5kaWFnbm9zdGljcy5zaXplKVxuICAgICAgICBmb3IgKGxldCBpdGVyID0gUmFuZ2VTZXQuaXRlcihbbFN0YXRlLmRpYWdub3N0aWNzXSk7IGl0ZXIudmFsdWU7IGl0ZXIubmV4dCgpKVxuICAgICAgICAgICAgZihpdGVyLnZhbHVlLnNwZWMuZGlhZ25vc3RpYywgaXRlci5mcm9tLCBpdGVyLnRvKTtcbn1cblxuZXhwb3J0IHsgY2xvc2VMaW50UGFuZWwsIGRpYWdub3N0aWNDb3VudCwgZm9yRWFjaERpYWdub3N0aWMsIGZvcmNlTGludGluZywgbGludEd1dHRlciwgbGludEtleW1hcCwgbGludGVyLCBuZXh0RGlhZ25vc3RpYywgb3BlbkxpbnRQYW5lbCwgc2V0RGlhZ25vc3RpY3MsIHNldERpYWdub3N0aWNzRWZmZWN0IH07XG4iLCAiaW1wb3J0IHsgbGluZU51bWJlcnMsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIGNyb3NzaGFpckN1cnNvciwgaGlnaGxpZ2h0QWN0aXZlTGluZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5leHBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IGZvbGRHdXR0ZXIsIGluZGVudE9uSW5wdXQsIHN5bnRheEhpZ2hsaWdodGluZywgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBicmFja2V0TWF0Y2hpbmcsIGZvbGRLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBoaXN0b3J5LCBkZWZhdWx0S2V5bWFwLCBoaXN0b3J5S2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvY29tbWFuZHMnO1xuaW1wb3J0IHsgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgc2VhcmNoS2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc2VhcmNoJztcbmltcG9ydCB7IGNsb3NlQnJhY2tldHMsIGF1dG9jb21wbGV0aW9uLCBjbG9zZUJyYWNrZXRzS2V5bWFwLCBjb21wbGV0aW9uS2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IGxpbnRLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9saW50JztcblxuLy8gKFRoZSBzdXBlcmZsdW91cyBmdW5jdGlvbiBjYWxscyBhcm91bmQgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9ucyB3b3JrXG4vLyBhcm91bmQgY3VycmVudCBsaW1pdGF0aW9ucyBpbiB0cmVlLXNoYWtpbmcgc29mdHdhcmUuKVxuLyoqXG5UaGlzIGlzIGFuIGV4dGVuc2lvbiB2YWx1ZSB0aGF0IGp1c3QgcHVsbHMgdG9nZXRoZXIgYSBudW1iZXIgb2ZcbmV4dGVuc2lvbnMgdGhhdCB5b3UgbWlnaHQgd2FudCBpbiBhIGJhc2ljIGVkaXRvci4gSXQgaXMgbWVhbnQgYXMgYVxuY29udmVuaWVudCBoZWxwZXIgdG8gcXVpY2tseSBzZXQgdXAgQ29kZU1pcnJvciB3aXRob3V0IGluc3RhbGxpbmdcbmFuZCBpbXBvcnRpbmcgYSBsb3Qgb2Ygc2VwYXJhdGUgcGFja2FnZXMuXG5cblNwZWNpZmljYWxseSwgaXQgaW5jbHVkZXMuLi5cblxuIC0gW3RoZSBkZWZhdWx0IGNvbW1hbmQgYmluZGluZ3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVmYXVsdEtleW1hcClcbiAtIFtsaW5lIG51bWJlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5saW5lTnVtYmVycylcbiAtIFtzcGVjaWFsIGNoYXJhY3RlciBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMpXG4gLSBbdGhlIHVuZG8gaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KVxuIC0gW2EgZm9sZCBndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcilcbiAtIFtjdXN0b20gc2VsZWN0aW9uIGRyYXdpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKVxuIC0gW2Ryb3AgY3Vyc29yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJvcEN1cnNvcilcbiAtIFttdWx0aXBsZSBzZWxlY3Rpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuIC0gW3JlaW5kZW50YXRpb24gb24gaW5wdXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50T25JbnB1dClcbiAtIFt0aGUgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKSAoYXMgZmFsbGJhY2spXG4gLSBbYnJhY2tldCBtYXRjaGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5icmFja2V0TWF0Y2hpbmcpXG4gLSBbYnJhY2tldCBjbG9zaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKVxuIC0gW2F1dG9jb21wbGV0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbilcbiAtIFtyZWN0YW5ndWxhciBzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikgYW5kIFtjcm9zc2hhaXIgY3Vyc29yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuY3Jvc3NoYWlyQ3Vyc29yKVxuIC0gW2FjdGl2ZSBsaW5lIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpXG4gLSBbYWN0aXZlIGxpbmUgZ3V0dGVyIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIpXG4gLSBbc2VsZWN0aW9uIG1hdGNoIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcylcbiAtIFtzZWFyY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaEtleW1hcClcbiAtIFtsaW50aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludEtleW1hcClcblxuKFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIGFkZCBzb21lIGxhbmd1YWdlIHBhY2thZ2UgdG8geW91ciBzZXR1cFxudG9vLilcblxuVGhpcyBleHRlbnNpb24gZG9lcyBub3QgYWxsb3cgY3VzdG9taXphdGlvbi4gVGhlIGlkZWEgaXMgdGhhdCxcbm9uY2UgeW91IGRlY2lkZSB5b3Ugd2FudCB0byBjb25maWd1cmUgeW91ciBlZGl0b3IgbW9yZSBwcmVjaXNlbHksXG55b3UgdGFrZSB0aGlzIHBhY2thZ2UncyBzb3VyY2UgKHdoaWNoIGlzIGp1c3QgYSBidW5jaCBvZiBpbXBvcnRzXG5hbmQgYW4gYXJyYXkgbGl0ZXJhbCksIGNvcHkgaXQgaW50byB5b3VyIG93biBjb2RlLCBhbmQgYWRqdXN0IGl0XG5hcyBkZXNpcmVkLlxuKi9cbmNvbnN0IGJhc2ljU2V0dXAgPSAvKkBfX1BVUkVfXyovKCgpID0+IFtcbiAgICBsaW5lTnVtYmVycygpLFxuICAgIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSxcbiAgICBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoKSxcbiAgICBoaXN0b3J5KCksXG4gICAgZm9sZEd1dHRlcigpLFxuICAgIGRyYXdTZWxlY3Rpb24oKSxcbiAgICBkcm9wQ3Vyc29yKCksXG4gICAgRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMub2YodHJ1ZSksXG4gICAgaW5kZW50T25JbnB1dCgpLFxuICAgIHN5bnRheEhpZ2hsaWdodGluZyhkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHsgZmFsbGJhY2s6IHRydWUgfSksXG4gICAgYnJhY2tldE1hdGNoaW5nKCksXG4gICAgY2xvc2VCcmFja2V0cygpLFxuICAgIGF1dG9jb21wbGV0aW9uKCksXG4gICAgcmVjdGFuZ3VsYXJTZWxlY3Rpb24oKSxcbiAgICBjcm9zc2hhaXJDdXJzb3IoKSxcbiAgICBoaWdobGlnaHRBY3RpdmVMaW5lKCksXG4gICAgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcygpLFxuICAgIGtleW1hcC5vZihbXG4gICAgICAgIC4uLmNsb3NlQnJhY2tldHNLZXltYXAsXG4gICAgICAgIC4uLmRlZmF1bHRLZXltYXAsXG4gICAgICAgIC4uLnNlYXJjaEtleW1hcCxcbiAgICAgICAgLi4uaGlzdG9yeUtleW1hcCxcbiAgICAgICAgLi4uZm9sZEtleW1hcCxcbiAgICAgICAgLi4uY29tcGxldGlvbktleW1hcCxcbiAgICAgICAgLi4ubGludEtleW1hcFxuICAgIF0pXG5dKSgpO1xuLyoqXG5BIG1pbmltYWwgc2V0IG9mIGV4dGVuc2lvbnMgdG8gY3JlYXRlIGEgZnVuY3Rpb25hbCBlZGl0b3IuIE9ubHlcbmluY2x1ZGVzIFt0aGUgZGVmYXVsdCBrZXltYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVmYXVsdEtleW1hcCksIFt1bmRvXG5oaXN0b3J5XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmhpc3RvcnkpLCBbc3BlY2lhbCBjaGFyYWN0ZXJcbmhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodFNwZWNpYWxDaGFycyksIFtjdXN0b20gc2VsZWN0aW9uXG5kcmF3aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbiksIGFuZCBbZGVmYXVsdCBoaWdobGlnaHRcbnN0eWxlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmF1bHRIaWdobGlnaHRTdHlsZSkuXG4qL1xuY29uc3QgbWluaW1hbFNldHVwID0gLypAX19QVVJFX18qLygoKSA9PiBbXG4gICAgaGlnaGxpZ2h0U3BlY2lhbENoYXJzKCksXG4gICAgaGlzdG9yeSgpLFxuICAgIGRyYXdTZWxlY3Rpb24oKSxcbiAgICBzeW50YXhIaWdobGlnaHRpbmcoZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCB7IGZhbGxiYWNrOiB0cnVlIH0pLFxuICAgIGtleW1hcC5vZihbXG4gICAgICAgIC4uLmRlZmF1bHRLZXltYXAsXG4gICAgICAgIC4uLmhpc3RvcnlLZXltYXAsXG4gICAgXSlcbl0pKCk7XG5cbmV4cG9ydCB7IGJhc2ljU2V0dXAsIG1pbmltYWxTZXR1cCB9O1xuIiwgImltcG9ydCB7IFBhcnNlciwgTm9kZVNldCwgTm9kZVR5cGUsIERlZmF1bHRCdWZmZXJMZW5ndGgsIE5vZGVQcm9wLCBUcmVlLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vLy8gQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG4vLy8gcGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG4vLy8gdGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbi8vLyBhYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG5jbGFzcyBTdGFjayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgcCwgXG4gICAgLy8vIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICAvLy8gdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YWNrLCBcbiAgICAvLy8gVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZVBvcywgXG4gICAgLy8vIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgcG9zLCBcbiAgICAvLy8gVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgLy8vIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXJCYXNlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGxvb2tBaGVhZCA9IDAsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGljIHN0YXJ0KHAsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIGxldCBjeCA9IHAucGFyc2VyLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2socCwgW10sIHN0YXRlLCBwb3MsIHBvcywgMCwgW10sIDAsIGN4ID8gbmV3IFN0YWNrQ29udGV4dChjeCwgY3guc3RhcnQpIDogbnVsbCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIC8vLyBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgLy8vIHBhcmFtZXRlciwgb3IgaXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dFxuICAgIC8vLyB0cmFja2VyLlxuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNlXHUyMDE0dGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAyXTtcbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSB0aGlzLnN0YWNrW2Jhc2UgLSAxXSwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogRXJyICovICYmXG4gICAgICAgICAgICAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMuYnVmZmVyQmFzZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIEVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KG5leHQsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KG5leHQsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhbiBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgICAvLy8gQGludGVybmFsXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogRGVsZXRlICovO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgLy8vIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIC8vLyBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIC8vLyBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIEluc2VydCAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCByZWR1Y2UgPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGlmICghcGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHJlZHVjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBBY3Rpb25zICovKV0gPT0gNjU1MzUgLyogRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvLy8gUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIC8vLyB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICAvLy8gc3RhdGUpLiBAaW50ZXJuYWxcbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgLy8vIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRDb250ZXh0KCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtMylcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5jdXJDb250ZXh0Lmhhc2gsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgLTMpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQgJiYgdGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0KVxuICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sb29rQWhlYWQgPiAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuc3RyaWN0ID8gdHJhY2tlci5oYXNoKGNvbnRleHQpIDogMDtcbiAgICB9XG59XG52YXIgUmVjb3ZlcjtcbihmdW5jdGlvbiAoUmVjb3Zlcikge1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkluc2VydFwiXSA9IDIwMF0gPSBcIkluc2VydFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRlbGV0ZVwiXSA9IDE5MF0gPSBcIkRlbGV0ZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlJlZHVjZVwiXSA9IDEwMF0gPSBcIlJlZHVjZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heE5leHRcIl0gPSA0XSA9IFwiTWF4TmV4dFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heEluc2VydFN0YWNrRGVwdGhcIl0gPSAzMDBdID0gXCJNYXhJbnNlcnRTdGFja0RlcHRoXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDEyMF0gPSBcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIjtcbn0pKFJlY292ZXIgfHwgKFJlY292ZXIgPSB7fSkpO1xuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrID09IHRoaXMuc3RhcnQuc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlIC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhcnQucC5wYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RoaXMuYmFzZSAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2ssIHBvcyA9IHN0YWNrLmJ1ZmZlckJhc2UgKyBzdGFjay5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3Ioc3RhY2ssIHBvcywgcG9zIC0gc3RhY2suYnVmZmVyQmFzZSk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8vLyBbVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxuLy8vIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuLy8vIGNoYXJhY3RlcnMsIHRyYWNraW5nIGxvb2thaGVhZCBhbmQgaGlkaW5nIHRoZSBjb21wbGV4aXR5IG9mXG4vLy8gW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuY2xhc3MgSW5wdXRTdHJlYW0ge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgaW5wdXQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgLy8vIEJhY2t1cCBjaHVua1xuICAgICAgICB0aGlzLmNodW5rMiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY2h1bmsyUG9zID0gMDtcbiAgICAgICAgLy8vIFRoZSBjaGFyYWN0ZXIgY29kZSBvZiB0aGUgbmV4dCBjb2RlIHVuaXQgaW4gdGhlIGlucHV0LCBvciAtMVxuICAgICAgICAvLy8gd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLy8vIExvb2sgYXQgYSBjb2RlIHVuaXQgbmVhciB0aGUgc3RyZWFtIHBvc2l0aW9uLiBgLnBlZWsoMClgIGVxdWFsc1xuICAgIC8vLyBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgLy8vIG9uLlxuICAgIC8vL1xuICAgIC8vLyBOb3RlIHRoYXQgbG9va2luZyBhcm91bmQgZHVyaW5nIHRva2VuaXppbmcgY3JlYXRlcyBkZXBlbmRlbmNpZXNcbiAgICAvLy8gb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICAvLy8gZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5nXHUyMDE0d2hlbiBsb29raW5nIGZvcndhcmRcdTIwMTRvciBldmVuXG4gICAgLy8vIGNhdXNlIGludmFsaWQgcmVwYXJzZXMgd2hlbiBsb29raW5nIGJhY2t3YXJkIG1vcmUgdGhhbiAyNSBjb2RlXG4gICAgLy8vIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBBY2NlcHQgYSB0b2tlbi4gQnkgZGVmYXVsdCwgdGhlIGVuZCBvZiB0aGUgdG9rZW4gaXMgc2V0IHRvIHRoZVxuICAgIC8vLyBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgLy8vIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgIGFjY2VwdFRva2VuKHRva2VuLCBlbmRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBlbmQgPSBlbmRPZmZzZXQgPyB0aGlzLnJlc29sdmVPZmZzZXQoZW5kT2Zmc2V0LCAtMSkgOiB0aGlzLnBvcztcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsIHx8IGVuZCA8IHRoaXMudG9rZW4uc3RhcnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRva2VuIGVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kO1xuICAgIH1cbiAgICBnZXRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGNodW5rLCBjaHVua1BvcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMjtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLmNodW5rMlBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IGNodW5rUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIGxldCBuZXh0Q2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMucG9zKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyArIG5leHRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gZW5kID4gdGhpcy5yYW5nZS50byA/IG5leHRDaHVuay5zbGljZSgwLCB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3MpIDogbmV4dENodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmdldENodW5rKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua09mZiA9PSB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdCh0aGlzLmNodW5rT2ZmKTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICAvLy8gdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgYWR2YW5jZShuID0gMSkge1xuICAgICAgICB0aGlzLmNodW5rT2ZmICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyArIG4gPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgIG4gLT0gdGhpcy5yYW5nZS50byAtIHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5yYW5nZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICBzZXREb25lKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleCA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykgeyByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIHRoaXMuaWQpOyB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8vLyBgQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG4vLy8gYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgLy8vIGdpdmVuIGFuIGlucHV0IHN0cmVhbSwgc2NhbnMgZm9yIHRoZSB0eXBlcyBvZiB0b2tlbnMgaXRcbiAgICAvLy8gcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIC8vLyBbYGFjY2VwdFRva2VuYF0oI2xyLklucHV0U3RyZWFtLmFjY2VwdFRva2VuKSB3aGVuIGl0IGZpbmRzXG4gICAgLy8vIG9uZS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYGlucHV0LnRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgc3RhY2ssIGdyb3VwKSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGlhbGVjdCB9ID0gcGFyc2VyO1xuICAgIHNjYW46IGZvciAoOzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC50b2tlbi52YWx1ZSA9PSAtMSB8fCBpbnB1dC50b2tlbi52YWx1ZSA9PSB0ZXJtIHx8IHBhcnNlci5vdmVycmlkZXModGVybSwgaW5wdXQudG9rZW4udmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBFbmQgKi8gJiYgZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDNdID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gMV07XG4gICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKDsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXSB8fCAweDEwMDAwO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG52YXIgU2FmZXR5O1xuKGZ1bmN0aW9uIChTYWZldHkpIHtcbiAgICBTYWZldHlbU2FmZXR5W1wiTWFyZ2luXCJdID0gMjVdID0gXCJNYXJnaW5cIjtcbn0pKFNhZmV0eSB8fCAoU2FmZXR5ID0ge30pKTtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICBjdXJzb3IubW92ZVRvKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gMjUgLyogTWFyZ2luICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgMjUgLyogTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFRva2VuaXplck1hc2sgKi8pO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN0YWNrLmN1ckNvbnRleHQgPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICBsZXQgbG9va0FoZWFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmxvb2tBaGVhZCA+IHRva2VuLmVuZCArIDI1IC8qIE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBFcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGFjdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHRlbmRlZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4uZXh0ZW5kZWQsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi52YWx1ZSwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbml6ZXIuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkluZGV4ID4gc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IGFjdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xuICAgICAgICBpZiAobG9va0FoZWFkKVxuICAgICAgICAgICAgc3RhY2suc2V0TG9va0FoZWFkKGxvb2tBaGVhZCk7XG4gICAgICAgIGlmICghbWFpbiAmJiBzdGFjay5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kKSB7XG4gICAgICAgICAgICBtYWluID0gbmV3IENhY2hlZFRva2VuO1xuICAgICAgICAgICAgbWFpbi52YWx1ZSA9IHN0YWNrLnAucGFyc2VyLmVvZlRlcm07XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gbWFpbi5lbmQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgbWFpbi52YWx1ZSwgbWFpbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG1haW47XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnM7XG4gICAgfVxuICAgIGdldE1haW5Ub2tlbihzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5tYWluVG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluVG9rZW47XG4gICAgICAgIGxldCBtYWluID0gbmV3IENhY2hlZFRva2VuLCB7IHBvcywgcCB9ID0gc3RhY2s7XG4gICAgICAgIG1haW4uc3RhcnQgPSBwb3M7XG4gICAgICAgIG1haW4uZW5kID0gTWF0aC5taW4ocG9zICsgMSwgcC5zdHJlYW0uZW5kKTtcbiAgICAgICAgbWFpbi52YWx1ZSA9IHBvcyA9PSBwLnN0cmVhbS5lbmQgPyBwLnBhcnNlci5lb2ZUZXJtIDogMCAvKiBFcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbih0aGlzLnN0cmVhbS5yZXNldChzdGFydCwgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dEFjdGlvbihhY3Rpb24sIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGUgYWN0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2ldID09IGFjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBhZGRBY3Rpb25zKHN0YWNrLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gc3RhY2ssIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIC8vIFdoZW4gdHdvIHN0YWNrcyBoYXZlIGJlZW4gcnVubmluZyBpbmRlcGVuZGVudGx5IGxvbmcgZW5vdWdoIHRvXG4gICAgLy8gYWRkIHRoaXMgbWFueSBlbGVtZW50cyB0byB0aGVpciBidWZmZXJzLCBwcnVuZSBvbmUuXG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gNTAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xuICAgIC8vIE9uY2UgYSBzdGFjayByZWFjaGVzIHRoaXMgZGVwdGggKGluIC5zdGFjay5sZW5ndGgpIGZvcmNlLXJlZHVjZVxuICAgIC8vIGl0IGJhY2sgdG8gQ3V0VG8gdG8gYXZvaWQgY3JlYXRpbmcgdHJlZXMgdGhhdCBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAvLyBvbiByZWN1cnNpdmUgdHJhdmVyc2FsLlxuICAgIFJlY1tSZWNbXCJDdXREZXB0aFwiXSA9IDE1MDAwXSA9IFwiQ3V0RGVwdGhcIjtcbiAgICBSZWNbUmVjW1wiQ3V0VG9cIl0gPSA5MDAwXSA9IFwiQ3V0VG9cIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDsgLy8gXHUyNjU0LCBcdTI2NTUsIFx1MjY1NiwgXHUyNjU3LCBcdTI2NTgsIFx1MjY1OSwgXHUyNjYwLCBcdTI2NjEsIFx1MjY2MiwgXHUyNjYzLCBcdTI2NjQsIFx1MjY2NSwgXHUyNjY2LCBcdTI2NjdcbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IDA7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV07XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5nZXRNYWluVG9rZW4oc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBEaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBNYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gMTUwMDAgLyogQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA5MDAwIC8qIEN1dFRvICovICYmIHN0YWNrLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjayk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBGb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLy8vIENvbnRleHQgdHJhY2tlcnMgYXJlIHVzZWQgdG8gdHJhY2sgc3RhdGVmdWwgY29udGV4dCAoc3VjaCBhc1xuLy8vIGluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbi8vLyBncmFtbWFyKSBuZWVkZWQgYnkgZXh0ZXJuYWwgdG9rZW5pemVycy4gWW91IGRlY2xhcmUgdGhlbSBpbiBhXG4vLy8gZ3JhbW1hciBmaWxlIGFzIGBAY29udGV4dCBleHBvcnROYW1lIGZyb20gXCJtb2R1bGVcImAuXG4vLy9cbi8vLyBDb250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxuLy8vIG9uIHNoaWZ0IG9yIHJlZHVjZSBhY3Rpb25zLlxuLy8vXG4vLy8gVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xuLy8vIHR5cGUuXG5jbGFzcyBDb250ZXh0VHJhY2tlciB7XG4gICAgLy8vIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzcGVjLnN0YXJ0O1xuICAgICAgICB0aGlzLnNoaWZ0ID0gc3BlYy5zaGlmdCB8fCBpZDtcbiAgICAgICAgdGhpcy5yZWR1Y2UgPSBzcGVjLnJlZHVjZSB8fCBpZDtcbiAgICAgICAgdGhpcy5yZXVzZSA9IHNwZWMucmV1c2UgfHwgaWQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHNwZWMuaGFzaCB8fCAoKCkgPT4gMCk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gc3BlYy5zdHJpY3QgIT09IGZhbHNlO1xuICAgIH1cbn1cbi8vLyBIb2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuLy8vIGBsZXplci1nZW5lcmF0b3JgLCBhbmQgcHJvdmlkZXMgW21ldGhvZHNdKCNjb21tb24uUGFyc2VyKSB0byBwYXJzZVxuLy8vIGNvbnRlbnQgd2l0aC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxNCAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IE5vZGVQcm9wW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmIChzcGVjLnByb3BTb3VyY2VzKVxuICAgICAgICAgICAgdGhpcy5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5zcGVjLnByb3BTb3VyY2VzKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBzcGVjLnNwZWNpYWxpemVkIHx8IFtdO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSB0aGlzLnNwZWNpYWxpemVyU3BlY3NbaV0udGVybTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKGdldFNwZWNpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLy8vIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IHBhaXIodGhpcy5kYXRhLCBpICsgMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICAvLy8gZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBvdmVycmlkZXModG9rZW4sIHByZXYpIHtcbiAgICAgICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHByZXYpO1xuICAgICAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCB0b2tlbikgPCBpUHJldjtcbiAgICB9XG4gICAgLy8vIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICAvLy8gZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICAvLy8ga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3BlY2lhbGl6ZXJzKSB7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyU3BlY3MgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnNwZWNpYWxpemVycy5maW5kKHIgPT4gci5mcm9tID09IHMuZXh0ZXJuYWwpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzKSwgeyBleHRlcm5hbDogZm91bmQudG8gfSk7XG4gICAgICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnNbaV0gPSBnZXRTcGVjaWFsaXplcihzcGVjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8vLyBUZWxscyB5b3Ugd2hldGhlciBhbnkgW3BhcnNlIHdyYXBwZXJzXSgjbHIuUGFyc2VyQ29uZmlnLndyYXApXG4gICAgLy8vIGFyZSByZWdpc3RlcmVkIGZvciB0aGlzIHBhcnNlci5cbiAgICBoYXNXcmFwcGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICAvLy8gdXNlciBjb2RlLlxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBFbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldFNwZWNpYWxpemVyKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5leHRlcm5hbCkge1xuICAgICAgICBsZXQgbWFzayA9IHNwZWMuZXh0ZW5kID8gMSAvKiBFeHRlbmQgKi8gOiAwIC8qIFNwZWNpYWxpemUgKi87XG4gICAgICAgIHJldHVybiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlYy5leHRlcm5hbCh2YWx1ZSwgc3RhY2spIDw8IDEpIHwgbWFzaztcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMuZ2V0O1xufVxuXG5leHBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIElucHV0U3RyZWFtLCBMUlBhcnNlciwgU3RhY2sgfTtcbiIsICJpbXBvcnQgeyBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuY29uc3QganNvbkhpZ2hsaWdodGluZyA9IHN0eWxlVGFncyh7XG4gIFN0cmluZzogdGFncy5zdHJpbmcsXG4gIE51bWJlcjogdGFncy5udW1iZXIsXG4gIFwiVHJ1ZSBGYWxzZVwiOiB0YWdzLmJvb2wsXG4gIFByb3BlcnR5TmFtZTogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIE51bGw6IHRhZ3MubnVsbCxcbiAgXCIsXCI6IHRhZ3Muc2VwYXJhdG9yLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2Vcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIkYk9WUVBPT09PUU8nI0NiJyNDYk9uUVBPJyNDZU92UVBPJyNDak9PUU8nI0NwJyNDcFFPUVBPT09PUU8nI0NnJyNDZ099UVBPJyNDZk8hU1FQTycjQ3JPT1FPLDU5UCw1OVBPIVtRUE8sNTlQTyFhUVBPJyNDdU9PUU8sNTlVLDU5VU8haVFQTyw1OVVPVlFQTyw1OVFPcVFQTycjQ2tPIW5RUE8sNTleT09RTzFHLmsxRy5rT1ZRUE8nI0NsTyF2UVBPLDU5YU9PUU8xRy5wMUcucE9PUU8xRy5sMUcubE9PUU8sNTlWLDU5Vk9PUU8tRTZpLUU2aU9PUU8sNTlXLDU5V09PUU8tRTZqLUU2alwiLFxuICBzdGF0ZURhdGE6IFwiI09+T2NPU35PUVNPUlNPU1NPVFNPV1FPXVJPZVBPfk9WWE9lVU9+T1tbT35QVk9nXk9+T2hfT1ZmWH5PVmFPfk9oYk9baVh+T1tkT35PaF9PVmZhfk9oYk9baWF+T1wiLFxuICBnb3RvOiBcIiFralBQUFBQUGtQUGtxd1BQa3shUlBQUCFYUCFlUFAhaFhTT1JeYlFXUVJmX1RWUV9RYFdSZ2BRY1pSaWNRVE9RWlJRZV5SaGJSWVFSXVJcIixcbiAgbm9kZU5hbWVzOiBcIlx1MjZBMCBKc29uVGV4dCBUcnVlIEZhbHNlIE51bGwgTnVtYmVyIFN0cmluZyB9IHsgT2JqZWN0IFByb3BlcnR5IFByb3BlcnR5TmFtZSBdIFsgQXJyYXlcIixcbiAgbWF4VGVybTogMjUsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcIm9wZW5lZEJ5XCIsIDcsXCJ7XCIsMTIsXCJbXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIDgsXCJ9XCIsMTMsXCJdXCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbanNvbkhpZ2hsaWdodGluZ10sXG4gIHNraXBwZWROb2RlczogWzBdLFxuICByZXBlYXROb2RlQ291bnQ6IDIsXG4gIHRva2VuRGF0YTogXCIocH5SYVhZIVdZWiFXXV4hV3BxIVdycyFdfH0kaX0hTyRuIVEhUiR3IVIhWyZWIVshXSZoIX0jTyZtI1AjUSZyI1kjWiZ3I2IjYydmI2gjaSd9I28jcChmI3EjcihrfiFdT2N+fiFgVXBxIV1xciFdcnMhcnMjTyFdI08jUCF3I1B+IV1+IXdPZX5+IXpYcnMhXSFQIVEhXSNPI1AhXSNVI1YhXSNZI1ohXSNiI2MhXSNmI2chXSNoI2khXSNpI2ojZ34jalIhUSFbI3MhYyFpI3MjVCNaI3N+I3ZSIVEhWyRQIWMhaSRQI1QjWiRQfiRTUiFRIVskXSFjIWkkXSNUI1okXX4kYFIhUSFbIV0hYyFpIV0jVCNaIV1+JG5PaH5+JHFRIVEhUiR3IVIhWyZWfiR8UlR+IU8hUCVWIWchaCVrI1gjWSVrfiVZUCFRIVslXX4lYlJUfiFRIVslXSFnIWglayNYI1kla34lblJ7fCV3fSFPJXchUSFbJX1+JXpQIVEhWyV9fiZTUFR+IVEhWyV9fiZbU1R+IU8hUCVWIVEhWyZWIWchaCVrI1gjWSVrfiZtT2d+fiZyT11+fiZ3T1t+fiZ6UCNUI1UmfX4nUVAjYCNhJ1R+J1dQI2cjaCdafideUCNYI1knYX4nZk9Sfn4naVAjaSNqJ2x+J29QI2AjYSdyfid1UCNgI2EneH4nfU9Tfn4oUVAjZiNnKFR+KFdQI2kjaihafiheUCNYI1koYX4oZk9Rfn4oa09Xfn4ocE9WflwiLFxuICB0b2tlbml6ZXJzOiBbMF0sXG4gIHRvcFJ1bGVzOiB7XCJKc29uVGV4dFwiOlswLDFdfSxcbiAgdG9rZW5QcmVjOiAwXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iLCAiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL2pzb24nO1xuaW1wb3J0IHsgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGNvbnRpbnVlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQ2FsbHNcbltgSlNPTi5wYXJzZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vcGFyc2UpXG5vbiB0aGUgZG9jdW1lbnQgYW5kLCBpZiB0aGF0IHRocm93cyBhbiBlcnJvciwgcmVwb3J0cyBpdCBhcyBhXG5zaW5nbGUgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBqc29uUGFyc2VMaW50ZXIgPSAoKSA9PiAodmlldykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2Uodmlldy5zdGF0ZS5kb2MudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICBjb25zdCBwb3MgPSBnZXRFcnJvclBvc2l0aW9uKGUsIHZpZXcuc3RhdGUuZG9jKTtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICB0bzogcG9zXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcbmZ1bmN0aW9uIGdldEVycm9yUG9zaXRpb24oZXJyb3IsIGRvYykge1xuICAgIGxldCBtO1xuICAgIGlmIChtID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvYXQgcG9zaXRpb24gKFxcZCspLykpXG4gICAgICAgIHJldHVybiBNYXRoLm1pbigrbVsxXSwgZG9jLmxlbmd0aCk7XG4gICAgaWYgKG0gPSBlcnJvci5tZXNzYWdlLm1hdGNoKC9hdCBsaW5lIChcXGQrKSBjb2x1bW4gKFxcZCspLykpXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihkb2MubGluZSgrbVsxXSkuZnJvbSArICgrbVsyXSkgLSAxLCBkb2MubGVuZ3RoKTtcbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIHRoYXQgcHJvdmlkZXMgSlNPTiBwYXJzaW5nLlxuKi9cbmNvbnN0IGpzb25MYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJqc29uXCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBPYmplY3Q6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKlxcfS8gfSksXG4gICAgICAgICAgICAgICAgQXJyYXk6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKlxcXS8gfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIFwiT2JqZWN0IEFycmF5XCI6IGZvbGRJbnNpZGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY2xvc2VCcmFja2V0czogeyBicmFja2V0czogW1wiW1wiLCBcIntcIiwgJ1wiJ10gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqW1xcfVxcXV0kL1xuICAgIH1cbn0pO1xuLyoqXG5KU09OIGxhbmd1YWdlIHN1cHBvcnQuXG4qL1xuZnVuY3Rpb24ganNvbigpIHtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChqc29uTGFuZ3VhZ2UpO1xufVxuXG5leHBvcnQgeyBqc29uLCBqc29uTGFuZ3VhZ2UsIGpzb25QYXJzZUxpbnRlciB9O1xuIiwgImltcG9ydCB7IGJhc2ljU2V0dXAsIEVkaXRvclZpZXcgfSBmcm9tIFwiY29kZW1pcnJvclwiXG5pbXBvcnQgeyBqc29uIH0gZnJvbSBcIkBjb2RlbWlycm9yL2xhbmctanNvblwiXG5pbXBvcnQgeyBpbmRlbnRXaXRoVGFiIH0gZnJvbSAnQGNvZGVtaXJyb3IvY29tbWFuZHMnO1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvdmlldydcblxuZXhwb3J0IGRlZmF1bHQgKEFscGluZSkgPT4ge1xuICAgIEFscGluZS5kYXRhKCdmaWxhbWVudEpzb25GaWVsZCcsICh7IHN0YXRlLCBkaXNhYmxlZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Rpc2FibGVkOiAnICsgZGlzYWJsZWQgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgbmV3IEVkaXRvclZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBkb2M6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuYnVpbGRFeHRlbnNpb25zQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLiRyZWZzLmpzb25CbG9ja1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnVpbGRFeHRlbnNpb25zQXJyYXkoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGJhc2ljU2V0dXAsXG4gICAgICAgICAgICAgICAgICAgIGpzb24oKSxcbiAgICAgICAgICAgICAgICAgICAga2V5bWFwLm9mKFtpbmRlbnRXaXRoVGFiXSksXG4gICAgICAgICAgICAgICAgICAgIEVkaXRvclZpZXcubGluZVdyYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHYuc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgY29udGVudGVkaXRhYmxlOiAhZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGNvbmRpdGlvbmFsIGV4dGVuc2lvbnMuLi5cblxuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0IEpzb25GaWVsZEFscGluZVBsdWdpbiBmcm9tICcuL2NvbXBvbmVudHMvanNvbi1maWVsZCc7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2FscGluZTppbml0JywgKCkgPT4ge1xuICAgIHdpbmRvdy5BbHBpbmUucGx1Z2luKEpzb25GaWVsZEFscGluZVBsdWdpbik7XG59KVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7QUFHQSxtQkFBVztBQUFBLElBSVAsY0FBYztBQUFBO0FBQUEsSUFJZCxPQUFPLEtBQUs7QUFDUixVQUFJLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDdEIsY0FBTSxJQUFJLFdBQVcsb0JBQW9CLDZCQUE2QixLQUFLO0FBQy9FLGFBQU8sS0FBSyxVQUFVLEtBQUssT0FBTyxHQUFHO0FBQUE7QUFBQSxJQUt6QyxLQUFLLEdBQUc7QUFDSixVQUFJLElBQUksS0FBSyxJQUFJLEtBQUs7QUFDbEIsY0FBTSxJQUFJLFdBQVcsdUJBQXVCLFFBQVEsS0FBSztBQUM3RCxhQUFPLEtBQUssVUFBVSxHQUFHLE1BQU0sR0FBRztBQUFBO0FBQUEsSUFLdEMsUUFBUSxNQUFNLElBQUksTUFBTTtBQUNwQixVQUFJLFFBQVE7QUFDWixXQUFLLFVBQVUsR0FBRyxNQUFNLE9BQU87QUFDL0IsVUFBSSxLQUFLO0FBQ0wsYUFBSyxVQUFVLEdBQUcsS0FBSyxRQUFRLE9BQU8sSUFBb0I7QUFDOUQsV0FBSyxVQUFVLElBQUksS0FBSyxRQUFRLE9B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SUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBO0FBR0EsTUFBSSxRQUFRO0FBQUEsSUFDakIsSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osSUFBSTtBQUFBLElBQ0osS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFB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
