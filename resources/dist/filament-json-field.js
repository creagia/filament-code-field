(() => {
  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string2 = this.text[i], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from, to, text);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      if (text.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i] = updated;
              return new TextNode(copy, this.length - (to - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
      let line = text[i], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let {value} = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let {done, lineBreak, value} = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
      if (extend[i] > code)
        return extend[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json2) {
      if (!Array.isArray(json2) || json2.length % 2 || json2.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json2);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index = i >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set = new ChangeSet(sections, inserted);
        total = total ? total.compose(set.map(total)) : set;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let {from, to = from, insert: insert2} = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json2) {
      if (!Array.isArray(json2))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json2.length; i++) {
        let part = json2[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert2)
              addInsert(insert2, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left = a.len;
        while (left) {
          if (b.ins == -1) {
            let piece = Math.min(left, b.len);
            len += piece;
            left -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert2 && inserted < a.i)
          addInsert(insert2, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set) {
      this.set = set;
      this.i = 0;
      this.next();
    }
    next() {
      let {sections} = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let {inserted} = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let {inserted} = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return {anchor: this.anchor, head: this.head};
    }
    static fromJSON(json2) {
      if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json2.anchor, json2.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range, main = true) {
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return {ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex};
    }
    static fromJSON(json2) {
      if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        if (range.empty ? range.from <= pos : range.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i = 1; i < ranges.length; i++) {
        let range = ranges[i], prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection3, docLength) {
    for (let range of selection3.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get)
        get = (x) => x;
      return this.compute([field], (state) => get(state.field(field)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
      let values = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({static: true});
  var StateField = class {
    constructor(id, createF, updateF, compareF, spec) {
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i) => i.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create) {
      return [this, initField.of({field: this, create})];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = {lowest: 4, low: 3, default: 2, high: 1, highest: 0};
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({compartment: this, extension: content2});
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = Object.create(null);
      let newCompartments = new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id in facets) {
        let providers = facets[id], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map) {
      this.map = map;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState, changes, selection3, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection3;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection3)
        checkSelection(selection3, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection3, effects, annotations, scrollIntoView3) {
      return new Transaction(startState, changes, selection3, effects, annotations, scrollIntoView3);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch = str[i];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config2, doc2, selection3, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection3;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, {base: base2, compartments} = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: {from: range.from, to: range.to, insert: text},
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json2, config2 = {}, fields) {
      if (!json2 || typeof json2.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json2, prop)) {
            let field = fields[prop], value = json2[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json2.doc,
        selection: EditorSelection.fromJSON(json2.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], new Map());
      let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection3 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection3, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection3 = selection3.asSingle();
      return new EditorState(configuration, doc2, selection3, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
          phrase2 = map[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$")
            return "$";
          let n = +(i || 1);
          return !n || n > insert2.length ? m : insert2[n - 1];
        });
      return phrase2;
    }
    languageDataAt(name2, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values.push(result[name2]);
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let {text, from, length} = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak(text, start, false);
        if (cat(text.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key of Object.keys(config2)) {
        let value = config2[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults3)
      if (result[key] === void 0)
        result[key] = defaults3[key];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return {mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos};
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let {add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length} = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i < add2.length) {
        if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
          let range = add2[i++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({add: spill, filter, filterFrom, filterTo}));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let {mapped, pos} = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
      let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor3 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let open = cursor3.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor3.to, to);
        if (cursor3.point) {
          iterator.point(pos, curTo, cursor3.point, cursor3.activeForPoint(cursor3.to), open, cursor3.pointRank);
          open = cursor3.openEnd(curTo) + (cursor3.to > curTo ? 1 : 0);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor3.active, open);
          open = cursor3.openEnd(curTo);
        }
        if (cursor3.to > to)
          break;
        pos = cursor3.to;
        cursor3.next();
      }
      return open;
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur2 = ranges[i];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
      for (let i = 0; i < set.chunk.length; i++)
        if (set.chunk[i].maxPoint <= 0)
          inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
      for (let i = 0; i < set.chunk.length; i++) {
        let known = inA.get(set.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
          shared.add(set.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur2 = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, {value, to, rank} = this.cursor;
      while (i < this.activeRank.length && this.activeRank[i] <= rank)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            if (this.cursor.from < from && this.cursor.to > from)
              trackExtra++;
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            if (this.cursor.from < from)
              trackExtra = 1;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        let openStart = 0;
        while (openStart < trackOpen.length && trackOpen[openStart] < from)
          openStart++;
        this.openStart = openStart + trackExtra;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
      array[i] = array[i + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
      array[i + 1] = array[i];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array.length; i++)
      if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array[i];
      }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n = 0;
    for (let i = 0; i < to; ) {
      if (string2.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string2, i);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string2.length)
        break;
      n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string2, i);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let {finish} = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id = top[COUNT] || 1;
      top[COUNT] = id + 1;
      return C + id.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i = 0; i < this.modules.length; i++)
          text += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (var i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  for (var i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (var code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc")
      name2 = "Escape";
    if (name2 == "Del")
      name2 = "Delete";
    if (name2 == "Left")
      name2 = "ArrowLeft";
    if (name2 == "Up")
      name2 = "ArrowUp";
    if (name2 == "Right")
      name2 = "ArrowRight";
    if (name2 == "Down")
      name2 = "ArrowDown";
    return name2;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection3) {
    if (!selection3.anchorNode)
      return false;
    try {
      return contains(dom, selection3.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = {left: 0, right: 0, top: 0, bottom: 0};
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return {left: x, right: x, top: rect.top, bottom: rect.bottom};
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur2 = dom; cur2; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY;
              movedY = cur2.scrollTop - start;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX;
              movedX = cur2.scrollLeft - start;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y = "nearest";
          }
        }
        if (top2)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = {preventScroll: true};
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top2 = stack[i++], left = stack[i++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name2, code) {
    let options = {key: name2, code: name2, keyCode: code, which: code, cancelable: true};
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection3) {
    let node = selection3.focusNode, offset = selection3.focusOffset;
    if (!node || selection3.anchorNode != node || selection3.anchorOffset != offset)
      return false;
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i = from; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children);
      for (let i = 0; i < children.length; i++)
        children[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i) {
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let {children} = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let {i: toI, off: toOff} = cur2.findPos(to, 1);
    let {i: fromI, off: fromOff} = cur2.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : {userAgent: "", vendor: "", platform: ""};
  var doc = typeof document != "undefined" ? document : {documentElement: {style: {}}};
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source) {
      if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return {from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling};
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i;
        off = end;
        i++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view = top2.editorView, text = view && view.state.doc, start = this.posAtStart;
      return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return this.length ? rect : flattenRect(rect, this.side > 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let {topView, text} = this.widget;
      if (!topView)
        return new DOMPos(text, Math.min(pos, text.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), (p) => new DOMPos(text, Math.min(p, text.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let {topView, text} = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let {topView, text} = this.widget;
      if (!topView)
        return textCoords(text, pos, side);
      return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
    canReuseDOM() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view, text, enterView, fromText) {
    if (view instanceof MarkView) {
      for (let child = view.dom.firstChild; child; child = child.nextSibling) {
        let desc = ContentView.get(child);
        if (!desc)
          return fromText(pos, side);
        let hasComp = contains(child, text);
        let len = desc.length + (hasComp ? text.nodeValue.length : 0);
        if (pos < len || pos == len && desc.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);
        pos -= len;
      }
      return enterView(view, view.length, -1);
    } else if (view.dom == text) {
      return fromText(pos, side);
    } else {
      return enterView(view, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view, text) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let pos = 0, hasComp = contains(child.dom, text);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text.nodeValue.length : child.length;
      }
    } else if (view.dom == text) {
      return Math.min(offset, text.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? {left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom} : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view, side) {
    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
      if (side < 0 ? index > 0 : index < parent.children.length) {
        let next = parent.children[index + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last = parent.dom.lastChild;
        if (last && last.nodeName == "BR")
          return last.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, {children} = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
      let child = children[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j = i; j > 0; j--) {
      let prev = children[j - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
      let next = children[j];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, {children} = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
        let child = view2.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if (!after && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  function attrsEq(a, b) {
    if (a == b)
      return true;
    if (!a || !b)
      return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key of keysA) {
      if (keysB.indexOf(key) == -1 || a[key] !== b[key])
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = null;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs))
          dom.removeAttribute(changed = name2);
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2]))
          dom.setAttribute(changed = name2, attrs[name2]);
    }
    return !!changed;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let {start, end} = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let {start, end} = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let {inclusiveStart: start, inclusiveEnd: end} = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return {start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block};
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
      ranges[last] = Math.max(ranges[last], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let {i, off} = this.childPos(at);
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({class: cls}, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, type) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer([]);
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (!openEnd)
        this.flushBuffer([]);
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let {value, lineBreak, done} = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer([]);
            this.curLine = null;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(0, openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let {type} = deco;
          if (type == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to ? 1 : 2;
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var ScrollTarget = class {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({map: (t2, ch) => t2.map(ch)});
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({combine: (values) => values.length ? values[0] : true});
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id, create, domEventHandlers, buildExtensions) {
      this.id = id;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const {eventHandlers, provide, decorations: deco} = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e) {
            logException(update.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
      let i = set.length, me = this;
      for (; i > 0; i--) {
        let range = set[i - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set.splice(i - 1, 1);
      }
      set.splice(i, 0, me);
      return set;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
    static create(view, state, transactions) {
      return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span = order[i];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i = 0; i < len; i++) {
      if (types[i] == 256) {
        let end = i + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i ? types[i - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] != 1;
        while (i < len && rtl == (types[i] != 1))
          i++;
        if (rtl) {
          for (let j = i; j > start; ) {
            let end = j, l = types[--j] != 2;
            while (j > start && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i, 0));
        }
      }
    } else {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] == 2;
        while (i < len && rtl == (types[i] == 2))
          i++;
        order.push(new BidiSpan(start, i, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re.exec(text)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update) {
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({fromA, toA}) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let {observer} = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? {node: observer.selectionRange.focusNode, written: false} : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor3 = this.childCursor(oldLength);
      for (let i = changes.length - 1; ; i--) {
        let next = i >= 0 ? changes[i] : null;
        if (!next)
          break;
        let {fromA, toA, fromB, toB} = next;
        let {content: content2, breakAtStart, openStart, openEnd} = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let {i: toI, off: toOff} = cursor3.findPos(toA, 1);
        let {i: fromI, off: fromOff} = cursor3.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({preventScroll: true});
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let {view} = this, cursor3 = view.state.selection.main;
      let sel = getSelection(view.root);
      let {anchorNode, anchorOffset} = view.observer.selectionRange;
      if (!sel || !cursor3.empty || !cursor3.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor3.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor3.head == lineStart || cursor3.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor3.head, -1), after = this.coordsAt(cursor3.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor3.head + cursor3.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor3.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor3.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    mayControlSelection() {
      let active = this.view.root.activeElement;
      return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let {i, off} = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i = this.children.length - 1; ; i--) {
        let child = this.children[i], start = off - child.breakAfter - child.length;
        if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start, side);
        off = start;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], {from, to} = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let {i} = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return {lineHeight, charWidth};
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d, i) => {
        let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      for (let i = allDeco.length; i < allDeco.length + 3; i++)
        this.dynamicDecorationMap[i] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let {range} = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let {left, right, top: top2, bottom} = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return {from: pos, to: pos, node: topNode, text: textNode};
    } else {
      for (; ; ) {
        let {parent} = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from = cView.posAtStart;
      return {from, to: from + cView.length, node: cView.dom, text: textNode};
    }
  }
  function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding)
      return Decoration.none;
    let {from, to, node, text: textNode} = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let {state} = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
      if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
        newTo = newFrom + text.length;
      else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
        newFrom = newTo - text.length;
      else
        return Decoration.none;
    } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({widget: new CompositionWidget(node, textNode, topView), inclusive: true}).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text, topView) {
      super();
      this.top = top2;
      this.text = text;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? {top: top2, left: rect.left, right: rect.right, bottom: rect.bottom} : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? {top: rect.top, left: rect.left, right: rect.right, bottom} : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return {node: parent, offset: 0};
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {node: parent, offset};
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return {node, offset: i + (after ? 1 : 0)};
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return {node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0};
  }
  function posAtCoords(view, {x, y}, precise, bias = -1) {
    var _a2;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, {docHeight} = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
    if (!element) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element = root.elementFromPoint(x, y);
      if (element && !view.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          ({offsetNode: node, offset} = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          ({startContainer: node, startOffset: offset} = range);
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({node, offset} = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
      return false;
    for (let cur2 = node; ; ) {
      let parent = cur2.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur2 = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view, {x: resolvedGoal, y: curY}, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start.assoc, void 0, goal);
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let atoms = view.state.facet(atomicRanges).map((f) => f(view));
    for (; ; ) {
      let moved = false;
      for (let set of atoms) {
        set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
          if (pos.from > from && pos.from < to) {
            pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.mouseSelection = null;
      for (let type in handlers) {
        let handler = handlers[type];
        view.contentDOM.addEventListener(type, (event) => {
          if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
            return;
          if (type == "keydown" && this.keydown(view, event))
            return;
          if (this.mustFlushObserver(event))
            view.observer.forceFlush();
          if (this.runCustomHandlers(type, view, event))
            event.preventDefault();
          else
            handler(view, event);
        }, handlerOptions[type]);
        this.registeredEvents.push(type);
      }
      if (browser.chrome && browser.chrome_version == 102) {
        view.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view.contentDOM.style.pointerEvents = "";
          }, 100);
        }, {passive: true});
      }
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
      var _a2;
      let handlers2;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers2 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({plugin: plugin.value, handlers: handlers2});
          for (let type in handlers2)
            if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
              this.registeredEvents.push(type);
              view.contentDOM.addEventListener(type, (event) => {
                if (!eventBelongsToEditor(view, event))
                  return;
                if (this.runCustomHandlers(type, view, event))
                  event.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type, view, event) {
      for (let set of this.customHandlers) {
        let handler = set.handlers[type];
        if (handler) {
          try {
            if (handler.call(set.plugin, event, view) || event.defaultPrevented)
              return true;
          } catch (e) {
            logException(view.state, e);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      this.lastScrollTop = view.scrollDOM.scrollTop;
      this.lastScrollLeft = view.scrollDOM.scrollLeft;
      for (let set of this.customHandlers) {
        let handler = set.handlers.scroll;
        if (handler) {
          try {
            handler.call(set.plugin, event, view);
          } catch (e) {
            logException(view.state, e);
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    {key: "Backspace", keyCode: 8, inputType: "deleteContentBackward"},
    {key: "Enter", keyCode: 13, inputType: "insertParagraph"},
    {key: "Delete", keyCode: 46, inputType: "deleteContentForward"}
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.style = style;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      let selection3 = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection3.eq(this.view.state.selection) || selection3.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection: selection3,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
      this.mustSelect = false;
    }
    update(update) {
      if (update.docChanged && this.dragging)
        this.dragging = this.dragging.map(update.changes);
      if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let {main} = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var handlerOptions = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let {state} = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return {range};
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
        return {
          changes: {from: line.from, insert: insert2},
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text.line(i++);
        return {
          changes: {from: range.from, to: range.to, insert: line.text},
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
      view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      view.inputState.lastEscPress = 0;
  };
  handlers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlerOptions.touchstart = handlerOptions.touchmove = {passive: true};
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3)
      return;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view, event);
    if (style) {
      let mustFocus = view.root.activeElement != view.contentDOM;
      if (mustFocus)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
  var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
      return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    return {pos, bias: findPositionSide(view, pos, event.clientX, event.clientY)};
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start, lastEvent = event;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
          lastEvent = null;
        }
      },
      get(event2, extend2, multiple) {
        let cur2;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur2 = last;
        else {
          cur2 = last = queryPos(view, event2);
          lastEvent = event2;
        }
        let range = rangeForClick(view, cur2.pos, cur2.bias, type);
        if (start.pos != cur2.pos && !extend2) {
          let startRange = rangeForClick(view, start.pos, start.bias, type);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend2)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range)))
          return removeRange(startSel, range);
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  function removeRange(sel, range) {
    for (let i = 0; ; i++) {
      if (sel.ranges[i].eq(range))
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
  }
  handlers.dragstart = (view, event) => {
    let {selection: {main}} = view.state;
    let {mouseSelection} = view.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    event.preventDefault();
    let {mouseSelection} = view.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {from: mouseSelection.dragging.from, to: mouseSelection.dragging.to} : null;
    let ins = {from: dropPos, insert: text};
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: {anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1)},
      userEvent: del ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = (view, event) => {
    if (!event.dataTransfer)
      return;
    if (view.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly)
      return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let {from} of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({from: line.from, to: Math.min(state.doc.length, line.to + 1)});
        }
        upto = line.number;
      }
      linewise = true;
    }
    return {text: content2.join(state.lineBreak), ranges, linewise};
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    let {text, ranges, linewise} = copiedRange(view.state);
    if (!text && !linewise)
      return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text);
    } else {
      captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  function updateForFocusChange(view) {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused)
        view.update([]);
    }, 10);
  }
  handlers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  handlers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  handlers.compositionstart = handlers.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android)
      view.observer.flushSoon();
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
        view.update([]);
    }, 50);
  };
  handlers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h = knownHeights[i];
          if (h < 0)
            i++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length, top2, height, type) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i = changes.length - 1; i >= 0; i--) {
        let {fromA, toA, fromB, toB} = changes[i];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split = nodes[i - 1];
            if (split.break)
              nodes.splice(--i, 1, split.left, null, split.right);
            else
              nodes.splice(--i, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, type) {
      super(length, height);
      this.type = type;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      if (from <= offset + this.length && to >= offset)
        f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    lines(doc2, offset) {
      let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
      return {firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1)};
    }
    blockAt(height, doc2, top2, offset) {
      let {firstLine, lastLine, lineHeight} = this.lines(doc2, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let {from, length} = doc2.line(firstLine + line);
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc2, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, doc2, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let {from: from2, to} = doc2.lineAt(value);
        return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
      }
      let {firstLine, lineHeight} = this.lines(doc2, offset);
      let {from, length, number: number2} = doc2.lineAt(value);
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let {firstLine, lineHeight} = this.lines(doc2, offset);
      for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        let line = doc2.lineAt(pos);
        if (pos == from)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        let wasChanged = oracle.heightChanged;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc2, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, doc2, top2, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let {left, right} = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let {from, to} = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size) {
      this.from = from;
      this.to = to;
      this.size = size;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA = a[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({widget: new LineGapWidget(this.size, wrapping)}).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = {left: 0, right: window.innerWidth, top: 0, bottom: 0};
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], {main} = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main.head : main.anchor;
        if (!viewports.some(({from, to}) => pos >= from && pos <= to)) {
          let {from, to} = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
      this.contentDOMHeight = dom.clientHeight;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = dom.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let {lineHeight, charWidth} = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map = this.heightMap, doc2 = this.state.doc, {visibleTop, visibleBottom} = this;
      let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTarget) {
        let {head} = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({from, to}, bias = 0) {
      if (!this.inView)
        return true;
      let {top: top2} = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
      let {bottom} = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
      let {visibleTop, visibleBottom} = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
        }
        gaps.push(gap);
      };
      for (let line of this.viewportLines) {
        if (line.length < doubleMargin)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          continue;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (this.pixelViewport.left - marginWidth) / totalWidth;
            right = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({from, to});
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({from: pos, to: from2});
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({from: pos, to});
      total += to - pos;
    }
    return {total, ranges};
  }
  function findPosition({total, ranges}, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let {from, to} = ranges[i], size = to - from;
      if (dist <= size)
        return from + dist;
      dist -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let {from, to} of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc2, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({from, to}) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return {from, to, top: top2, bottom, domTop: 0, domBottom: 0};
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({combine: (strs) => strs.join(" ")});
  var darkTheme = /* @__PURE__ */ Facet.define({combine: (values) => values.indexOf(true) > -1});
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = {"&light": "." + baseLightID, "&dark": "." + baseDarkID};
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&.cm-editor": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {caretColor: "black"},
    "&dark .cm-content": {caretColor: "white"},
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
      zIndex: -1,
      contain: "size style"
    },
    ".cm-selectionBackground": {
      position: "absolute"
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      zIndex: 100,
      contain: "size style",
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {"0%": {}, "50%": {opacity: 0}, "100%": {}},
    "@keyframes cm-blink2": {"0%": {}, "50%": {opacity: 0}, "100%": {}},
    ".cm-cursor, .cm-dropCursor": {
      position: "absolute",
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": {backgroundColor: "#cceeff44"},
    "&dark .cm-activeLine": {backgroundColor: "#99eeff33"},
    "&light .cm-specialChar": {color: "red"},
    "&dark .cm-specialChar": {color: "#f78"},
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var DOMChange = class {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      let {impreciseHead: iHead, impreciseAnchor: iAnchor} = view.docView;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view, domChange) {
    let change;
    let {newSel} = domChange, sel = view.state.selection.main;
    if (domChange.bounds) {
      let {from, to} = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus || !view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = {from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to)};
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString())) {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {from: sel.from, to: sel.to, insert: Text.of([" "])};
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {from: sel.from, to: sel.to, insert: Text.of([" "])};
    }
    if (change) {
      let startState = view.state;
      if (browser.ios && view.inputState.flushIOSKey(view))
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
        return true;
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          let replaced = view.state.sliceDoc(change.from, change.to);
          let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
          let offset = sel.to - change.to, size = sel.to - sel.from;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return {changes, range: mainSel || range.map(changes)};
            let to = range.to - offset, from = to - replaced.length;
            if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
              return {range};
            let rangeChanges = startState.changes({from, to, insert: change.insert}), selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, {scrollIntoView: true, userEvent});
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({selection: newSel, scrollIntoView: scrollIntoView3, userEvent});
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return {from, toA, toB};
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let {anchorNode, anchorOffset, focusNode, focusOffset} = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resize = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resize = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resize.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runScrollHandlers(this.view, e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let {view} = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let {view} = this;
      let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
      if (!range || this.selectionRange.eq(range))
        return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            if (!this.flush() && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({from, to} = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return {from, to, typeOver};
    }
    readChange() {
      let {from, to, typeOver} = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      return new DOMChange(this.view, from, to, typeOver);
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange)
        return false;
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return {from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue};
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return {anchorNode, anchorOffset, focusNode, focusOffset};
  }
  var EditorView = class {
    constructor(config2 = {}) {
      this.plugins = [];
      this.pluginMap = new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config2.parent)
        config2.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let {main} = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e of tr.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value;
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update);
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force)
          dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let {scrollHeight, scrollTop, clientHeight} = this.scrollDOM;
      let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
      try {
        for (let i = 0; ; i++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let refBlock = this.viewState.lineBlockAtHeight(refHeight);
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m = measuring[i2];
                if (m.write)
                  m.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrolled = true;
            } else {
              let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
              if (diff > 1 || diff < -1) {
                this.scrollDOM.scrollTop += diff;
                scrolled = true;
              }
            }
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom};
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), {eventHandlers: handlers2});
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({class: "cm-lineWrapping"});
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty)
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        let entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source = sources[i], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift2) {
    if (event.altKey)
      name2 = "Alt-" + name2;
    if (event.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({enables: handleKeyEvents});
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
      Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is;
      else if (current != is)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key, command2, preventDefault) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            run: [(view) => {
              let ourObj = storedPrefix = {view, prefix, scope};
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []});
      if (command2)
        binding.run.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = {preventDefault: false, run: []};
          for (let key in scopeObj)
            scopeObj[key].run.push(b.any);
        }
      let name2 = b[platform] || b.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add2(scope, name2, b.run, b.preventDefault);
        if (b.shift)
          add2(scope, "Shift-" + name2, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map, event, view, scope) {
    let name2 = keyName(event);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let ran = new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view, event))
              return true;
          }
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
        return true;
      if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
          return true;
        else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
          return true;
      }
      if (runFor(scopeObj._any))
        return true;
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      drawSelectionPlugin,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  var Piece = class {
    constructor(left, top2, width, height, className) {
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
      this.className = className;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width >= 0)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
  };
  var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.rangePieces = [];
      this.cursors = [];
      this.measureReq = {read: this.readPos.bind(this), write: this.drawSel.bind(this)};
      this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.selectionLayer.className = "cm-selectionLayer";
      this.selectionLayer.setAttribute("aria-hidden", "true");
      this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.cursorLayer.className = "cm-cursorLayer";
      this.cursorLayer.setAttribute("aria-hidden", "true");
      view.requestMeasure(this.measureReq);
      this.setBlinkRate();
    }
    setBlinkRate() {
      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
      let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
      if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
        this.view.requestMeasure(this.measureReq);
      if (update.transactions.some((tr) => tr.scrollIntoView))
        this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      if (confChanged)
        this.setBlinkRate();
    }
    readPos() {
      let {state} = this.view, conf = state.facet(selectionConfig);
      let rangePieces = state.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
      let cursors = [];
      for (let r of state.selection.ranges) {
        let prim = r == state.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(this.view, r, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return {rangePieces, cursors};
    }
    drawSel({rangePieces, cursors}) {
      if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
        this.selectionLayer.textContent = "";
        for (let p of rangePieces)
          this.selectionLayer.appendChild(p.draw());
        this.rangePieces = rangePieces;
      }
      if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
        let oldCursors = this.cursorLayer.children;
        if (oldCursors.length !== cursors.length) {
          this.cursorLayer.textContent = "";
          for (const c of cursors)
            this.cursorLayer.appendChild(c.draw());
        } else {
          cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
        }
        this.cursors = cursors;
      }
    }
    destroy() {
      this.selectionLayer.remove();
      this.cursorLayer.remove();
    }
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": {backgroundColor: "transparent !important"},
      "&::selection": {backgroundColor: "transparent !important"}
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return {left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop};
  }
  function wrappedLine(view, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
      return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new Piece(left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01, "cm-selectionBackground");
    }
    function pieces({top: top2, bottom, horizontal}) {
      let pieces2 = [];
      for (let i = 0; i < horizontal.length; i += 2)
        pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r of view.visibleRanges)
        if (r.to > start && r.from < end) {
          for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start, from2 == null, end, to2 == null, view.textDirection);
      return {top: top2, bottom, horizontal};
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return {top: y, bottom: y, horizontal: []};
    }
  }
  function measureCursor(view, cursor3, primary) {
    let pos = view.coordsAtPos(cursor3.head, cursor3.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view);
    return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
  }
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = {read: this.readPos.bind(this), write: this.drawCursor.bind(this)};
    }
    update(update) {
      var _a2;
      let cursorPos = update.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let pos = this.view.state.field(dropCursorPos);
      let rect = pos != null && this.view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = this.view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        if (pos) {
          this.cursor.style.left = pos.left + "px";
          this.cursor.style.top = pos.top + "px";
          this.cursor.style.height = pos.height + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({effects: setDropCursorPos.of(pos)});
    }
  }, {
    eventHandlers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({x: event.clientX, y: event.clientY}));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor3 = doc2.iterRange(from, to), pos = from, m; !cursor3.next().done; pos += cursor3.value.length) {
      if (!cursor3.lineBreak)
        while (m = re.exec(cursor3.value))
          f(pos + m.index, m);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let {from, to} of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from)
        result[result.length - 1].to = to;
      else
        result.push({from, to});
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config2) {
      const {regexp, decoration, decorate, boundary, maxLength = 1e3} = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view, from, add2) => {
          let deco = decoration(match, view, from);
          if (deco)
            add2(from, from + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder(), add2 = build.add.bind(build);
      for (let {from, to} of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add2));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f, _t, from, to) => {
          if (to > update.view.viewport.from && from < update.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start = from;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m;
          let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
              this.addMatch(m, view, m.index + fromLine.from, add2);
          } else {
            iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add2));
          }
          deco = deco.update({filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges});
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let {doc: doc2} = view.state;
            let code = codePointAt(m[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)});
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({widget: new SpecialCharWidget(conf, code)}));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({class: "cm-activeLine"});
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
      let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        let start = findColumn(line.text, startCol, state.tabSize, true);
        if (start < 0) {
          ranges.push(EditorSelection.cursor(line.to));
        } else {
          let end = findColumn(line.text, endCol, state.tabSize);
          ranges.push(EditorSelection.range(line.from + start, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
  }
  function getPos(view, event) {
    let offset = view.posAtCoords({x: event.clientX, y: event.clientY}, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return {line: line.number, col, off};
  }
  function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
      return null;
    return {
      update(update) {
        if (update.docChanged) {
          let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
          let newLine = update.state.doc.lineAt(newStart);
          start = {line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length)};
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view.state, start, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
  }
  var keys = {
    Alt: [18, (e) => e.altKey],
    Control: [17, (e) => e.ctrlKey],
    Shift: [16, (e) => e.shiftKey],
    Meta: [91, (e) => e.metaKey]
  };
  var showCrosshair = {style: "cursor: crosshair"};
  function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventHandlers: {
        keydown(e) {
          this.set(e.keyCode == code || getter(e));
        },
        keyup(e) {
          if (e.keyCode == code || !getter(e))
            this.set(false);
        },
        mousemove(e) {
          this.set(getter(e));
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view) => {
        var _a2;
        return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips = input.filter((x) => x);
      if (input === this.input) {
        for (let t2 of this.tooltipViews)
          if (t2.update)
            t2.update(update);
        return false;
      }
      let tooltipViews = [];
      for (let i = 0; i < tooltips.length; i++) {
        let tip = tooltips[i], known = -1;
        if (!tip)
          continue;
        for (let i2 = 0; i2 < this.tooltips.length; i2++) {
          let other = this.tooltips[i2];
          if (other && other.create == tip.create)
            known = i2;
        }
        if (known < 0) {
          tooltipViews[i] = this.createTooltipView(tip);
        } else {
          let tooltipView = tooltipViews[i] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t2 of this.tooltipViews)
        if (tooltipViews.indexOf(t2) < 0) {
          t2.dom.remove();
          (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
        }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace(view) {
    let {win} = view;
    return {top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth};
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.inView = true;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = {read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this};
      this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, {threshold: [1]}) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update) {
      if (update.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews)
          t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews)
          this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip) {
      let tooltipView = tooltip.create(this.view);
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      this.container.appendChild(tooltipView.dom);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      return tooltipView;
    }
    destroy() {
      var _a2, _b;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor = this.view.dom.getBoundingClientRect();
      return {
        editor,
        parent: this.parent ? this.container.getBoundingClientRect() : editor,
        pos: this.manager.tooltips.map((t2, i) => {
          let tv = this.manager.tooltipViews[i];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({dom}) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
      };
    }
    writeMeasure(measured) {
      let {editor, space} = measured;
      let others = [];
      for (let i = 0; i < this.manager.tooltips.length; i++) {
        let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], {dom} = tView;
        let pos = measured.pos[i], size = measured.size[i];
        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = size.bottom - size.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = !!tooltip.above;
        if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
          above = !above;
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others)
            if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
              top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = top2 - measured.parent.top + "px";
          dom.style.left = left - measured.parent.left + "px";
        } else {
          dom.style.top = top2 + "px";
          dom.style.left = left + "px";
        }
        if (arrow)
          arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
        if (tView.overlap !== true)
          others.push({left, top: top2, right, bottom: top2 + height});
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventHandlers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = {x: 0, y: 0};
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class {
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
    static create(view) {
      return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned(space) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space);
      }
    }
    update(update) {
      this.manager.update(update);
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    let tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = {x: 0, y: 0, target: view.dom, time: 0};
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let {lastMove} = this;
      let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null)
        return;
      let posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
        return;
      let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = {pos};
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result)
              this.view.dispatch({effects: this.setHover.of(result)});
          }
        }, (e) => logException(this.view.state, e, "hover tooltip"));
      } else if (open) {
        this.view.dispatch({effects: this.setHover.of(open)});
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = {x: event.clientX, y: event.clientY, target: event.target, time: Date.now()};
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let tooltip = this.active;
      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
        let {pos} = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({effects: this.setHover.of(null)});
          this.pending = null;
        }
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active && !isInTooltip(e.relatedTarget))
        this.view.dispatch({effects: this.setHover.of(null)});
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  function isInTooltip(elt) {
    for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
      if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
        return true;
    return false;
  }
  function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
      if (dist <= margin)
        return true;
    }
    return false;
  }
  function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
          return null;
        if (value && tr.docChanged) {
          let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null)
            return null;
          let copy = Object.assign(Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null)
            copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = null;
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
      showHoverTooltipHost
    ];
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c of configs) {
        topContainer = topContainer || c.topContainer;
        bottomContainer = bottomContainer || c.bottomContainer;
      }
      return {topContainer, bottomContainer};
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      } else {
        for (let p of this.panels)
          if (p.update)
            p.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && {top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin()};
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels)
        if (p.destroy && panels.indexOf(p) < 0)
          p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        let text;
        if (Array.isArray(line.type)) {
          for (let b of line.type)
            if (b.type == BlockType.Text) {
              text = b;
              break;
            }
        } else {
          text = line.type == BlockType.Text ? line : void 0;
        }
        if (!text)
          continue;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text, classSet);
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0)
            g.destroy();
        }
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? {left: value.dom.offsetWidth} : {right: value.dom.offsetWidth};
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor3, collect, pos) {
    while (cursor3.value && cursor3.from <= pos) {
      if (cursor3.from == pos)
        collect.push(cursor3.value);
      cursor3.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c = marker.elementClass;
          if (c)
            cls += " " + c;
          for (let i = iOld; i < this.markers.length; i++)
            if (this.markers[i].compare(marker)) {
              skipTo = i;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].compare(b[i]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, {formatNumber: String, domEventHandlers: {}}, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event in b) {
            let exists = result[event], add2 = b[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.openedBy = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.group = new NodeProp({deserialize: (str) => str.split(" ")});
  NodeProp.contextHash = new NodeProp({perNode: true});
  NodeProp.lookAhead = new NodeProp({perNode: true});
  NodeProp.mounted = new NodeProp({perNode: true});
  var noProps = Object.create(null);
  var NodeType = class {
    constructor(name2, props, id, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map) {
      let direct = Object.create(null);
      for (let prop in map)
        for (let name2 of prop.split(" "))
          direct[name2] = map[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", Object.create(null), 0, 8);
  var NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i = 0; i < types2.length; i++)
        if (types2[i].id != i)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add2 = source(type);
          if (add2) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add2[0].id] = add2[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  var CachedNode = new WeakMap();
  var CachedInnerNode = new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor3 = new TreeCursor(scope);
      cursor3.moveTo(pos, side);
      CachedNode.set(this, cursor3._tree);
      return cursor3;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let {enter, leave, from = 0, to = this.length} = spec;
      for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c.type.isAnonymous)
            leave(c);
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id in this.props)
          result.push([+id, this.props[id]]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set) {
      this.buffer = buffer;
      this.length = length;
      this.set = set;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let {buffer} = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i = startI, j = 0; i < endI; ) {
        copy[j++] = b[i++];
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - startI;
      }
      return new TreeBuffer(copy, to - from, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from, index, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let {children, positions} = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start = positions[i] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start, i, parent);
            let inner = new TreeNode(next, start, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let {from, to} of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null) {
      while (!cur2.type.is(before))
        if (!cur2.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  };
  var BufferNode = class {
    constructor(context, _parent, index) {
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let {buffer} = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let {buffer} = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let {buffer} = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let {buffer} = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let {buffer} = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  var TreeCursor = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let {start, buffer} = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let {buffer} = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let {buffer} = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, {buffer} = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({index, parent} = buffer);
      } else {
        ({index, _parent: parent} = this._tree);
      }
      for (; parent; {index, _parent: parent} = parent) {
        if (index > -1)
          for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan:
          for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let {buffer} = this.buffer, {types: types2} = buffer.set;
      for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context, i);
        let type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context[i] && context[i] != type.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let {buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length} = data;
    let cursor3 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let {id, start, end, size} = cursor3;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor3.next();
        if (size == -1) {
          let node2 = reused[id];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor3.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor3.pos - buffer2.size, index = data2.length;
        while (cursor3.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor3.pos - size;
        cursor3.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id >= minRepeatType ? id : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor3.pos > endPos) {
          if (localInRepeat >= 0 && cursor3.id == localInRepeat && cursor3.size >= 0) {
            if (cursor3.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor3.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor3.end;
            }
            cursor3.next();
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor3.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = {size: 0, start: 0, skip: 0};
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size;
            result.start = start;
            result.skip = skip;
            skip += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start = nodeStart2;
          size += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let {id, start, end, size} = cursor3;
      cursor3.next();
      if (size >= 0 && id < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor3.pos - (size - 4);
          while (cursor3.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor3.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(balanceType, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var stoppedInner = new NodeProp({perNode: true});

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set, base2, modified) {
      this.set = set;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set = [], tag = new Tag(set, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config2 of configs)
            set.push(Modifier.get(parent, config2));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map = Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map[tag.id] = style.class;
    }
    let {scope, all = null} = options || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor3, from, to, inheritedClass, highlighters) {
      let {type, from: start, to: end} = cursor3;
      if (start >= to || end <= from)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor3) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(cursor3.from, cls);
      if (rule.opaque)
        return;
      let mounted = cursor3.tree && cursor3.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor3.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        let hasChild2 = cursor3.firstChild();
        for (let i = 0, pos = start; ; i++) {
          let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor3.from < rangeTo) {
              this.highlightRange(cursor3, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(to, cursor3.to), cls);
              if (cursor3.to >= nextPos || !cursor3.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2)
          cursor3.parent();
      } else if (cursor3.firstChild()) {
        do {
          if (cursor3.to <= from)
            continue;
          if (cursor3.from >= to)
            break;
          this.highlightRange(cursor3, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor3.to), cls);
        } while (cursor3.nextSibling());
        cursor3.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    {tag: tags.link, class: "tok-link"},
    {tag: tags.heading, class: "tok-heading"},
    {tag: tags.emphasis, class: "tok-emphasis"},
    {tag: tags.strong, class: "tok-strong"},
    {tag: tags.keyword, class: "tok-keyword"},
    {tag: tags.atom, class: "tok-atom"},
    {tag: tags.bool, class: "tok-bool"},
    {tag: tags.url, class: "tok-url"},
    {tag: tags.labelName, class: "tok-labelName"},
    {tag: tags.inserted, class: "tok-inserted"},
    {tag: tags.deleted, class: "tok-deleted"},
    {tag: tags.literal, class: "tok-literal"},
    {tag: tags.string, class: "tok-string"},
    {tag: tags.number, class: "tok-number"},
    {tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2"},
    {tag: tags.variableName, class: "tok-variableName"},
    {tag: tags.local(tags.variableName), class: "tok-variableName tok-local"},
    {tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition"},
    {tag: tags.special(tags.variableName), class: "tok-variableName2"},
    {tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition"},
    {tag: tags.typeName, class: "tok-typeName"},
    {tag: tags.namespace, class: "tok-namespace"},
    {tag: tags.className, class: "tok-className"},
    {tag: tags.macroName, class: "tok-macroName"},
    {tag: tags.propertyName, class: "tok-propertyName"},
    {tag: tags.operator, class: "tok-operator"},
    {tag: tags.comment, class: "tok-comment"},
    {tag: tags.meta, class: "tok-meta"},
    {tag: tags.invalid, class: "tok-invalid"},
    {tag: tags.punctuation, class: "tok-punctuation"}
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  }
  var Language = class {
    constructor(data, parser2, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", {get() {
          return syntaxTree(this);
        }});
      this.parser = parser2;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return languageDataFacetAt(state, pos, side) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{from: 0, to: state.doc.length}];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({from, to: from + tree.length});
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({from: r.from + from, to: r.to + from});
            else
              result.push({from, to: from + tree.length});
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch = tree.children[i];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state, pos, side) {
    let topLang = state.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  var LRLanguage = class extends Language {
    constructor(data, parser2, name2) {
      super(data, parser2, [], name2);
      this.parser = parser2;
    }
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
      }), spec.name);
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2, length = doc2.length) {
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser2;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser2, state, viewport) {
      return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let {fragments, tree, treeLen, viewport, skipped} = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({fromA, toA, fromB, toB}));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = {from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1)};
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to)
              skipped.push({from, to});
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let {from, to} = this.skipped[i];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({from, to});
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser2 = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser2;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{fromA: from, toA: to, fromB: from, toB: to}]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, {from: 0, to: vpTo});
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(() => {
        idle = requestIdleCallback(callback, {timeout: 500 - 100});
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let {state} = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let {state, viewport: {to: vpTo}} = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({effects: Language.setState.of(new LanguageState(field.context))});
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: {focus() {
      this.scheduleWork();
    }}
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? {"data-language": lang.name} : {};
      })
    ]
  });
  var LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      if (!/^(?: +|\t+)$/.test(values[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return values[0];
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (let i = 0; i < cols; i++)
      result += " ";
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let {simulateBreak, simulateDoubleBreak} = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return {text: "", from: pos};
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return {text: line.text.slice(simulateBreak - line.from), from: simulateBreak};
        else
          return {text: line.text.slice(0, simulateBreak - line.from), from: line.from};
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let {text, from} = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let {text, from} = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let {text, from} = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  function continuedIndent({except, units = 1} = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc2 = tr.newDoc, {head} = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr;
      let {state} = tr, last = -1, changes = [];
      for (let {head: head2} of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last)
          continue;
        last = line2.from;
        let indent = getIndentation(state, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state, indent);
        if (cur2 != norm)
          changes.push({from: line2.from, to: line2.from + cur2.length, insert: norm});
      }
      return changes.length ? [tr, {changes, sequential: true}] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? {from: first.to, to: last.type.isError ? node.to : last.from} : null;
  }
  function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
      return null;
    let inner = tree.resolveInner(end, 1);
    let found = null;
    for (let cur2 = inner; cur2; cur2 = cur2.parent) {
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state);
        if (value && value.from <= end && value.from >= start && value.to > end)
          found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
      let result = service(state, lineStart, lineEnd);
      if (result)
        return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
  }
  function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? void 0 : {from, to};
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({map: mapRange});
  function selectedLines(view) {
    let lines = [];
    for (let {head} of view.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head))
        continue;
      lines.push(view.lineBlockAt(head));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e of tr.effects) {
        if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
          folded = folded.update({add: [foldWidget.range(e.value.from, e.value.to)]});
        else if (e.is(unfoldEffect))
          folded = folded.update({
            filter: (from, to) => e.value.from != from || e.value.to != to,
            filterFrom: e.value.from,
            filterTo: e.value.to
          });
      }
      if (tr.selection) {
        let onSelection = false, {head} = tr.selection.main;
        folded.between(head, head, (a, b) => {
          if (a < head && b > head)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head,
            filterTo: head,
            filter: (a, b) => b <= head || a >= head
          });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f),
    toJSON(folded, state) {
      let ranges = [];
      folded.between(0, state.doc.length, (from, to) => {
        ranges.push(from, to);
      });
      return ranges;
    },
    fromJSON(value) {
      if (!Array.isArray(value) || value.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let ranges = [];
      for (let i = 0; i < value.length; ) {
        let from = value[i++], to = value[i++];
        if (typeof from != "number" || typeof to != "number")
          throw new RangeError("Invalid JSON for fold state");
        ranges.push(foldWidget.range(from, to));
      }
      return Decoration.set(ranges, true);
    }
  });
  function findFold(state, from, to) {
    var _a2;
    let found = null;
    (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
      if (!found || found.from > from2)
        found = {from: from2, to: to2};
    });
    return found;
  }
  function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => {
      if (a == from && b == to)
        found = true;
    });
    return found;
  }
  function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view) => {
    for (let line of selectedLines(view)) {
      let range = foldable(view.state, line.from, line.to);
      if (range) {
        view.dispatch({effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])});
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view) => {
    if (!view.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view)) {
      let folded = findFold(view.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
      view.dispatch({effects});
    return effects.length > 0;
  };
  function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view) => {
    let {state} = view, effects = [];
    for (let pos = 0; pos < state.doc.length; ) {
      let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
      if (range)
        effects.push(foldEffect.of(range));
      pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
      view.dispatch({effects: maybeEnable(view.state, effects)});
    return !!effects.length;
  };
  var unfoldAll = (view) => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => {
      effects.push(unfoldEffect.of({from, to}));
    });
    view.dispatch({effects});
    return true;
  };
  var foldKeymap = [
    {key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode},
    {key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode},
    {key: "Ctrl-Alt-[", run: foldAll},
    {key: "Ctrl-Alt-]", run: unfoldAll}
  ];
  var defaultConfig = {
    placeholderDOM: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view) {
      let {state} = view, conf = state.facet(foldConfig);
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          view.dispatch({effects: unfoldEffect.of(folded)});
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick);
      let element = document.createElement("span");
      element.textContent = conf.placeholderText;
      element.setAttribute("aria-label", state.phrase("folded code"));
      element.title = state.phrase("unfold");
      element.className = "cm-foldPlaceholder";
      element.onclick = onclick;
      return element;
    }
  }()});
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view) {
        this.from = view.viewport.from;
        this.markers = this.buildMarkers(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
          this.markers = this.buildMarkers(update.view);
      }
      buildMarkers(view) {
        let builder = new RangeSetBuilder();
        for (let line of view.viewportLineBlocks) {
          let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let {domEventHandlers} = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view) {
          var _a2;
          return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({effects: unfoldEffect.of(folded)});
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({effects: foldEffect.of(range)});
            return true;
          }
          return false;
        }})
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, {tag: null}))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update.changes);
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let {from, to} of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({class: style})));
        }, from, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {backgroundColor: "#328c8252"},
    "&.cm-focused .cm-nonmatchingBracket": {backgroundColor: "#bb555544"}
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({class: "cm-matchingBracket"});
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({class: "cm-nonmatchingBracket"});
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end)
      decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty)
          continue;
        let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match)
          decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index + dir]];
    }
    return null;
  }
  function matchBrackets(state, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches = matchingNodes(cur2.type, dir, brackets);
      if (matches && cur2.from < cur2.to)
        return matchMarkedBrackets(state, pos, dir, cur2, matches, brackets);
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = {from: token.from, to: token.to};
    let depth = 0, cursor3 = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor3 && (dir < 0 ? cursor3.childBefore(token.from) : cursor3.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor3.to <= token.from : cursor3.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor3.type.name) > -1 && cursor3.from < cursor3.to) {
            return {start: firstToken, end: {from: cursor3.from, to: cursor3.to}, matched: true};
          } else if (matchingNodes(cursor3.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor3.type, -dir, brackets)) {
            if (depth == 0)
              return {
                start: firstToken,
                end: cursor3.from == cursor3.to ? void 0 : {from: cursor3.from, to: cursor3.to},
                matched: false
              };
            depth--;
          }
        }
      } while (dir < 0 ? cursor3.prevSibling() : cursor3.nextSibling());
    return {start: firstToken, matched: false};
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = {from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos};
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0)
        distance += text.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return {start: startToken, end: {from: basePos + pos2, to: basePos + pos2 + 1}, matched: found >> 1 == bracket2 >> 1};
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text.length;
    }
    return iter.done ? {start: startToken, matched: false} : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({[name2]: tag})]
    });
    typeArray.push(type);
    return type.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let config2 = getConfig(target.state);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({state, dispatch}) => {
      if (state.readOnly)
        return false;
      let tr = f(option, state);
      if (!tr)
        return false;
      dispatch(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos = state.selection.main.head) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, {open, close}, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: {pos: from - spaceBefore, margin: spaceBefore && 1},
        close: {pos: to + spaceAfter, margin: spaceAfter && 1}
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last].to > fromLine.from)
        ranges[last].to = toLine.to;
      else
        ranges.push({from: fromLine.from, to: toLine.to});
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c) => c))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 && !comments.every((c) => c)) {
      return {changes: state.changes(ranges.map((range, i) => {
        if (comments[i])
          return [];
        return [{from: range.from, insert: tokens[i].open + " "}, {from: range.to, insert: " " + tokens[i].close}];
      }))};
    } else if (option != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token = tokens[i], {open, close} = comment2;
          changes.push({from: open.pos - token.open.length, to: open.pos + open.margin}, {from: close.pos - close.margin, to: close.pos + token.close.length});
        }
      return {changes};
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let {from, to} of ranges) {
      let startI = lines.length, minIndent = 1e9;
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let token = getConfig(state, pos).line;
          if (!token)
            continue;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({line, comment: comment2, token, indent, empty: empty2, single: false});
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let {line, token, indent, empty: empty2, single} of lines)
        if (single || !empty2)
          changes.push({from: line.from + indent, insert: token + " "});
      let changeSet = state.changes(changes);
      return {changes: changeSet, selection: state.selection.map(changeSet, 1)};
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let {line, comment: comment2, token} of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to = from + token.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({from, to});
        }
      return {changes};
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500
      }, {minDepth: Math.max, newGroupDelay: Math.min});
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to) => end = to);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let selection3 = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr, selection3), from = fromHist.side;
        let other = from == 0 ? state.undone : state.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false)
        return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event)
        state = state.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
      else if (tr.selection)
        state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state = state.isolate();
      return state;
    },
    toJSON(value) {
      return {done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON())};
    },
    fromJSON(json2) {
      return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e, view) {
          let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection3) {
    return function({state, dispatch}) {
      if (!selection3 && state.readOnly)
        return false;
      let historyState = state.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state, selection3);
      if (!tr)
        return false;
      dispatch(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json2) {
      return new HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection3) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection3 || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from = ranges[i++], to = ranges[i++];
        if (t2 >= from && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection3) {
    if (!branch.length) {
      return [HistEvent.selection([selection3])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection3))
        return branch;
      sels.push(selection3);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection3, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection3))
        return this;
      return new HistoryState(addSelection(this.done, selection3), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection3) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1];
      if (selection3 && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({side, rest: popSelection(branch)}),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({side, rest}),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    {key: "Mod-z", run: undo, preventDefault: true},
    {key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true},
    {linux: "Ctrl-Shift-z", run: redo, preventDefault: true},
    {key: "Mod-u", run: undoSelection, preventDefault: true},
    {key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true}
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection3) {
    return state.update({selection: selection3, scrollIntoView: true, userEvent: "select"});
  }
  function moveSel({state, dispatch}, how) {
    let selection3 = updateSel(state.selection, how);
    if (selection3.eq(state.selection))
      return false;
    dispatch(setSel(state, selection3));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
      newPos = forward ? match.end.to : match.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function pageHeight(view) {
    return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
  }
  function cursorByPage(view, forward) {
    let {state} = view, selection3 = updateSel(state.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);
    });
    if (selection3.eq(state.selection))
      return false;
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
      effect = EditorView.scrollIntoView(selection3.main.head, {y: "start", yMargin: startPos.top - scrollRect.top});
    view.dispatch(setSel(state, selection3), {effects: effect});
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state, dispatch, extend2) {
    let found = false, selection3 = updateSel(state.selection, (range) => {
      let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
      if (!matching || !matching.end)
        return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch(setSel(state, selection3));
    return true;
  }
  var cursorMatchingBracket = ({state, dispatch}) => toMatchingBracket(state, dispatch, false);
  function extendSel(view, how) {
    let selection3 = updateSel(view.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection3.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection3));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, pageHeight(view)));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  var cursorDocStart = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: 0}));
    return true;
  };
  var cursorDocEnd = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.doc.length}));
    return true;
  };
  var selectDocStart = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.selection.main.anchor, head: 0}));
    return true;
  };
  var selectDocEnd = ({state, dispatch}) => {
    dispatch(setSel(state, {anchor: state.selection.main.anchor, head: state.doc.length}));
    return true;
  };
  var selectAll = ({state, dispatch}) => {
    dispatch(state.update({selection: {anchor: 0, head: state.doc.length}, userEvent: "select"}));
    return true;
  };
  var selectLine = ({state, dispatch}) => {
    let ranges = selectedLineBlocks(state).map(({from, to}) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({selection: EditorSelection.create(ranges), userEvent: "select"}));
    return true;
  };
  var selectParentSyntax = ({state, dispatch}) => {
    let selection3 = updateSel(state.selection, (range) => {
      var _a2;
      let context = syntaxTree(state).resolveInner(range.head, 1);
      while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context = context.parent;
      return EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state, selection3));
    return true;
  };
  var simplifySelection = ({state, dispatch}) => {
    let cur2 = state.selection, selection3 = null;
    if (cur2.ranges.length > 1)
      selection3 = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection3 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection3)
      return false;
    dispatch(setSel(state, selection3));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event = "delete.selection", {state} = target;
    let changes = state.changeByRange((range) => {
      let {from, to} = range;
      if (from == to) {
        let towards = by(from);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? {range} : {changes: {from, to}, range: EditorSelection.cursor(from)};
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let {state} = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return targetPos;
  });
  var deleteCharBackward = (view) => deleteByChar(view, false);
  var deleteCharForward = (view) => deleteByChar(view, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
    let pos = start, {state} = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != start)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
    let lineEnd = view.lineBlockAt(pos).to;
    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
  });
  var deleteToLineStart = (view) => deleteBy(view, (pos) => {
    let lineStart = view.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
  });
  var splitLine = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: {from: range.from, to: range.to, insert: Text.of(["", ""])},
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, {scrollIntoView: true, userEvent: "input"}));
    return true;
  };
  var transposeChars = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length)
        return {range};
      let pos = range.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: {from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))},
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state.update(changes, {scrollIntoView: true, userEvent: "move.character"}));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
      let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from)
        endLine = state.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({from: startLine.from, to: endLine.to, ranges: [range]});
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size = nextLine.length + 1;
      if (forward) {
        changes.push({from: block.to, to: nextLine.to}, {from: block.from, insert: nextLine.text + state.lineBreak});
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      } else {
        changes.push({from: nextLine.from, to: block.from}, {from: block.to, insert: state.lineBreak + nextLine.text});
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({state, dispatch}) => moveLine(state, dispatch, false);
  var moveLineDown = ({state, dispatch}) => moveLine(state, dispatch, true);
  function copyLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward)
        changes.push({from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak});
      else
        changes.push({from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to)});
    }
    dispatch(state.update({changes, scrollIntoView: true, userEvent: "input.copyline"}));
    return true;
  }
  var copyLineUp = ({state, dispatch}) => copyLine(state, dispatch, false);
  var copyLineDown = ({state, dispatch}) => copyLine(state, dispatch, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let {state} = view, changes = state.changes(selectedLineBlocks(state).map(({from, to}) => {
      if (from > 0)
        from--;
      else if (to < state.doc.length)
        to++;
      return {from, to};
    }));
    let selection3 = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
    view.dispatch({changes, selection: selection3, scrollIntoView: true, userEvent: "delete.line"});
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return {from: pos, to: pos};
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
      return {from: before.to, to: after.from};
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({state, dispatch}) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        let {from, to} = range, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, {simulateBreak: from, simulateDoubleBreak: !!explode});
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({from, to} = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state, indent)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: {from, to, insert: Text.of(insert2)},
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, {scrollIntoView: true, userEvent: "input"}));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  var indentSelection = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let updated = Object.create(null);
    let context = new IndentContext(state, {overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    }});
    let changes = changeBySelectedLine(state, (line, changes2, range) => {
      let indent = getIndentation(context, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm || range.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({from: line.from, to: line.from + cur2.length, insert: norm});
      }
    });
    if (!changes.changes.empty)
      dispatch(state.update(changes, {userEvent: "indent"}));
    return true;
  };
  var indentMore = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({from: line.from, insert: state.facet(indentUnit)});
    }), {userEvent: "input.indent"}));
    return true;
  };
  var indentLess = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep)});
    }), {userEvent: "delete.dedent"}));
    return true;
  };
  var emacsStyleKeymap = [
    {key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true},
    {key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight},
    {key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp},
    {key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown},
    {key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart},
    {key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd},
    {key: "Ctrl-d", run: deleteCharForward},
    {key: "Ctrl-h", run: deleteCharBackward},
    {key: "Ctrl-k", run: deleteToLineEnd},
    {key: "Ctrl-Alt-h", run: deleteGroupBackward},
    {key: "Ctrl-o", run: splitLine},
    {key: "Ctrl-t", run: transposeChars},
    {key: "Ctrl-v", run: cursorPageDown}
  ];
  var standardKeymap = /* @__PURE__ */ [
    {key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true},
    {key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true},
    {mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true},
    {key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true},
    {key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true},
    {mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true},
    {key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true},
    {mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart},
    {mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp},
    {key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true},
    {mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd},
    {mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown},
    {key: "PageUp", run: cursorPageUp, shift: selectPageUp},
    {key: "PageDown", run: cursorPageDown, shift: selectPageDown},
    {key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true},
    {key: "Mod-Home", run: cursorDocStart, shift: selectDocStart},
    {key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true},
    {key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd},
    {key: "Enter", run: insertNewlineAndIndent},
    {key: "Mod-a", run: selectAll},
    {key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward},
    {key: "Delete", run: deleteCharForward},
    {key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward},
    {key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward},
    {mac: "Mod-Backspace", run: deleteToLineStart},
    {mac: "Mod-Delete", run: deleteToLineEnd}
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({mac: b.key, run: b.run, shift: b.shift})));
  var defaultKeymap = /* @__PURE__ */ [
    {key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft},
    {key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight},
    {key: "Alt-ArrowUp", run: moveLineUp},
    {key: "Shift-Alt-ArrowUp", run: copyLineUp},
    {key: "Alt-ArrowDown", run: moveLineDown},
    {key: "Shift-Alt-ArrowDown", run: copyLineDown},
    {key: "Escape", run: simplifySelection},
    {key: "Mod-Enter", run: insertBlankLine},
    {key: "Alt-l", mac: "Ctrl-l", run: selectLine},
    {key: "Mod-i", run: selectParentSyntax, preventDefault: true},
    {key: "Mod-[", run: indentLess},
    {key: "Mod-]", run: indentMore},
    {key: "Mod-Alt-\\", run: indentSelection},
    {key: "Shift-Mod-k", run: deleteLine},
    {key: "Shift-Mod-\\", run: cursorMatchingBracket},
    {key: "Mod-/", run: toggleComment},
    {key: "Alt-A", run: toggleBlockComment}
  ].concat(standardKeymap);
  var indentWithTab = {key: "Tab", run: indentMore, shift: indentLess};

  // node_modules/crelt/index.es.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
      elt = document.createElement(elt);
    var i = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next)
        if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string")
            elt.setAttribute(name2, value);
          else if (value != null)
            elt[name2] = value;
        }
      i++;
    }
    for (; i < arguments.length; i++)
      add(elt, arguments[i]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++)
        add(elt, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  var SearchCursor = class {
    constructor(text, query, from = 0, to = text.length, normalize, test) {
      this.test = test;
      this.value = {from: 0, to: 0};
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from, to);
      this.bufferStart = from;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        for (let i = 0, pos = start; ; i++) {
          let code = norm.charCodeAt(i);
          let match = this.match(code, pos);
          if (match) {
            this.value = match;
            return this;
          }
          if (i == norm.length - 1)
            break;
          if (pos == start && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
      }
    }
    match(code, pos) {
      let match = null;
      for (let i = 0; i < this.matches.length; i += 2) {
        let index = this.matches[i], keep = false;
        if (this.query.charCodeAt(index) == code) {
          if (index == this.query.length - 1) {
            match = {from: this.matches[i + 1], to: pos + 1};
          } else {
            this.matches[i]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i, 2);
          i -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code) {
        if (this.query.length == 1)
          match = {from: pos, to: pos + 1};
        else
          this.matches.push(1, pos);
      }
      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
        match = null;
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = {from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("")};
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text, query, options, from = 0, to = text.length) {
      this.text = text;
      this.to = to;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text, query, options, from, to);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.iter = text.iter();
      let startLine = text.lineAt(from);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text, from);
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from = this.curLineStart + match.index, to = from + match[0].length;
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          if (from == this.curLineStart + this.curLine.length)
            this.nextLine();
          if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
            this.value = {from, to, match};
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from, text) {
      this.from = from;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from, to) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to || cached.to <= from) {
        let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from && cached.to == to)
        return cached;
      let {text, from: cachedFrom} = cached;
      if (cachedFrom > from) {
        text = doc2.sliceString(from, cachedFrom) + text;
        cachedFrom = from;
      }
      if (cached.to < to)
        text += doc2.sliceString(cached.to, to);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text, query, options, from, to) {
      this.text = text;
      this.to = to;
      this.done = false;
      this.value = empty;
      this.matchPos = toCharEnd(text, from);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match) {
          let from = this.flat.from + match.index, to = from + match[0].length;
          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
            this.value = {from, to, match};
            this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function toCharEnd(text, pos) {
    if (pos >= text.length)
      return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
      pos++;
    return pos;
  }
  function createLineDialog(view) {
    let input = crelt("input", {class: "cm-textfield", name: "line"});
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view.dispatch({effects: dialogEffect.of(false)});
          view.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {class: "cm-button", type: "submit"}, view.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match)
        return;
      let {state} = view, startLine = state.doc.lineAt(state.selection.main.head);
      let [, sign, ln, cl, percent] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line / 100;
        if (sign)
          pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
        line = Math.round(state.doc.lines * pc);
      } else if (ln && sign) {
        line = line * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
      view.dispatch({
        effects: dialogEffect.of(false),
        selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
        scrollIntoView: true
      });
      view.focus();
    }
    return {dom};
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(dialogEffect))
          value = e.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view.dispatch({effects});
      panel = getPanel(view, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": {fontSize: "80%"}
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options) {
      return combineConfig(options, defaultHighlightOptions, {
        highlightWordAroundCursor: (a, b) => a || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
      ext.push(highlightConfig.of(options));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch"});
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({class: "cm-selectionMatch cm-selectionMatch-main"});
  function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
  }
  function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.selectionSet || update.docChanged || update.viewportChanged)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let {state} = view, sel = state.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range = sel.main, query, check = null;
      if (range.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state.wordAt(range.head);
        if (!word)
          return Decoration.none;
        check = state.charCategorizer(range.head);
        query = state.sliceDoc(word.from, word.to);
      } else {
        let len = range.to - range.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state.sliceDoc(range.from, range.to);
          check = state.charCategorizer(range.head);
          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
            return Decoration.none;
        } else {
          query = state.sliceDoc(range.from, range.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor3 = new SearchCursor(state.doc, query, part.from, part.to);
        while (!cursor3.next().done) {
          let {from, to} = cursor3.value;
          if (!check || insideWordBoundaries(check, state, from, to)) {
            if (range.empty && from <= range.from && to >= range.to)
              deco.push(mainMatchDeco.range(from, to));
            else if (from >= range.to || to <= range.from)
              deco.push(matchDeco.range(from, to));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": {backgroundColor: "#99ff7780"},
    ".cm-searchMatch .cm-selectionMatch": {backgroundColor: "transparent"}
  });
  var selectWord = ({state, dispatch}) => {
    let {selection: selection3} = state;
    let newSel = EditorSelection.create(selection3.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection3.mainIndex);
    if (newSel.eq(selection3))
      return false;
    dispatch(state.update({selection: newSel}));
    return true;
  };
  function findNextOccurrence(state, query) {
    let {main, ranges} = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor3 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor3.next();
      if (cursor3.done) {
        if (cycled)
          return null;
        cursor3 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor3.value.from))
          continue;
        if (fullWord) {
          let word2 = state.wordAt(cursor3.value.from);
          if (!word2 || word2.from != cursor3.value.from || word2.to != cursor3.value.to)
            continue;
        }
        return cursor3.value;
      }
    }
  }
  var selectNextOccurrence = ({state, dispatch}) => {
    let {ranges} = state.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({state, dispatch});
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
      return false;
    dispatch(state.update({
      selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        wholeWord: false,
        createPanel: (view) => new SearchPanel(view)
      });
    }
  });
  var SearchQuery = class {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.literal = !!config2.literal;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config2.wholeWord;
    }
    unquote(text) {
      return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from = 0, to) {
      let st = state.doc ? state : EditorState.create({doc: state});
      if (to == null)
        to = st.doc.length;
      return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
  }
  function stringWordTest(doc2, categorizer) {
    return (from, to, buf, bufPos) => {
      if (bufPos > from || bufPos + buf.length < to) {
        bufPos = Math.max(0, from - 2);
        buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
      }
      return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
    };
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state, curFrom, curTo) {
      let cursor3 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
      if (cursor3.done)
        cursor3 = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
      return cursor3.done ? null : cursor3.value;
    }
    prevMatchInRange(state, from, to) {
      for (let pos = to; ; ) {
        let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
        let cursor3 = stringCursor(this.spec, state, start, pos), range = null;
        while (!cursor3.nextOverlapping().done)
          range = cursor3.value;
        if (range)
          return range;
        if (start == from)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state, limit) {
      let cursor3 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor3.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor3.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor3 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
      while (!cursor3.next().done)
        add2(cursor3.value.from, cursor3.value.to);
    }
  };
  function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
    }, from, to);
  }
  function charBefore(str, index) {
    return str.slice(findClusterBreak(str, index, false), index);
  }
  function charAfter(str, index) {
    return str.slice(index, findClusterBreak(str, index));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(state, curFrom, curTo) {
      let cursor3 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
      if (cursor3.done)
        cursor3 = regexpCursor(this.spec, state, 0, curFrom).next();
      return cursor3.done ? null : cursor3.value;
    }
    prevMatchInRange(state, from, to) {
      for (let size = 1; ; size++) {
        let start = Math.max(from, to - size * 1e4);
        let cursor3 = regexpCursor(this.spec, state, start, to), range = null;
        while (!cursor3.next().done)
          range = cursor3.value;
        if (range && (start == from || range.from > start + 10))
          return range;
        if (start == from)
          return null;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
    }
    matchAll(state, limit) {
      let cursor3 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor3.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor3.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor3 = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
      while (!cursor3.next().done)
        add2(cursor3.value.from, cursor3.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state) {
      return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch"});
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({class: "cm-searchMatch cm-searchMatch-selected"});
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
      let state = update.state.field(searchState);
      if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
        this.decorations = this.highlight(state);
    }
    highlight({query, panel}) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let {view} = this;
      let builder = new RangeSetBuilder();
      for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
        let {from, to} = ranges[i];
        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
          to = ranges[++i].to;
        query.highlight(view.state, from, to, (from2, to2) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
          builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state = view.state.field(searchState, false);
      return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {to} = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
      return false;
    view.dispatch({
      selection: {anchor: next.from, head: next.to},
      scrollIntoView: true,
      effects: announceMatch(view, next),
      userEvent: "select.search"
    });
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {state} = view, {from} = state.selection.main;
    let range = query.prevMatch(state, from, from);
    if (!range)
      return false;
    view.dispatch({
      selection: {anchor: range.from, head: range.to},
      scrollIntoView: true,
      effects: announceMatch(view, range),
      userEvent: "select.search"
    });
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view, {query}) => {
    let ranges = query.matchAll(view.state, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({state, dispatch}) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let {from, to} = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch(state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view, {query}) => {
    let {state} = view, {from, to} = state.selection.main;
    if (state.readOnly)
      return false;
    let next = query.nextMatch(state, from, from);
    if (!next)
      return false;
    let changes = [], selection3, replacement;
    let announce = [];
    if (next.from == from && next.to == to) {
      replacement = state.toText(query.getReplacement(next));
      changes.push({from: next.from, to: next.to, insert: replacement});
      next = query.nextMatch(state, next.from, next.to);
      announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection3 = {anchor: next.from - off, head: next.to - off};
      announce.push(announceMatch(view, next));
    }
    view.dispatch({
      changes,
      selection: selection3,
      scrollIntoView: !!selection3,
      effects: announce,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view, {query}) => {
    if (view.state.readOnly)
      return false;
    let changes = query.matchAll(view.state, 1e9).map((match) => {
      let {from, to} = match;
      return {from, to, insert: query.getReplacement(match)};
    });
    if (!changes.length)
      return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state, fallback) {
    var _a2, _b, _c, _d;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
      return fallback;
    let config2 = state.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
      literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
      wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config2.wholeWord
    });
  }
  var openSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
      let panel = getPanel(view, createSearchPanel);
      if (!panel)
        return false;
      let searchInput = panel.dom.querySelector("[main-field]");
      if (searchInput && searchInput != view.root.activeElement) {
        let query = defaultQuery(view.state, state.query.spec);
        if (query.valid)
          view.dispatch({effects: setSearchQuery.of(query)});
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view.dispatch({effects: [
        togglePanel.of(true),
        state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ]});
    }
    return true;
  };
  var closeSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
      return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
      view.focus();
    view.dispatch({effects: togglePanel.of(false)});
    return true;
  };
  var searchKeymap = [
    {key: "Mod-f", run: openSearchPanel, scope: "editor search-panel"},
    {key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true},
    {key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true},
    {key: "Escape", run: closeSearchPanel, scope: "editor search-panel"},
    {key: "Mod-Shift-l", run: selectSelectionMatches},
    {key: "Alt-g", run: gotoLine},
    {key: "Mod-d", run: selectNextOccurrence, preventDefault: true}
  ];
  var SearchPanel = class {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button(name2, onclick, content2) {
        return crelt("button", {class: "cm-button", name: name2, onclick, type: "button"}, content2);
      }
      this.dom = crelt("div", {onkeydown: (e) => this.keydown(e), class: "cm-search"}, [
        this.searchField,
        button("next", () => findNext(view), [phrase(view, "next")]),
        button("prev", () => findPrevious(view), [phrase(view, "previous")]),
        button("select", () => selectMatches(view), [phrase(view, "all")]),
        crelt("label", null, [this.caseField, phrase(view, "match case")]),
        crelt("label", null, [this.reField, phrase(view, "regexp")]),
        crelt("label", null, [this.wordField, phrase(view, "by word")]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [phrase(view, "replace")]),
          button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, ["\xD7"])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({effects: setSearchQuery.of(query)});
      }
    }
    keydown(e) {
      if (runScopeHandlers(this.view, e, "search-panel")) {
        e.preventDefault();
      } else if (e.keyCode == 13 && e.target == this.searchField) {
        e.preventDefault();
        (e.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e.keyCode == 13 && e.target == this.replaceField) {
        e.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update) {
      for (let tr of update.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view, {from, to}) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
      for (let i = 0; i < AnnounceMargin; i++)
        if (!Break.test(text[i + 1]) && Break.test(text[i])) {
          text = text.slice(i);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
        if (!Break.test(text[i - 1]) && Break.test(text[i])) {
          text = text.slice(0, i);
          break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": {backgroundColor: "#ffff0054"},
    "&dark .cm-searchMatch": {backgroundColor: "#00ffff8a"},
    "&light .cm-searchMatch-selected": {backgroundColor: "#ff6a0054"},
    "&dark .cm-searchMatch-selected": {backgroundColor: "#ff00ff8a"}
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.lowest(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    constructor(state, pos, explicit) {
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      this.abortListeners = [];
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : {from: start + found, to: this.pos, text: str.slice(found)};
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type, listener) {
      if (type == "abort" && this.abortListeners)
        this.abortListeners.push(listener);
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let {label} of options) {
      first[label[0]] = true;
      for (let i = 1; i < label.length; i++)
        rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  function completeFromList(list) {
    let options = list.map((o) => typeof o == "string" ? {label: o} : o);
    let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
      let token = context.matchBefore(match);
      return token || context.explicit ? {from: token ? token.from : context.pos, options, validFor} : null;
    };
  }
  var Option = class {
    constructor(completion, source, match) {
      this.completion = completion;
      this.source = source;
      this.match = match;
    }
  };
  function cur(state) {
    return state.selection.main.head;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let {source} = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  var pickedCompletion = /* @__PURE__ */ Annotation.define();
  function insertCompletionText(state, text, from, to) {
    return Object.assign(Object.assign({}, state.changeByRange((range) => {
      if (range == state.selection.main)
        return {
          changes: {from, to, insert: text},
          range: EditorSelection.cursor(from + text.length)
        };
      let len = to - from;
      if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to))
        return {range};
      return {
        changes: {from: range.from - len, to: range.from, insert: text},
        range: EditorSelection.cursor(range.from - len + text.length)
      };
    })), {userEvent: "input.complete"});
  }
  function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string")
      view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {annotations: pickedCompletion.of(option.completion)}));
    else
      apply(view, option.completion, result.from, result.to);
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source))
      return source;
    let known = SourceCache.get(source);
    if (!known)
      SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      for (let p = 0; p < pattern.length; ) {
        let char = codePointAt(pattern, p), size = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p, p + size), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    match(word) {
      if (this.pattern.length == 0)
        return [0];
      if (word.length < this.pattern.length)
        return null;
      let {chars, folded, any, precise, byWord} = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0);
        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return [0, 0, this.pattern.length];
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
          let next = codePointAt(word, i);
          if (next == chars[anyTo] || next == folded[anyTo])
            any[anyTo++] = i;
          i += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
        let next = codePointAt(word, i);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i;
              adjacentEnd = i + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type;
        i += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return [-200 - word.length, 0, adjacentEnd];
      if (direct > -1)
        return [-700 - word.length, direct, direct + this.pattern.length];
      if (adjacentTo == len)
        return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [score2 - word.length], i = 1;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i > 1 && result[i - 1] == pos)
          result[i - 1] = to;
        else {
          result[i++] = pos;
          result[i++] = to;
        }
      }
      return result;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        compareCompletions: (a, b) => a.label.localeCompare(b.label),
        interactionDelay: 75
      }, {
        defaultKeymap: (a, b) => a && b,
        closeOnBlur: (a, b) => a && b,
        icons: (a, b) => a && b,
        optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
        addToOptions: (a, b) => a.concat(b)
      });
    }
  });
  function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let {label} = completion, off = 0;
        for (let j = 1; j < match.length; ) {
          let from = match[j++], to = match[j++];
          if (from > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
  }
  function rangeAroundSelected(total, selected, max) {
    if (total <= max)
      return {from: 0, to: total};
    if (selected < 0)
      selected = 0;
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max);
      return {from: off2 * max, to: (off2 + 1) * max};
    }
    let off = Math.floor((total - selected) / max);
    return {from: total - (off + 1) * max, to: total - off * max};
  }
  var CompletionTooltip = class {
    constructor(view, stateField) {
      this.view = view;
      this.stateField = stateField;
      this.info = null;
      this.placeInfo = {
        read: () => this.measureInfo(),
        write: (pos) => this.positionInfo(pos),
        key: this
      };
      this.space = null;
      let cState = view.state.field(stateField);
      let {options, selected} = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.dom.addEventListener("mousedown", (e) => {
        for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
            applyCompletion(view, options[+match[1]]);
            e.preventDefault();
            return;
          }
        }
      });
      this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    mount() {
      this.updateSel();
    }
    update(update) {
      var _a2, _b, _c;
      let cState = update.state.field(this.stateField);
      let prevState = update.startState.field(this.stateField);
      if (cState != prevState) {
        this.updateSel();
        if (((_a2 = cState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
      }
    }
    positioned(space) {
      this.space = space;
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        });
      }
      if (this.updateSelectedOption(open.selected)) {
        if (this.info) {
          this.info.remove();
          this.info = null;
        }
        let {completion} = open.options[open.selected];
        let {info} = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((node) => {
            if (node && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(node);
          }).catch((e) => logException(this.view.state, e, "completion info"));
        } else {
          this.addInfoPane(infoResult);
        }
      }
    }
    addInfoPane(content2) {
      let dom = this.info = document.createElement("div");
      dom.className = "cm-tooltip cm-completionInfo";
      dom.appendChild(content2);
      this.dom.appendChild(dom);
      this.view.requestMeasure(this.placeInfo);
    }
    updateSelectedOption(selected) {
      let set = null;
      for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
        if (i == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set)
        scrollIntoView2(this.list, set);
      return set;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space = this.space;
      if (!space) {
        let win = this.dom.ownerDocument.defaultView || window;
        space = {left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight};
      }
      if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
        return null;
      let rtl = this.view.textDirection == Direction.RTL, left = rtl, narrow = false, maxWidth;
      let top2 = "", bottom = "";
      let spaceLeft = listRect.left - space.left, spaceRight = space.right - listRect.right;
      if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
        left = true;
      if (infoRect.width <= (left ? spaceLeft : spaceRight)) {
        top2 = Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top + "px";
        maxWidth = Math.min(400, left ? spaceLeft : spaceRight) + "px";
      } else {
        narrow = true;
        maxWidth = Math.min(400, (rtl ? listRect.right : space.right - listRect.left) - 30) + "px";
        let spaceBelow = space.bottom - listRect.bottom;
        if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
          top2 = selRect.bottom - listRect.top + "px";
        else
          bottom = listRect.bottom - selRect.top + "px";
      }
      return {
        top: top2,
        bottom,
        maxWidth,
        class: narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right"
      };
    }
    positionInfo(pos) {
      if (this.info) {
        if (pos) {
          this.info.style.top = pos.top;
          this.info.style.bottom = pos.bottom;
          this.info.style.maxWidth = pos.maxWidth;
          this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
        } else {
          this.info.style.top = "-1e6px";
        }
      }
    }
    createListBox(options, id, range) {
      const ul = document.createElement("ul");
      ul.id = id;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      for (let i = range.from; i < range.to; i++) {
        let {completion, match} = options[i];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id + "-" + i;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, match);
          if (node)
            li.appendChild(node);
        }
      }
      if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
  };
  function completionTooltip(stateField) {
    return (view) => new CompletionTooltip(view, stateField);
  }
  function scrollIntoView2(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top)
      container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom)
      container.scrollTop += self.bottom - parent.bottom;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    let options = [], i = 0;
    for (let a of active)
      if (a.hasResult()) {
        if (a.result.filter === false) {
          let getMatch = a.result.getMatch;
          for (let option of a.result.options) {
            let match = [1e9 - i++];
            if (getMatch)
              for (let n of getMatch(option))
                match.push(n);
            options.push(new Option(option, a, match));
          }
        } else {
          let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;
          for (let option of a.result.options)
            if (match = matcher.match(option.label)) {
              if (option.boost != null)
                match[0] += option.boost;
              options.push(new Option(option, a, match));
            }
        }
      }
    let result = [], prev = null;
    let compare2 = state.facet(completionConfig).compareCompletions;
    for (let opt of options.sort((a, b) => b.match[0] - a.match[0] || compare2(a.completion, b.completion))) {
      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
      this.options = options;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    setSelected(selected, id) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf) {
      let options = sortOptions(active, state);
      if (!options.length) {
        return prev && active.some((a) => a.state == 1) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
      }
      let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i = 0; i < options.length; i++)
          if (options[i].completion == selectedValue) {
            selected = i;
            break;
          }
      }
      return new CompletionDialog(options, makeAttrs(id, selected), {
        pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
        create: completionTooltip(completionState),
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {pos: changes.mapPos(this.tooltip.pos)}), this.timestamp, this.selected, this.disabled);
    }
  };
  var CompletionState = class {
    constructor(active, id, open) {
      this.active = active;
      this.id = id;
      this.open = open;
    }
    static start() {
      return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let {state} = tr, conf = state.facet(completionConfig);
      let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a) => a.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
        active = this.active;
      let open = this.open;
      if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active))
        open = CompletionDialog.build(active, state, this.id, this.open, conf);
      else if (open && tr.docChanged)
        open = open.map(tr.changes);
      if (!open && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
        active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : baseAttrs;
    }
  };
  function sameResults(a, b) {
    if (a == b)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a.length && !a[iA].hasResult)
        iA++;
      while (iB < b.length && !b[iB].hasResult)
        iB++;
      let endA = iA == a.length, endB = iB == b.length;
      if (endA || endB)
        return endA == endB;
      if (a[iA++].result != b[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id, selected) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id
    };
    if (selected > -1)
      result["aria-activedescendant"] = id + "-" + selected;
    return result;
  }
  var none3 = [];
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = class {
    constructor(source, state, explicitPos = -1) {
      this.source = source;
      this.state = state;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let event = getUserEvent(tr), value = this;
      if (event)
        value = value.handleUserEvent(tr, event, conf);
      else if (tr.docChanged)
        value = value.handleChange(tr);
      else if (tr.selection && value.state != 0)
        value = new ActiveSource(value.source, 0);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    handleUserEvent(tr, type, conf) {
      return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
  };
  var ActiveResult = class extends ActiveSource {
    constructor(source, explicitPos, result, from, to) {
      super(source, 2, explicitPos);
      this.result = result;
      this.from = from;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    handleUserEvent(tr, type, conf) {
      var _a2;
      let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
        return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
      if (checkValid(this.result.validFor, tr.state, from, to))
        return new ActiveResult(this.source, explicitPos, this.result, from, to);
      if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(mapping) {
      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
  };
  function checkValid(validFor, state, from, to) {
    if (!validFor)
      return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state) => state.attrs)
    ]
  });
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let {length} = cState.open.options;
      let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
      if (selected < 0)
        selected = by == "page" ? 0 : length - 1;
      else if (selected >= length)
        selected = by == "page" ? length - 1 : 0;
      view.dispatch({effects: setSelectedEffect.of(selected)});
      return true;
    };
  }
  var acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    if (!cState.open.disabled)
      applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
  };
  var startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
      return false;
    view.dispatch({effects: startCompletionEffect.of(true)});
    return true;
  };
  var closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a) => a.state != 0))
      return false;
    view.dispatch({effects: closeCompletionEffect.of(null)});
    return true;
  };
  var RunningQuery = class {
    constructor(active, context) {
      this.active = active;
      this.context = context;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var DebounceTime = 50;
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0;
      for (let active of view.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update) {
      let cState = update.state.field(completionState);
      if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
        return;
      let doesReset = update.transactions.some((tr) => {
        return (tr.selection || tr.docChanged) && !getUserEvent(tr);
      });
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e) {
              logException(this.view.state, e);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i--, 1);
        } else {
          query.updates.push(...update.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
      if (this.composing != 0)
        for (let tr of update.transactions) {
          if (getUserEvent(tr) == "input")
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      let {state} = this.view, cState = state.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
          this.startQuery(active);
      }
    }
    startQuery(active) {
      let {state} = this.view, pos = cur(state);
      let context = new CompletionContext(state, pos, active.explicitPos == pos);
      let pending = new RunningQuery(active, context);
      this.running.push(pending);
      Promise.resolve(active.source(context)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({effects: closeCompletionEffect.of(null)});
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig);
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (query.done === void 0)
          continue;
        this.running.splice(i--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length)
        this.view.dispatch({effects: setActiveEffect.of(updated)});
    }
  }, {
    eventHandlers: {
      blur() {
        let state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
          this.view.dispatch({effects: closeCompletionEffect.of(null)});
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({effects: startCompletionEffect.of(false)}), 20);
        }
        this.composing = 0;
      }
    }
  });
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer",
          padding: "1px 3px",
          lineHeight: 1.2
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": {right: "100%"},
    ".cm-completionInfo.cm-completionInfo-right": {left: "100%"},
    ".cm-completionInfo.cm-completionInfo-left-narrow": {right: `${30}px`},
    ".cm-completionInfo.cm-completionInfo-right-narrow": {left: `${30}px`},
    "&light .cm-snippetField": {backgroundColor: "#00000022"},
    "&dark .cm-snippetField": {backgroundColor: "#ffffff22"},
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {content: "'\u0192'"}
    },
    ".cm-completionIcon-class": {
      "&:after": {content: "'\u25CB'"}
    },
    ".cm-completionIcon-interface": {
      "&:after": {content: "'\u25CC'"}
    },
    ".cm-completionIcon-variable": {
      "&:after": {content: "'\u{1D465}'"}
    },
    ".cm-completionIcon-constant": {
      "&:after": {content: "'\u{1D436}'"}
    },
    ".cm-completionIcon-type": {
      "&:after": {content: "'\u{1D461}'"}
    },
    ".cm-completionIcon-enum": {
      "&:after": {content: "'\u222A'"}
    },
    ".cm-completionIcon-property": {
      "&:after": {content: "'\u25A1'"}
    },
    ".cm-completionIcon-keyword": {
      "&:after": {content: "'\u{1F511}\uFE0E'"}
    },
    ".cm-completionIcon-namespace": {
      "&:after": {content: "'\u25A2'"}
    },
    ".cm-completionIcon-text": {
      "&:after": {content: "'abc'", fontSize: "50%", verticalAlign: "middle"}
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      return mapping.mapPos(value);
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      if (tr.selection) {
        let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1))
          value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(closeBracketEffect))
          value = value.update({add: [closedBracket.range(effect.value, effect.value + 1)]});
        else if (effect.is(skipBracketEffect))
          value = value.update({filter: (from) => from != effect.value});
      }
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
      if (definedClosing.charCodeAt(i) == ch)
        return definedClosing.charAt(i + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
      return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
      return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr)
      return false;
    view.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({state, dispatch}) => {
    if (state.readOnly)
      return false;
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty) {
        let before = prevChar(state.doc, range.head);
        for (let token of tokens) {
          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
            return {
              changes: {from: range.head - token.length, to: range.head + token.length},
              range: EditorSelection.cursor(range.head - token.length)
            };
        }
      }
      return {range: dont = range};
    });
    if (!dont)
      dispatch(state.update(changes, {scrollIntoView: true, userEvent: "delete.backward"}));
    return !dont;
  };
  var closeBracketsKeymap = [
    {key: "Backspace", run: deleteBracketPair}
  ];
  function insertBracket(state, bracket2) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
        return handleClose(state, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, (from) => {
      if (from == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{insert: open, from: range.from}, {insert: close, from: range.to}],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
      let next = nextChar(state.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: {insert: open + close, from: range.head},
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
      return {range: dont = range};
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    let dont = null, moved = state.selection.ranges.map((range) => {
      if (range.empty && nextChar(state.doc, range.head) == close)
        return EditorSelection.cursor(range.head + close.length);
      return dont = range;
    });
    return dont ? null : state.update({
      selection: EditorSelection.create(moved, state.selection.mainIndex),
      scrollIntoView: true,
      effects: state.selection.ranges.map(({from}) => skipBracketEffect.of(from))
    });
  }
  function handleSame(state, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{insert: token, from: range.from}, {insert: token, from: range.to}],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
      let pos = range.head, next = nextChar(state.doc, pos), start;
      if (next == token) {
        if (nodeStart(state, pos)) {
          return {
            changes: {insert: token + token, from: pos},
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state, pos)) {
          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          return {
            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
            effects: skipBracketEffect.of(pos)
          };
        }
      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
        return {
          changes: {insert: token + token + token + token, from: pos},
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
          return {
            changes: {insert: token + token, from: pos},
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return {range: dont = range};
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    let tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    let node = syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i = 0; i < 5; i++) {
      let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
            return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
      return pos;
    for (let prefix of prefixes) {
      let start = pos - prefix.length;
      if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
        return start;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    {key: "Ctrl-Space", run: startCompletion},
    {key: "Escape", run: closeCompletion},
    {key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true)},
    {key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false)},
    {key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page")},
    {key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page")},
    {key: "Enter", run: acceptCompletion}
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics);
      let ranges = Decoration.set(markedDiagnostics.map((d) => {
        return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
          widget: new DiagnosticWidget(d),
          diagnostic: d
        }).range(d.from) : Decoration.mark({
          attributes: {class: "cm-lintRange cm-lintRange-" + d.severity},
          diagnostic: d
        }).range(d.from, d.to);
      }), true);
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, {spec}) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
      lintState,
      EditorView.decorations.compute([lintState], (state2) => {
        let {selected, panel} = state2.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      hoverTooltip(lintTooltip, {hideOn: hideTooltip}),
      baseTheme5
    ]));
  }
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        let mapped = value.diagnostics.map(tr.changes), selected = null;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          value = LintState.init(effect.value, value.panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({class: "cm-lintRange cm-lintRange-active"});
  function lintTooltip(view, pos, side) {
    let {diagnostics} = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, {spec}) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return {dom: diagnosticsTooltip(view, found)};
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", {class: "cm-tooltip-lint"}, diagnostics.map((d) => renderDiagnostic(view, d, false)));
  }
  var openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      view.dispatch({effects: maybeEnableLint(view.state, [togglePanel2.of(true)])});
    let panel = getPanel(view, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({effects: togglePanel2.of(false)});
    return true;
  };
  var nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view.dispatch({selection: {anchor: next.from, head: next.to}, scrollIntoView: true});
    return true;
  };
  var lintKeymap = [
    {key: "Mod-Shift-m", run: openLintPanel, preventDefault: true},
    {key: "F8", run: nextDiagnostic}
  ];
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let {delay} = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    run() {
      let now = Date.now();
      if (now < this.lintTime - 10) {
        setTimeout(this.run, this.lintTime - now);
      } else {
        this.set = false;
        let {state} = this.view, {sources} = state.facet(lintConfig);
        Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
          let all = annotations.reduce((a, b) => a.concat(b));
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, all));
        }, (error) => {
          logException(this.view.state, error);
        });
      }
    }
    update(update) {
      let config2 = update.state.facet(lintConfig);
      if (update.docChanged || config2 != update.startState.facet(lintConfig)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({sources: input.map((i) => i.source)}, combineConfig(input.map((i) => i.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null
      }));
    },
    enables: lintPlugin
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions:
        for (let {name: name2} of actions) {
          for (let i = 0; i < name2.length; i++) {
            let ch = name2[i];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", {class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity}, crelt("span", {class: "cm-diagnosticText"}, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i) => {
      let click = (e) => {
        e.preventDefault();
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view, found.from, found.to);
      };
      let {name: name2} = action, keyIndex = keys2[i] ? name2.indexOf(keys2[i]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", {class: "cm-diagnosticSource"}, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", {class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity});
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let {diagnostic} = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
          for (let i = 0; i < keys2.length; i++)
            if (keys2[i].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i = 0; i < this.items.length; i++) {
          if (this.items[i].dom.contains(event.target))
            this.moveSelection(i);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", {class: "cm-panel-lint"}, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i = 0; i < this.items.length; i++)
        if (this.items[i].diagnostic == selected.diagnostic)
          return i;
      return -1;
    }
    update() {
      let {diagnostics, selected} = this.view.state.field(lintState);
      let i = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, {spec}) => {
        let found = -1, item;
        for (let j = i; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i) {
            this.items.splice(i, found - i);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i++;
      });
      while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect()}),
          write: ({sel, panel}) => {
            if (sel.top < panel.top)
              this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += sel.bottom - panel.bottom;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection3 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection3)
        return;
      this.view.dispatch({
        selection: {anchor: selection3.from, head: selection3.to},
        scrollIntoView: true,
        effects: movePanelSelection.of(selection3)
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {borderLeft: "5px solid #d11"},
    ".cm-diagnostic-warning": {borderLeft: "5px solid orange"},
    ".cm-diagnostic-info": {borderLeft: "5px solid #999"},
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {backgroundImage: /* @__PURE__ */ underline("#d11")},
    ".cm-lintRange-warning": {backgroundImage: /* @__PURE__ */ underline("orange")},
    ".cm-lintRange-info": {backgroundImage: /* @__PURE__ */ underline("#999")},
    ".cm-lintRange-active": {backgroundColor: "#ffdd9980"},
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {borderBottomColor: "orange"}
    },
    ".cm-lintPoint-info": {
      "&:after": {borderBottomColor: "#999"}
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {textDecoration: "underline"}
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {textDecoration: "none"},
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });

  // node_modules/codemirror/dist/index.js
  var basicSetup = /* @__PURE__ */ (() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    syntaxHighlighting(defaultHighlightStyle, {fallback: true}),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ])();

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class {
    constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score2;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    toString() {
      return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p, state, pos = 0) {
      let cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action) {
      let depth = action >> 19, type = action & 65535;
      let {parser: parser2} = this.p;
      let dPrec = parser2.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
        if (type < parser2.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start = this.stack[base2 - 2];
      let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser2.minRepeatTerm || action & 131072) {
        let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser2.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start);
    }
    storeNode(term, start, end, size = 4, isReduce = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur2 = this, top2 = this.buffer.length;
        if (top2 == 0 && cur2.parent) {
          top2 = cur2.bufferBase - cur2.parent.bufferBase;
          cur2 = cur2.parent;
        }
        if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
          if (start == end)
            return;
          if (cur2.buffer[top2 - 2] >= start) {
            cur2.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        let index = this.buffer.length;
        if (index > 0 && this.buffer[index - 4] != 0)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index] = term;
        this.buffer[index + 1] = start;
        this.buffer[index + 2] = end;
        this.buffer[index + 3] = size;
      }
    }
    shift(action, next, nextEnd) {
      let start = this.pos;
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, {parser: parser2} = this.p;
        if (nextEnd > this.pos || next <= parser2.maxNode) {
          this.pos = nextEnd;
          if (!parser2.stateFlag(nextState, 1))
            this.reducePos = nextEnd;
        }
        this.pushState(nextState, start);
        this.shiftContext(next, start);
        if (next <= parser2.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      } else {
        this.pos = nextEnd;
        this.shiftContext(next, start);
        if (next <= this.p.parser.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      }
    }
    apply(action, next, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextEnd);
    }
    useNode(value, next) {
      let index = this.p.reused.length - 1;
      if (index < 0 || this.p.reused[index] != value) {
        this.p.reused.push(value);
        index++;
      }
      let start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(index, start, this.reducePos, -1);
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if ((action & 65536) == 0)
          return true;
        if (action == 0)
          return false;
        sim.reduce(action);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
            best.push(nextStates[i], s);
        }
        if (this.stack.length < 120)
          for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i2) => i2 & 1 && v == s))
              best.push(nextStates[i], s);
          }
        nextStates = best;
      }
      let result = [];
      for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
        let s = nextStates[i + 1];
        if (s == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i], this.pos);
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      let reduce = this.p.parser.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0)
        return false;
      let {parser: parser2} = this.p;
      if (!parser2.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
          return false;
        this.storeNode(0, this.reducePos, this.reducePos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2)) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let {parser: parser2} = this.p;
      return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
    }
    restart() {
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i = 0; i < this.stack.length; i += 3)
        if (this.stack[i] != other.stack[i])
          return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    emitContext() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3)
        this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4)
        this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var Recover;
  (function(Recover2) {
    Recover2[Recover2["Insert"] = 200] = "Insert";
    Recover2[Recover2["Delete"] = 190] = "Delete";
    Recover2[Recover2["Reduce"] = 100] = "Reduce";
    Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
    Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
  })(Recover || (Recover = {}));
  var SimulatedStack = class {
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class {
    constructor(stack, pos, index) {
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    resolveOffset(offset, assoc) {
      let range = this.range, index = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range.from) {
        if (!index)
          return null;
        let next = this.ranges[--index];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range of this.ranges)
        if (range.to > pos)
          return Math.max(pos, range.from);
      return this.end;
    }
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let {chunk, chunkPos} = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n = 1) {
      this.chunkOff += n;
      while (this.pos + n >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
      if (from >= this.range.from && to <= this.range.to)
        return this.input.read(from, to);
      let result = "";
      for (let r of this.ranges) {
        if (r.from >= to)
          break;
        if (r.to > from)
          result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id) {
      this.data = data;
      this.id = id;
    }
    token(input, stack) {
      readToken(this.data, input, stack, this.id);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, {parser: parser2} = stack.p, {dialect} = parser2;
    scan:
      for (; ; ) {
        if ((groupMask & data[state]) == 0)
          break;
        let accEnd = data[state + 1];
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data[i + 1] & groupMask) > 0) {
            let term = data[i];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
              input.acceptToken(term);
              break;
            }
          }
        let next = input.next, low = 0, high = data[state + 2];
        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
          state = data[accEnd + high * 3 - 1];
          continue scan;
        }
        for (; low < high; ) {
          let mid = low + high >> 1;
          let index = accEnd + mid + (mid << 1);
          let from = data[index], to = data[index + 1] || 65536;
          if (next < from)
            high = mid;
          else if (next >= to)
            low = mid + 1;
          else {
            state = data[index + 2];
            input.advance();
            continue scan;
          }
        }
        break;
      }
  }
  function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array)
        array[out++] = value;
      else
        array = new Type(value);
    }
    return array;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function(Safety2) {
    Safety2[Safety2["Margin"] = 25] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    let cursor3 = tree.cursor(IterMode.IncludeAnonymous);
    cursor3.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor3.childBefore(pos) : cursor3.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor3.to < pos : cursor3.from > pos) && !cursor3.type.isError)
            return side < 0 ? Math.max(0, Math.min(cursor3.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor3.from + 1, pos + 25));
          if (side < 0 ? cursor3.prevSibling() : cursor3.nextSibling())
            break;
          if (!cursor3.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last], index = this.index[last];
        if (index == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index];
        let start = this.start[last] + top2.positions[index];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom)
              return null;
            let end = start + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser2, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser2.tokenizers.map((_) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let {parser: parser2} = stack.p, {tokenizers} = parser2;
      let mask = parser2.stateSlot(stack.state, 3);
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i = 0; i < tokenizers.length; i++) {
        if ((1 << i & mask) == 0)
          continue;
        let tokenizer = tokenizers[i], token = this.tokens[i];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), {pos, p} = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        let {parser: parser2} = stack.p;
        for (let i = 0; i < parser2.specialized.length; i++)
          if (parser2.specialized[i] == token.value) {
            let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index) {
      for (let i = 0; i < index; i += 3)
        if (this.actions[i] == action)
          return index;
      this.actions[index++] = action;
      this.actions[index++] = token;
      this.actions[index++] = end;
      return index;
    }
    addActions(stack, token, end, index) {
      let {state} = stack, {parser: parser2} = stack.p, {data} = parser2;
      for (let set = 0; set < 2; set++) {
        for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
          if (data[i] == 65535) {
            if (data[i + 1] == 1) {
              i = pair(data, i + 2);
            } else {
              if (index == 0 && data[i + 1] == 2)
                index = this.putAction(pair(data, i + 2), token, end, index);
              break;
            }
          }
          if (data[i] == token)
            index = this.putAction(pair(data, i + 1), token, end, index);
        }
      }
      return index;
    }
  };
  var Rec;
  (function(Rec2) {
    Rec2[Rec2["Distance"] = 5] = "Distance";
    Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
    Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
  })(Rec || (Rec = {}));
  var Parse = class {
    constructor(parser2, input, fragments, ranges) {
      this.parser = parser2;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser2, this.stream);
      this.topTerm = parser2.top[1];
      let {from} = ranges[0];
      this.stacks = [Stack.start(this, parser2.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished)
          return this.stackToTree(finished);
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished)
          return this.stackToTree(finished.forceAll());
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a, b) => b.score - a.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer:
          for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
      }
      this.minStackPos = newStacks[0].pos;
      for (let i = 1; i < newStacks.length; i++)
        if (newStacks[i].pos < this.minStackPos)
          this.minStackPos = newStacks[i].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      let start = stack.pos, {parser: parser2} = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser2.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
        return true;
      }
      if (stack.stack.length >= 15e3) {
        while (stack.stack.length > 9e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i = 0; i < actions.length; ) {
        let action = actions[i++], term = actions[i++], end = actions[i++];
        let last = i == actions.length || !split;
        let localStack = last ? stack : stack.split();
        localStack.apply(action, term, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
        if (last)
          return true;
        else if (localStack.pos > start)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j = 0; force.forceReduce() && j < 10; j++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
      if (!id)
        stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
      return id + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
      let other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score)
          newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var LRParser = class extends Parser {
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i = 0; i < spec.repeatNodeCount; i++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
      let nodeProps = [];
      for (let i = 0; i < nodeNames.length; i++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i = 1; i < propSpec.length; ) {
            let next = propSpec[i++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i++]);
            } else {
              let value = propSpec[i + -next];
              for (let j = -next; j > 0; j--)
                setProp(propSpec[i++], prop, value);
              i++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
        name: i >= this.minRepeatTerm ? void 0 : name2,
        id: i,
        props: nodeProps[i],
        top: topTerms.indexOf(i) > -1,
        error: i == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i = 0; i < this.specializerSpecs.length; i++)
        this.specialized[i] = this.specializerSpecs[i].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse = new Parse(this, input, fragments, ranges);
      for (let w of this.wrappers)
        parse = w(parse, input, fragments, ranges);
      return parse;
    }
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last = groupTag & 1;
        let target = table[pos++];
        if (last && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last)
          return -1;
      }
    }
    hasAction(state, terminal) {
      let data = this.data;
      for (let set = 0; set < 2; set++) {
        for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
          if ((next = data[i]) == 65535) {
            if (data[i + 1] == 1)
              next = data[i = pair(data, i + 2)];
            else if (data[i + 1] == 2)
              return pair(data, i + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action) {
      if (action == this.stateSlot(state, 4))
        return true;
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            return false;
        }
        if (action == pair(this.data, i + 1))
          return true;
      }
    }
    nextStates(state) {
      let result = [];
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        if ((this.data[i + 2] & 65536 >> 16) == 0) {
          let value = this.data[i + 1];
          if (!result.some((v, i2) => i2 & 1 && v == value))
            result.push(this.data[i], value);
        }
      }
      return result;
    }
    overrides(token, prev) {
      let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
      return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config2) {
      let copy = Object.assign(Object.create(LRParser.prototype), this);
      if (config2.props)
        copy.nodeSet = this.nodeSet.extend(...config2.props);
      if (config2.top) {
        let info = this.topRules[config2.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config2.top}`);
        copy.top = info;
      }
      if (config2.tokenizers)
        copy.tokenizers = this.tokenizers.map((t2) => {
          let found = config2.tokenizers.find((r) => r.from == t2);
          return found ? found.to : t2;
        });
      if (config2.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
          let found = config2.specializers.find((r) => r.from == s.external);
          if (!found)
            return s;
          let spec = Object.assign(Object.assign({}, s), {external: found.to});
          copy.specializers[i] = getSpecializer(spec);
          return spec;
        });
      }
      if (config2.contextTracker)
        copy.context = config2.contextTracker;
      if (config2.dialect)
        copy.dialect = this.parseDialect(config2.dialect);
      if (config2.strict != null)
        copy.strict = config2.strict;
      if (config2.wrap)
        copy.wrappers = copy.wrappers.concat(config2.wrap);
      if (config2.bufferLength != null)
        copy.bufferLength = config2.bufferLength;
      return copy;
    }
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      let values = Object.keys(this.dialects), flags = values.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id = values.indexOf(part);
          if (id >= 0)
            flags[id] = true;
        }
      let disabled = null;
      for (let i = 0; i < values.length; i++)
        if (!flags[i]) {
          for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535; i++)
      if (next == term)
        return i - start;
    return -1;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/@lezer/json/dist/index.es.js
  var jsonHighlighting = styleTags({
    String: tags.string,
    Number: tags.number,
    "True False": tags.bool,
    PropertyName: tags.propertyName,
    Null: tags.null,
    ",": tags.separator,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace
  });
  var parser = LRParser.deserialize({
    version: 14,
    states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
    stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
    goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
    nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
    maxTerm: 25,
    nodeProps: [
      ["openedBy", 7, "{", 12, "["],
      ["closedBy", 8, "}", 13, "]"]
    ],
    propSources: [jsonHighlighting],
    skippedNodes: [0],
    repeatNodeCount: 2,
    tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
    tokenizers: [0],
    topRules: {JsonText: [0, 1]},
    tokenPrec: 0
  });

  // node_modules/@codemirror/lang-json/dist/index.js
  var jsonLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "json",
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          Object: /* @__PURE__ */ continuedIndent({except: /^\s*\}/}),
          Array: /* @__PURE__ */ continuedIndent({except: /^\s*\]/})
        }),
        /* @__PURE__ */ foldNodeProp.add({
          "Object Array": foldInside
        })
      ]
    }),
    languageData: {
      closeBrackets: {brackets: ["[", "{", '"']},
      indentOnInput: /^\s*[\}\]]$/
    }
  });
  function json() {
    return new LanguageSupport(jsonLanguage);
  }

  // node_modules/cm6-theme-basic-light/dist/index.js
  var base00 = "#2e3440";
  var base01 = "#3b4252";
  var base02 = "#434c5e";
  var base03 = "#4c566a";
  var base05 = "#e5e9f0";
  var base06 = "#eceff4";
  var base07 = "#8fbcbb";
  var base08 = "#88c0d0";
  var base09 = "#81a1c1";
  var base0A = "#5e81ac";
  var base0b = "#bf616a";
  var base0C = "#d08770";
  var base0D = "#ebcb8b";
  var base0E = "#a3be8c";
  var base0F = "#b48ead";
  var invalid = "#d30102";
  var darkBackground = base06;
  var highlightBackground = darkBackground;
  var background = "#ffffff";
  var tooltipBackground = base01;
  var selection = darkBackground;
  var cursor = base01;
  var basicLightTheme = /* @__PURE__ */ EditorView.theme({
    "&": {
      color: base00,
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: cursor
    },
    ".cm-cursor, .cm-dropCursor": {borderLeftColor: cursor},
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {backgroundColor: selection},
    ".cm-panels": {backgroundColor: darkBackground, color: base03},
    ".cm-panels.cm-panels-top": {borderBottom: "2px solid black"},
    ".cm-panels.cm-panels-bottom": {borderTop: "2px solid black"},
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: `1px solid ${base03}`
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: base05
    },
    ".cm-activeLine": {backgroundColor: highlightBackground},
    ".cm-selectionMatch": {backgroundColor: base05},
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      outline: `1px solid ${base03}`
    },
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: base06
    },
    ".cm-gutters": {
      backgroundColor: base06,
      color: base00,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground,
        color: base03
      }
    }
  }, {dark: false});
  var basicLightHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {tag: tags.keyword, color: base0A},
    {
      tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
      color: base0C
    },
    {tag: [tags.variableName], color: base0C},
    {tag: [/* @__PURE__ */ tags.function(tags.variableName)], color: base0A},
    {tag: [tags.labelName], color: base09},
    {
      tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
      color: base0A
    },
    {tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator], color: base0E},
    {tag: [tags.brace], color: base07},
    {
      tag: [tags.annotation],
      color: invalid
    },
    {
      tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
      color: base08
    },
    {
      tag: [tags.typeName, tags.className],
      color: base0D
    },
    {
      tag: [tags.operator, tags.operatorKeyword],
      color: base0E
    },
    {
      tag: [tags.tagName],
      color: base0F
    },
    {
      tag: [tags.squareBracket],
      color: base0b
    },
    {
      tag: [tags.angleBracket],
      color: base0C
    },
    {
      tag: [tags.attributeName],
      color: base0D
    },
    {
      tag: [tags.regexp],
      color: base0A
    },
    {
      tag: [tags.quote],
      color: base01
    },
    {tag: [tags.string], color: base0C},
    {
      tag: tags.link,
      color: base07,
      textDecoration: "underline",
      textUnderlinePosition: "under"
    },
    {
      tag: [tags.url, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: base0C
    },
    {tag: [tags.meta], color: base08},
    {tag: [tags.comment], color: base02, fontStyle: "italic"},
    {tag: tags.strong, fontWeight: "bold", color: base0A},
    {tag: tags.emphasis, fontStyle: "italic", color: base0A},
    {tag: tags.strikethrough, textDecoration: "line-through"},
    {tag: tags.heading, fontWeight: "bold", color: base0A},
    {tag: /* @__PURE__ */ tags.special(tags.heading1), fontWeight: "bold", color: base0A},
    {tag: tags.heading1, fontWeight: "bold", color: base0A},
    {
      tag: [tags.heading2, tags.heading3, tags.heading4],
      fontWeight: "bold",
      color: base0A
    },
    {
      tag: [tags.heading5, tags.heading6],
      color: base0A
    },
    {tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)], color: base0C},
    {
      tag: [tags.processingInstruction, tags.inserted],
      color: base07
    },
    {
      tag: [tags.contentSeparator],
      color: base0D
    },
    {tag: tags.invalid, color: base02, borderBottom: `1px dotted ${invalid}`}
  ]);
  var basicLight = [
    basicLightTheme,
    /* @__PURE__ */ syntaxHighlighting(basicLightHighlightStyle)
  ];

  // node_modules/cm6-theme-solarized-dark/dist/index.js
  var base002 = "#002b36";
  var base012 = "#073642";
  var base022 = "#586e75";
  var base032 = "#657b83";
  var base04 = "#839496";
  var base052 = "#93a1a1";
  var base062 = "#eee8d5";
  var base072 = "#fdf6e3";
  var base_red = "#dc322f";
  var base_orange = "#cb4b16";
  var base_yellow = "#b58900";
  var base_green = "#859900";
  var base_cyan = "#2aa198";
  var base_blue = "#268bd2";
  var base_violet = "#6c71c4";
  var base_magenta = "#d33682";
  var invalid2 = "#d30102";
  var stone = base04;
  var darkBackground2 = "#00252f";
  var highlightBackground2 = "#173541";
  var background2 = base002;
  var tooltipBackground2 = base012;
  var selection2 = "#173541";
  var cursor2 = base04;
  var solarizedDarkTheme = /* @__PURE__ */ EditorView.theme({
    "&": {
      color: base052,
      backgroundColor: background2
    },
    ".cm-content": {
      caretColor: cursor2
    },
    ".cm-cursor, .cm-dropCursor": {borderLeftColor: cursor2},
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {backgroundColor: selection2},
    ".cm-panels": {backgroundColor: darkBackground2, color: base032},
    ".cm-panels.cm-panels-top": {borderBottom: "2px solid black"},
    ".cm-panels.cm-panels-bottom": {borderTop: "2px solid black"},
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": {backgroundColor: highlightBackground2},
    ".cm-selectionMatch": {backgroundColor: "#aafe661a"},
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      outline: `1px solid ${base062}`
    },
    ".cm-gutters": {
      backgroundColor: darkBackground2,
      color: stone,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground2
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground2
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground2,
      borderBottomColor: tooltipBackground2
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground2,
        color: base032
      }
    }
  }, {dark: true});
  var solarizedDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {tag: tags.keyword, color: base_green},
    {
      tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
      color: base_cyan
    },
    {tag: [tags.variableName], color: base052},
    {tag: [/* @__PURE__ */ tags.function(tags.variableName)], color: base_blue},
    {tag: [tags.labelName], color: base_magenta},
    {
      tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
      color: base_yellow
    },
    {tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator], color: base_cyan},
    {tag: [tags.brace], color: base_magenta},
    {
      tag: [tags.annotation],
      color: invalid2
    },
    {
      tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
      color: base_magenta
    },
    {
      tag: [tags.typeName, tags.className],
      color: base_orange
    },
    {
      tag: [tags.operator, tags.operatorKeyword],
      color: base_violet
    },
    {
      tag: [tags.tagName],
      color: base_blue
    },
    {
      tag: [tags.squareBracket],
      color: base_red
    },
    {
      tag: [tags.angleBracket],
      color: base022
    },
    {
      tag: [tags.attributeName],
      color: base052
    },
    {
      tag: [tags.regexp],
      color: invalid2
    },
    {
      tag: [tags.quote],
      color: base_green
    },
    {tag: [tags.string], color: base_yellow},
    {
      tag: tags.link,
      color: base_cyan,
      textDecoration: "underline",
      textUnderlinePosition: "under"
    },
    {
      tag: [tags.url, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: base_yellow
    },
    {tag: [tags.meta], color: base_red},
    {tag: [tags.comment], color: base022, fontStyle: "italic"},
    {tag: tags.strong, fontWeight: "bold", color: base062},
    {tag: tags.emphasis, fontStyle: "italic", color: base_green},
    {tag: tags.strikethrough, textDecoration: "line-through"},
    {tag: tags.heading, fontWeight: "bold", color: base_yellow},
    {tag: tags.heading1, fontWeight: "bold", color: base072},
    {
      tag: [tags.heading2, tags.heading3, tags.heading4],
      fontWeight: "bold",
      color: base062
    },
    {
      tag: [tags.heading5, tags.heading6],
      color: base062
    },
    {tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)], color: base_magenta},
    {
      tag: [tags.processingInstruction, tags.inserted, tags.contentSeparator],
      color: base_red
    },
    {
      tag: [tags.contentSeparator],
      color: base_yellow
    },
    {tag: tags.invalid, color: base022, borderBottom: `1px dotted ${base_red}`}
  ]);
  var solarizedDark = [
    solarizedDarkTheme,
    /* @__PURE__ */ syntaxHighlighting(solarizedDarkHighlightStyle)
  ];

  // resources/js/components/json-field.js
  var theme2 = new Compartment();
  var json_field_default = (Alpine) => {
    Alpine.data("filamentJsonField", ({state, disabled}) => {
      return {
        state,
        codeMirror: null,
        init() {
          this.codeMirror = new EditorView({
            doc: this.state ? this.state : "{\n\n}",
            extensions: this.buildExtensionsArray(),
            parent: this.$refs.jsonBlock
          });
          window.addEventListener("dark-mode-toggled", (e) => {
            this.codeMirror.dispatch({
              effects: theme2.reconfigure(e.detail === "dark" ? solarizedDark : basicLight)
            });
          });
        },
        buildExtensionsArray() {
          const darkModeElement = document.querySelector("[dark-mode]");
          const lightMode = darkModeElement._x_dataStack[0].theme === "light";
          return [
            basicSetup,
            json(),
            keymap.of([indentWithTab]),
            EditorView.lineWrapping,
            EditorView.updateListener.of((v) => {
              if (v.docChanged) {
                this.state = v.state.doc.toString();
              }
            }),
            EditorView.contentAttributes.of({contenteditable: !disabled}),
            theme2.of(lightMode ? basicLight : solarizedDark)
          ];
        }
      };
    });
  };

  // resources/js/plugin.js
  document.addEventListener("alpine:init", () => {
    window.Alpine.plugin(json_field_default);
  });
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvanNvbi9kaXN0L2luZGV4LmVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWpzb24vZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY202LXRoZW1lLWJhc2ljLWxpZ2h0L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NtNi10aGVtZS1zb2xhcml6ZWQtZGFyay9kaXN0L2luZGV4LmpzIiwgIi4uL2pzL2NvbXBvbmVudHMvanNvbi1maWVsZC5qcyIsICIuLi9qcy9wbHVnaW4uanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxuKi9cbmNsYXNzIFRleHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuICgxLWJhc2VkKSBsaW5lIG51bWJlci5cbiAgICAqL1xuICAgIGxpbmUobikge1xuICAgICAgICBpZiAobiA8IDEgfHwgbiA+IHRoaXMubGluZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke259IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcbiAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMubGVuZ3RoICsgdGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZS5zbGljZShNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudGV4dClcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKCkgeyByZXR1cm4gMDsgfVxuICAgIHN0YXRpYyBzcGxpdCh0ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dCkge1xuICAgICAgICAgICAgcGFydC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+IC0xKVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn1cbi8vIE5vZGVzIHByb3ZpZGUgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBgVGV4dGAgdHlwZS4gVGhleSBzdG9yZSBhXG4vLyBudW1iZXIgb2Ygb3RoZXIgbm9kZXMgb3IgbGVhdmVzLCB0YWtpbmcgY2FyZSB0byBiYWxhbmNlIHRoZW1zZWx2ZXNcbi8vIG9uIGNoYW5nZXMuIFRoZXJlIGFyZSBpbXBsaWVkIGxpbmUgYnJlYWtzIF9iZXR3ZWVuXyB0aGUgY2hpbGRyZW4gb2Zcbi8vIGEgbm9kZSAoYnV0IG5vdCBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkKS5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICB0aGlzLmxpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgIH1cbiAgICBsaW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQubGVuZ3RoLCBlbmRMaW5lID0gbGluZSArIGNoaWxkLmxpbmVzIC0gMTtcbiAgICAgICAgICAgIGlmICgoaXNMaW5lID8gZW5kTGluZSA6IGVuZCkgPj0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5saW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSA9IGVuZExpbmUgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmcm9tIDw9IGVuZCAmJiB0byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPcGVuID0gb3BlbiAmICgocG9zIDw9IGZyb20gPyAxIC8qIE9wZW4uRnJvbSAqLyA6IDApIHwgKGVuZCA+PSB0byA/IDIgLyogT3Blbi5UbyAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC5zbGljZVN0cmluZyhmcm9tIC0gcG9zLCB0byAtIHBvcywgbGluZVNlcCk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5mbGF0dGVuKHRhcmdldCk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwob3RoZXIsIGRpcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFRleHROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IFtpQSwgaUIsIGVBLCBlQl0gPSBkaXIgPiAwID8gWzAsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBvdGhlci5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XG4gICAgICAgIGZvciAoOzsgaUEgKz0gZGlyLCBpQiArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChpQSA9PSBlQSB8fCBpQiA9PSBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoQSA9IHRoaXMuY2hpbGRyZW5baUFdLCBjaEIgPSBvdGhlci5jaGlsZHJlbltpQl07XG4gICAgICAgICAgICBpZiAoY2hBICE9IGNoQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoQS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNoaWxkcmVuLCBsZW5ndGggPSBjaGlsZHJlbi5yZWR1Y2UoKGwsIGNoKSA9PiBsICsgY2gubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgbGluZXMgKz0gY2gubGluZXM7XG4gICAgICAgIGlmIChsaW5lcyA8IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBUcmVlLkJyYW5jaCAqLywgbGluZXMgPj4gNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovKSwgbWF4Q2h1bmsgPSBjaHVuayA8PCAxLCBtaW5DaHVuayA9IGNodW5rID4+IDE7XG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubGluZXMgPiBtaW5DaHVuayAmJiAoY3VycmVudExpbmVzID4gbWluQ2h1bmsgfHwgIWN1cnJlbnRMaW5lcykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHRMZWFmICYmIGN1cnJlbnRMaW5lcyAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmxpbmVzICsgbGFzdC5saW5lcyA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQubGluZUF0KS5cbiovXG5jbGFzcyBMaW5lIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAoX2JlZm9yZV8gdGhlIGxpbmUgYnJlYWssXG4gICAgb3IgYXQgdGhlIGVuZCBvZiBkb2N1bWVudCBmb3IgdGhlIGxhc3QgbGluZSkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxuICAgICovXG4gICAgbnVtYmVyLCBcbiAgICAvKipcbiAgICBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGxpbmUgKG5vdCBpbmNsdWRpbmcgYW55IGxpbmUgYnJlYWsgYWZ0ZXIgaXQpLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cblxuLy8gQ29tcHJlc3NlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgR3JhcGhlbWVfQ2x1c3Rlcl9CcmVhaz1FeHRlbmRcbi8vIGluZm9ybWF0aW9uIGZyb21cbi8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHQuXG4vLyBFYWNoIHBhaXIgb2YgZWxlbWVudHMgcmVwcmVzZW50cyBhIHJhbmdlLCBhcyBhbiBvZmZldCBmcm9tIHRoZVxuLy8gcHJldmlvdXMgcmFuZ2UgYW5kIGEgbGVuZ3RoLiBOdW1iZXJzIGFyZSBpbiBiYXNlLTM2LCB3aXRoIHRoZSBlbXB0eVxuLy8gc3RyaW5nIGJlaW5nIGEgc2hvcnRoYW5kIGZvciAxLlxubGV0IGV4dGVuZCA9IC8qQF9fUFVSRV9fKi9cImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XG4vLyBDb252ZXJ0IG9mZnNldHMgaW50byBhYnNvbHV0ZSB2YWx1ZXNcbmZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSsrKVxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xuZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kW2kgLSAxXSA8PSBjb2RlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4MUYxRTYgJiYgY29kZSA8PSAweDFGMUZGO1xufVxuY29uc3QgWldKID0gMHgyMDBkO1xuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIChmb3J3YXJkID8gbmV4dENsdXN0ZXJCcmVhayA6IHByZXZDbHVzdGVyQnJlYWspKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICBpZiAocG9zID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgLy8gSWYgcG9zIGlzIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpciwgbW92ZSB0byBpdHMgc3RhcnRcbiAgICBpZiAocG9zICYmIHN1cnJvZ2F0ZUxvdyhzdHIuY2hhckNvZGVBdChwb3MpKSAmJiBzdXJyb2dhdGVIaWdoKHN0ci5jaGFyQ29kZUF0KHBvcyAtIDEpKSlcbiAgICAgICAgcG9zLS07XG4gICAgbGV0IHByZXYgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgcG9zICs9IGNvZGVQb2ludFNpemUocHJldik7XG4gICAgd2hpbGUgKHBvcyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChwcmV2ID09IFpXSiB8fCBuZXh0ID09IFpXSiB8fCBpbmNsdWRlRXh0ZW5kaW5nICYmIGlzRXh0ZW5kaW5nQ2hhcihuZXh0KSkge1xuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XG4gICAgICAgICAgICBsZXQgY291bnRCZWZvcmUgPSAwLCBpID0gcG9zIC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMiwgaW5jbHVkZUV4dGVuZGluZyk7XG4gICAgICAgIGlmIChmb3VuZCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgcG9zLS07XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLyoqXG5GaW5kIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHN0cmluZyAobGlrZSB0aGVcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG5zdHJpbmcgbWV0aG9kKS5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vKipcbkdpdmVuIGEgVW5pY29kZSBjb2RlcG9pbnQsIHJldHVybiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcgdGhhdFxucmVzcHJlc2VudHMgaXQgKGxpa2VcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxuKi9cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyOyB9XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xudmFyIE1hcE1vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG5yZXR1cm4gTWFwTW9kZX0pKE1hcE1vZGUgfHwgKE1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuIGBwb3NBYFxuICAgIHByb3ZpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmFuZ2UgaW4gdGhlIG9sZCBkb2N1bWVudCwgYHBvc0JgXG4gICAgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgY2hhbmdlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGl0ZXJHYXBzKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBmKHBvc0EsIHBvc0IsIGxlbik7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGNoYW5nZWQgYnkgdGhlc2UgY2hhbmdlcy4gKFNlZVxuICAgIFtgQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQuaXRlckNoYW5nZXMpIGZvciBhXG4gICAgdmFyaWFudCB0aGF0IGFsc28gcHJvdmlkZXMgeW91IHdpdGggdGhlIGluc2VydGVkIHRleHQuKVxuICAgIGBmcm9tQWAvYHRvQWAgcHJvdmlkZXMgdGhlIGV4dGVudCBvZiB0aGUgY2hhbmdlIGluIHRoZSBzdGFydGluZ1xuICAgIGRvY3VtZW50LCBgZnJvbUJgL2B0b0JgIHRoZSBleHRlbnQgb2YgdGhlIHJlcGxhY2VtZW50IGluIHRoZVxuICAgIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyAod2hpY2ggYXJlIGtlcHRcbiAgICBzZXBhcmF0ZSBmb3IgW3Bvc2l0aW9uIG1hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy5tYXBQb3MpKSBhcmVcbiAgICByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZWRSYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW52ZXJ0ZWQgZm9ybSBvZiB0aGVzZSBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IGludmVydGVkRGVzYygpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGlucywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xuICAgIGFmdGVyIHRoaXMgb25lLiBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGlzIHNldCBzaG91bGRcbiAgICBtYXRjaCB0aGUgbGVuZ3RoIGJlZm9yZSBgb3RoZXJgLlxuICAgICovXG4gICAgY29tcG9zZURlc2Mob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyKTsgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGRlc2NyaXB0aW9uLCB3aGljaCBzaG91bGQgc3RhcnQgd2l0aCB0aGUgc2FtZSBkb2N1bWVudFxuICAgIGFzIGBvdGhlcmAsIG92ZXIgYW5vdGhlciBzZXQgb2YgY2hhbmdlcywgc28gdGhhdCBpdCBjYW4gYmVcbiAgICBhcHBsaWVkIGFmdGVyIGl0LiBXaGVuIGBiZWZvcmVgIGlzIHRydWUsIG1hcCBhcyBpZiB0aGUgY2hhbmdlc1xuICAgIGluIGBvdGhlcmAgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGB0aGlzYC5cbiAgICAqL1xuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSk7IH1cbiAgICBtYXBQb3MocG9zLCBhc3NvYyA9IC0xLCBtb2RlID0gTWFwTW9kZS5TaW1wbGUpIHtcbiAgICAgICAgbGV0IHBvc0EgPSAwLCBwb3NCID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kQSA9IHBvc0EgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQiArIChwb3MgLSBwb3NBKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9IE1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IE1hcE1vZGUuVHJhY2tEZWwgJiYgcG9zQSA8IHBvcyAmJiBlbmRBID4gcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tCZWZvcmUgJiYgcG9zQSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChsZW4gPyBkb2Muc2xpY2UocG9zLCBwb3MgKyBsZW4pIDogVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXG4gICAgYGRvY0FgIFx1MjE5MiBgZG9jQmAgYW5kIGBvdGhlcmAgcmVwcmVzZW50cyBgZG9jQmAgXHUyMTkyIGBkb2NDYCwgdGhlXG4gICAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAgXHUyMTkyIGBkb2NDYC5cbiAgICAqL1xuICAgIGNvbXBvc2Uob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gICAgY2hhbmdlIHNldCBvdmVyIHRoZSBvdGhlciwgcHJvZHVjaW5nIGEgbmV3IGNoYW5nZSBzZXQgdGhhdCBjYW4gYmVcbiAgICBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBhcHBseWluZyBgb3RoZXJgLiBXaGVuXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgICBgb3RoZXJgLCBvdGhlcndpc2UgKHRoZSBkZWZhdWx0KSB0cmVhdCBgb3RoZXJgIGFzIGNvbWluZyBmaXJzdC5cbiAgICBcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICAgIGBCLmNvbXBvc2UoQS5tYXAoQiwgdHJ1ZSkpYCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgZG9jdW1lbnQuIFRoaXNcbiAgICBwcm92aWRlcyBhIGJhc2ljIGZvcm0gb2YgW29wZXJhdGlvbmFsXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgICBhbmQgY2FuIGJlIHVzZWQgZm9yIGNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiAgICAqL1xuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXG4gICAgYW5kIHRoZSByYW5nZSB0aGF0IHJlcGxhY2VzIGl0IGluIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAoYGZyb21CYC1gdG9CYCkuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gQ2hhbmdlRGVzYy5jcmVhdGUodGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogQ2hhbmdlRGVzYy5jcmVhdGUoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcbiAgICBpZiAobGVuID09IDAgJiYgaW5zIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBpbnMgPD0gMCAmJiBpbnMgPT0gc2VjdGlvbnNbbGFzdCArIDFdKVxuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgZWxzZSBpZiAobGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2VcdTIwMTR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDMgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSAzID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvciA9PSBvdGhlci5hbmNob3IgJiYgdGhpcy5oZWFkID09IG90aGVyLmhlYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcbiAgICB5b3VyIGNvZGUgYXBwbGllcyB0byBfYWxsXyByYW5nZXMsIGJ5IHVzaW5nIG1ldGhvZHMgbGlrZVxuICAgIFtgY2hhbmdlQnlSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhbmdlQnlSYW5nZSkuXG4gICAgKi9cbiAgICBnZXQgbWFpbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMubWFpbkluZGV4XTsgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgc2VsZWN0aW9uIG9ubHkgaGFzIG9uZSByYW5nZS4gUmV0dXJucyBhIHNlbGVjdGlvblxuICAgIGhvbGRpbmcgb25seSB0aGUgbWFpbiByYW5nZSBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAgICovXG4gICAgYXNTaW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5sZW5ndGggPT0gMSA/IHRoaXMgOiBuZXcgRWRpdG9yU2VsZWN0aW9uKFt0aGlzLm1haW5dLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgc2VsZWN0aW9uIHdpdGggYW4gZXh0cmEgcmFuZ2UuXG4gICAgKi9cbiAgICBhZGRSYW5nZShyYW5nZSwgbWFpbiA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXS5jb25jYXQodGhpcy5yYW5nZXMpLCBtYWluID8gMCA6IHRoaXMubWFpbkluZGV4ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGFub3RoZXIgcmFuZ2UsIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aGVcbiAgICBzZWxlY3Rpb24gdG8gbWVyZ2UgYW5kIHNvcnQgcmFuZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShyYW5nZSwgd2hpY2ggPSB0aGlzLm1haW5JbmRleCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VzW3doaWNoXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHNlbGVjdGlvbiB0byBhbiBvYmplY3QgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCB0b1xuICAgIEpTT04uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlczogdGhpcy5yYW5nZXMubWFwKHIgPT4gci50b0pTT04oKSksIG1haW46IHRoaXMubWFpbkluZGV4IH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhQXJyYXkuaXNBcnJheShqc29uLnJhbmdlcykgfHwgdHlwZW9mIGpzb24ubWFpbiAhPSBcIm51bWJlclwiIHx8IGpzb24ubWFpbiA+PSBqc29uLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihqc29uLnJhbmdlcy5tYXAoKHIpID0+IFNlbGVjdGlvblJhbmdlLmZyb21KU09OKHIpKSwganNvbi5tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGhvbGRpbmcgYSBzaW5nbGUgcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2luZ2xlKGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihbRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvciwgaGVhZCldLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU29ydCBhbmQgbWVyZ2UgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMsIGNyZWF0aW5nIGEgdmFsaWRcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHNlbGVjdGlvbiBuZWVkcyBhdCBsZWFzdCBvbmUgcmFuZ2VcIik7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHBvcyA6IHJhbmdlLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5ub3JtYWxpemVkKHJhbmdlcy5zbGljZSgpLCBtYWluSW5kZXgpO1xuICAgICAgICAgICAgcG9zID0gcmFuZ2UudG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3Igc2VsZWN0aW9uIHJhbmdlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gWW91IGNhblxuICAgIHNhZmVseSBpZ25vcmUgdGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3Vyc29yKHBvcywgYXNzb2MgPSAwLCBiaWRpTGV2ZWwsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvblJhbmdlLmNyZWF0ZShwb3MsIHBvcywgKGFzc29jID09IDAgPyAwIDogYXNzb2MgPCAwID8gNCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiA4IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgbGV0IGdvYWwgPSAoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLztcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCBnb2FsIHwgOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLylcbiAgICAgICAgICAgIDogU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGFuY2hvciwgaGVhZCwgZ29hbCB8IChoZWFkID4gYW5jaG9yID8gNCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0ci5uZXdEb2MsIHRyLm5ld1NlbGVjdGlvbiwgc3RhcnRWYWx1ZXMsIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC51cGRhdGUoc3RhdGUsIHRyKSwgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIHRvVGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3JcdTIwMTR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIFRleHQgPyBjb25maWcuZG9jXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICFjb25maWcuc2VsZWN0aW9uID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSgwKVxuICAgICAgICAgICAgOiBjb25maWcuc2VsZWN0aW9uIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gY29uZmlnLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcbiAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2MubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKGNvbmZpZ3VyYXRpb24sIGRvYywgc2VsZWN0aW9uLCBjb25maWd1cmF0aW9uLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5jcmVhdGUoc3RhdGUpLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgKGluIGNvbHVtbnMpIG9mIGEgdGFiIGluIHRoZSBkb2N1bWVudCwgZGV0ZXJtaW5lZCBieVxuICAgIHRoZSBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIGZhY2V0LlxuICAgICovXG4gICAgZ2V0IHRhYlNpemUoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnRhYlNpemUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcbiAgICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXG4gICAgKi9cbiAgICBnZXQgcmVhZE9ubHkoKSB7IHJldHVybiB0aGlzLmZhY2V0KHJlYWRPbmx5KTsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgIFxuICAgIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwYXNzZWQsIHRoZXkgd2lsbCBiZSBpbnNlcnRlZCBpblxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICAgIEEgc2luZ2xlIGAkYCBpcyBlcXVpdmFsZW50IHRvIGAkMWAsIGFuZCBgJCRgIHdpbGwgcHJvZHVjZSBhXG4gICAgbGl0ZXJhbCBkb2xsYXIgc2lnbi5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UsIC4uLmluc2VydCkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlID0gbWFwW3BocmFzZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgcGhyYXNlID0gcGhyYXNlLnJlcGxhY2UoL1xcJChcXCR8XFxkKikvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIGxldCBuID0gKyhpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgXG4gICAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gICAgXG4gICAgLSBbYFwiY29tbWVudFRva2Vuc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBmb3Igc3BlY2lmeWluZ1xuICAgICAgY29tbWVudCBzeW50YXguXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXG4gICAgICBmb3IgcHJvdmlkaW5nIGxhbmd1YWdlLXNwZWNpZmljIGNvbXBsZXRpb24gc291cmNlcy5cbiAgICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXG4gICAgICBsYW5ndWFnZS5cbiAgICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKSlcbiAgICBpbnRvIG9uZSBvZjpcbiAgICBcbiAgICAgLSBXb3JkIChjb250YWlucyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIG9yIGEgY2hhcmFjdGVyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgICAgbGFuZ3VhZ2UgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nKVxuICAgICAtIFNwYWNlIChjb250YWlucyBvbmx5IHdoaXRlc3BhY2UpXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICAgKi9cbiAgICBjaGFyQ2F0ZWdvcml6ZXIoYXQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYXRlZ29yaXplcih0aGlzLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGF0KS5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXG4gICAgY29udGFpbmluZyBhbGwgW3dvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIGNoYXJhY3RlcnNcbiAgICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICovXG4gICAgd29yZEF0KHBvcykge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY2F0ID0gdGhpcy5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gZnJvbSwgZW5kID0gcG9zIC0gZnJvbTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UocHJldiwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShlbmQsIG5leHQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxufSk7XG4vKipcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxuYW5kIGBcIlxcclwiYCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdG9yIHdoZW4gc3BsaXR0aW5nIGxpbmVzLCBhbmRcbmxpbmVzIGFyZSBqb2luZWQgd2l0aCBgXCJcXG5cImAuXG5cbldoZW4geW91IGNvbmZpZ3VyZSBhIHZhbHVlIGhlcmUsIG9ubHkgdGhhdCBwcmVjaXNlIHNlcGFyYXRvclxud2lsbCBiZSB1c2VkLCBhbGxvd2luZyB5b3UgdG8gcm91bmQtdHJpcCBkb2N1bWVudHMgdGhyb3VnaCB0aGVcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cbiovXG5FZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yID0gbGluZVNlcGFyYXRvcjtcbi8qKlxuVGhpcyBmYWNldCBjb250cm9scyB0aGUgdmFsdWUgb2YgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZ2V0dGVyLCB3aGljaCBpc1xuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcbmZ1bmN0aW9uYWxpdHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBzaG91bGQgYXBwbHkuIEl0XG5kZWZhdWx0cyB0byBmYWxzZSwgYnV0IHdoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpc1xuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxuXG5Ob3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxuY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yJ3MgRE9NIGlzIHNldCB0byBiZSBlZGl0YWJsZSAoYW5kXG50aHVzIGZvY3VzYWJsZSkuXG4qL1xuRWRpdG9yU3RhdGUucmVhZE9ubHkgPSByZWFkT25seTtcbi8qKlxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxuW2BwaHJhc2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnBocmFzZSkgbWV0aG9kIHdpbGwgbG9vayB0aHJvdWdoXG5hbGwgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGggdGhpcyBmYWNldCB0byBmaW5kIHRyYW5zbGF0aW9ucyBmb3Jcbml0cyBhcmd1bWVudC5cbiovXG5FZGl0b3JTdGF0ZS5waHJhc2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGxldCBrQSA9IE9iamVjdC5rZXlzKGEpLCBrQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga0EubGVuZ3RoID09IGtCLmxlbmd0aCAmJiBrQS5ldmVyeShrID0+IGFba10gPT0gYltrXSk7XG4gICAgfVxufSk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxudHJhbnNhY3Rpb24pLCBvciBhbiBhcnJheSBvZiBzcGVjcyAod2hpY2ggd2lsbCBiZSBjb21iaW5lZCBpblxudGhlIHNhbWUgd2F5IGFzIHRoZSBhcmd1bWVudHMgdG9cbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgcHJlc2VudC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tEZWw7XG4vKipcbkEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgSXRzIGVuZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFuZ2UuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIHRydWUpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIGZhbHNlLCBpKTsgaSA8IGU7IGkrKylcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBbXSwgZnJvbSA9IFtdLCB0byA9IFtdLCBuZXdQb3MgPSAtMSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcbiAgICAgICAgICAgIGlmIChjdXJGcm9tID09IGN1clRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUsIHZhbC5tYXBNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvIDwgbmV3RnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1clRvLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmV3UG9zIDwgMClcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xuICAgICAgICAgICAgaWYgKHZhbC5wb2ludClcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBuZXdUbyAtIG5ld0Zyb20pO1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICAgICAgZnJvbS5wdXNoKG5ld0Zyb20gLSBuZXdQb3MpO1xuICAgICAgICAgICAgdG8ucHVzaChuZXdUbyAtIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGVkOiB2YWx1ZS5sZW5ndGggPyBuZXcgQ2h1bmsoZnJvbSwgdG8sIHZhbHVlLCBtYXhQb2ludCkgOiBudWxsLCBwb3M6IG5ld1BvcyB9O1xuICAgIH1cbn1cbi8qKlxuQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBpbiBhXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXG5bdXBkYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0LnVwZGF0ZSkuIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGRhdGFcbnN0cnVjdHVyZS5cbiovXG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua1BvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVuaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0TGF5ZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFzdCA8IDAgPyAwIDogTWF0aC5tYXgodGhpcy5jaHVua0VuZChsYXN0KSwgdGhpcy5uZXh0TGF5ZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5uZXh0TGF5ZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY2h1bmsgb2YgdGhpcy5jaHVuaylcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua0VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc1tpbmRleF0gKyB0aGlzLmNodW5rW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgcmFuZ2Ugc2V0LCBvcHRpb25hbGx5IGFkZGluZyBuZXcgcmFuZ2VzIG9yIGZpbHRlcmluZ1xuICAgIG91dCBleGlzdGluZyBvbmVzLlxuICAgIFxuICAgIChOb3RlOiBUaGUgdHlwZSBwYXJhbWV0ZXIgaXMganVzdCB0aGVyZSBhcyBhIGtsdWRnZSB0byB3b3JrXG4gICAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIGBZYC4pXG4gICAgKi9cbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xuICAgICAgICBsZXQgeyBhZGQgPSBbXSwgc29ydCA9IGZhbHNlLCBmaWx0ZXJGcm9tID0gMCwgZmlsdGVyVG8gPSB0aGlzLmxlbmd0aCB9ID0gdXBkYXRlU3BlYztcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwZGF0ZVNwZWMuZmlsdGVyO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2goUmFuZ2UuY3JlYXRlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIXNwaWxsLmxlbmd0aCA/IFJhbmdlU2V0LmVtcHR5XG4gICAgICAgICAgICA6IHRoaXMubmV4dExheWVyLnVwZGF0ZSh7IGFkZDogc3BpbGwsIGZpbHRlciwgZmlsdGVyRnJvbSwgZmlsdGVyVG8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdLCBjaHVua1BvcyA9IFtdLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0LCBzdGFydCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodG91Y2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKGNoYW5nZXMubWFwUG9zKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hcHBlZCwgcG9zIH0gPSBjaHVuay5tYXAoc3RhcnQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbWFwcGVkLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dExheWVyLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcy5sZW5ndGggPT0gMCA/IG5leHQgOiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rcywgbmV4dCB8fCBSYW5nZVNldC5lbXB0eSwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyB0aGF0IHRvdWNoIHRoZSByZWdpb24gYGZyb21gIHRvIGB0b2AsXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIGJlIHJlcG9ydGVkIGluIGFueSBzcGVjaWZpYyBvcmRlci4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGBmYWxzZWAsIGl0ZXJhdGlvbiBzdG9wcy5cbiAgICAqL1xuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNodW5rLmJldHdlZW4oc3RhcnQsIGZyb20gLSBzdGFydCwgdG8gLSBzdGFydCwgZikgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMYXllci5iZXR3ZWVuKGZyb20sIHRvLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gdGhpcyBzZXQsIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIGl0ZXIoZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShbdGhpc10pLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICovXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShzZXRzKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUob2xkU2V0cywgbmV3U2V0cywgXG4gICAgLyoqXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgcmFuZ2VzLCBhbmQgaXMgbmVlZGVkIHRvIHN5bmNocm9uaXplIHRoZSBpdGVyYXRpb24uIGBmcm9tYCBhbmRcbiAgICBgdG9gIGFyZSBjb29yZGluYXRlcyBpbiB0aGUgX25ld18gc3BhY2UsIGFmdGVyIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XG4gICAgdGhlIGdpdmVuIHNpemUuIFdoZW4gLTEsIGFsbCByYW5nZXMgYXJlIGNvbXBhcmVkLlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xuICAgICAgICBpZiAodGV4dERpZmYuZW1wdHkgJiYgdGV4dERpZmYubGVuZ3RoID09IDApXG4gICAgICAgICAgICBjb21wYXJlKHNpZGVBLCAwLCBzaWRlQiwgMCwgMCwgY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBlcShvbGRTZXRzLCBuZXdTZXRzLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi8gLSAxO1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgbmV3U2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvICE9IHNpZGVCLnRvIHx8XG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgc2lkZUEucG9pbnQgJiYgKCFzaWRlQi5wb2ludCB8fCAhc2lkZUEucG9pbnQuZXEoc2lkZUIucG9pbnQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpZGVBLm5leHQoKTtcbiAgICAgICAgICAgIHNpZGVCLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSBncm91cCBvZiByYW5nZSBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIG5vdGlmeWluZ1xuICAgIHRoZSBpdGVyYXRvciBhYm91dCB0aGUgcmFuZ2VzIGNvdmVyaW5nIGV2ZXJ5IGdpdmVuIHBpZWNlIG9mXG4gICAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXG4gICAgW2BTcGFuSXRlcmF0b3Iuc3BhbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3Bhbkl0ZXJhdG9yLnNwYW4pKSBhdCB0aGUgZW5kXG4gICAgb2YgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBzcGFucyhzZXRzLCBmcm9tLCB0bywgaXRlcmF0b3IsIFxuICAgIC8qKlxuICAgIFdoZW4gZ2l2ZW4gYW5kIGdyZWF0ZXIgdGhhbiAtMSwgb25seSBwb2ludHMgb2YgYXQgbGVhc3QgdGhpc1xuICAgIHNpemUgYXJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU3BhbkN1cnNvcihzZXRzLCBudWxsLCBtaW5Qb2ludFNpemUpLmdvdG8oZnJvbSksIHBvcyA9IGZyb207XG4gICAgICAgIGxldCBvcGVuID0gY3Vyc29yLm9wZW5TdGFydDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGN1clRvID0gTWF0aC5taW4oY3Vyc29yLnRvLCB0byk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKSwgb3BlbiwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGN1cnNvci5vcGVuRW5kKGN1clRvKSArIChjdXJzb3IudG8gPiBjdXJUbyA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBvcGVuID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGJ1aWxkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XG4gICAgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jdXJzb3IuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCA9IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICB0aGlzLnRvID0gcG9zO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1pbkFjdGl2ZSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW3RoaXMubWluQWN0aXZlXSAtIHBvcyB8fCB0aGlzLmFjdGl2ZVt0aGlzLm1pbkFjdGl2ZV0uZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKHRoaXMubWluQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmUoaW5kZXgpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVRvLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVJhbmssIGluZGV4KTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICBhZGRBY3RpdmUodHJhY2tPcGVuKSB7XG4gICAgICAgIGxldCBpID0gMCwgeyB2YWx1ZSwgdG8sIHJhbmsgfSA9IHRoaXMuY3Vyc29yO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgdGhpcy5hY3RpdmVSYW5rW2ldIDw9IHJhbmspXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVUbywgaSwgdG8pO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVSYW5rLCBpLCByYW5rKTtcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgIGluc2VydCh0cmFja09wZW4sIGksIHRoaXMuY3Vyc29yLmZyb20pO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgICAvLyBwb2ludC4gT3RoZXJ3aXNlLCBpdCdzIGEgcmVndWxhciByYW5nZSwgY292ZXJlZCBieSBgdGhpcy5hY3RpdmVgLlxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy50bywgd2FzUG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbCwgdHJhY2tFeHRyYSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XG4gICAgICAgICAgICBpZiAoYSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW2FdIC0gdGhpcy5jdXJzb3IuZnJvbSB8fCB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlIC0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1thXSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShhKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnNvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yLmZyb20gPCBmcm9tICYmIHRoaXMuY3Vyc29yLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRXh0cmErKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvci5mcm9tIDwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRXh0cmEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAob3BlblN0YXJ0IDwgdHJhY2tPcGVuLmxlbmd0aCAmJiB0cmFja09wZW5bb3BlblN0YXJ0XSA8IGZyb20pXG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydCArIHRyYWNrRXh0cmE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRpZmYgPSAoYS50byArIGRQb3MpIC0gYi50byB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8gKyBkUG9zKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpcEVuZCA+IHBvcyAmJiAhc2FtZVZhbHVlcyhhLmFjdGl2ZSwgYi5hY3RpdmUpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVJhbmdlKHBvcywgY2xpcEVuZCwgYS5hY3RpdmUsIGIuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gZW5kQilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIGlmIChkaWZmIDw9IDApXG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVWYWx1ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSAmJiAhYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXgsIGUgPSBhcnJheS5sZW5ndGggLSAxOyBpIDwgZTsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcbiAgICBhcnJheS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcbiAgICAgICAgYXJyYXlbaSArIDFdID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kTWluSW5kZXgodmFsdWUsIGFycmF5KSB7XG4gICAgbGV0IGZvdW5kID0gLTEsIGZvdW5kUG9zID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcbnRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuKi9cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG87KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXG5zdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LiBCeVxuZGVmYXVsdCwgdGhlIHN0cmluZyBsZW5ndGggaXMgcmV0dXJuZWQgd2hlbiBpdCBpcyB0b28gc2hvcnQgdG9cbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XG5zaXR1YXRpb24uXG4qL1xuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSAwOzspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIGlmIChpID09IHN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xuICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSwgQ2hhbmdlRGVzYywgQ2hhbmdlU2V0LCBDaGFyQ2F0ZWdvcnksIENvbXBhcnRtZW50LCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBGYWNldCwgTGluZSwgTWFwTW9kZSwgUHJlYywgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUsIFNlbGVjdGlvblJhbmdlLCBTdGF0ZUVmZmVjdCwgU3RhdGVFZmZlY3RUeXBlLCBTdGF0ZUZpZWxkLCBUZXh0LCBUcmFuc2FjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIGNvdW50Q29sdW1uLCBmaW5kQ2x1c3RlckJyZWFrLCBmaW5kQ29sdW1uLCBmcm9tQ29kZVBvaW50IH07XG4iLCAiY29uc3QgQyA9IFwiXFx1MDM3Y1wiXG5jb25zdCBDT1VOVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19cIiArIEMgOiBTeW1ib2wuZm9yKEMpXG5jb25zdCBTRVQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fc3R5bGVTZXRcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkgOiBTeW1ib2woXCJzdHlsZVNldFwiKVxuY29uc3QgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxuXG4vLyA6OiAtIFN0eWxlIG1vZHVsZXMgZW5jYXBzdWxhdGUgYSBzZXQgb2YgQ1NTIHJ1bGVzIGRlZmluZWQgZnJvbVxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXG4vLyByb290IGFmdGVyIGl0IGhhcyBiZWVuIF9tb3VudGVkXyB0aGVyZSB3aXRoIGBTdHlsZU1vZHVsZS5tb3VudGAuXG4vL1xuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xuLy8gb3Bwb3NlZCB0byByZS1jcmVhdGluZyB0aGVtIGV2ZXJ5IHRpbWUgeW91IG5lZWQgdGhlbS4gVGhlIGFtb3VudCBvZlxuLy8gQ1NTIHJ1bGVzIGdlbmVyYXRlZCBmb3IgYSBnaXZlbiBET00gcm9vdCBpcyBib3VuZGVkIGJ5IHRoZSBhbW91bnRcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XG4vLyBjcmVhdGUgdGhlc2UgZHluYW1pY2FsbHksIGJ1dCB0cmVhdCB0aGVtIGFzIG9uZS10aW1lIGFsbG9jYXRpb25zLlxuZXhwb3J0IGNsYXNzIFN0eWxlTW9kdWxlIHtcbiAgLy8gOjogKE9iamVjdDxTdHlsZT4sID97ZmluaXNoOiA/KHN0cmluZykgXHUyMTkyIHN0cmluZ30pXG4gIC8vIENyZWF0ZSBhIHN0eWxlIG1vZHVsZSBmcm9tIHRoZSBnaXZlbiBzcGVjLlxuICAvL1xuICAvLyBXaGVuIGBmaW5pc2hgIGlzIGdpdmVuLCBpdCBpcyBjYWxsZWQgb24gcmVndWxhciAobm9uLWBAYClcbiAgLy8gc2VsZWN0b3JzIChhZnRlciBgJmAgZXhwYW5zaW9uKSB0byBjb21wdXRlIHRoZSBmaW5hbCBzZWxlY3Rvci5cbiAgY29uc3RydWN0b3Ioc3BlYywgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMgPSBbXVxuICAgIGxldCB7ZmluaXNofSA9IG9wdGlvbnMgfHwge31cblxuICAgIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAvXkAvLnRlc3Qoc2VsZWN0b3IpID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yLnNwbGl0KC8sXFxzKi8pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKHNlbGVjdG9ycywgc3BlYywgdGFyZ2V0LCBpc0tleWZyYW1lcykge1xuICAgICAgbGV0IGxvY2FsID0gW10sIGlzQXQgPSAvXkAoXFx3KylcXGIvLmV4ZWMoc2VsZWN0b3JzWzBdKSwga2V5ZnJhbWVzID0gaXNBdCAmJiBpc0F0WzFdID09IFwia2V5ZnJhbWVzXCJcbiAgICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgcmV0dXJuIHRhcmdldC5wdXNoKHNlbGVjdG9yc1swXSArIFwiO1wiKVxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNwZWNbcHJvcF1cbiAgICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgcmVuZGVyKHByb3Auc3BsaXQoLyxcXHMqLykubWFwKHBhcnQgPT4gc2VsZWN0b3JzLm1hcChzZWwgPT4gcGFydC5yZXBsYWNlKC8mLywgc2VsKSkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpLFxuICAgICAgICAgICAgICAgICB2YWx1ZSwgdGFyZ2V0KVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKCFpc0F0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IChcIiArIHByb3AgKyBcIikgc2hvdWxkIGJlIGEgcHJpbWl0aXZlIHZhbHVlLlwiKVxuICAgICAgICAgIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCB2YWx1ZSwgbG9jYWwsIGtleWZyYW1lcylcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbG9jYWwucHVzaChwcm9wLnJlcGxhY2UoL18uKi8sIFwiXCIpLnJlcGxhY2UoL1tBLVpdL2csIGwgPT4gXCItXCIgKyBsLnRvTG93ZXJDYXNlKCkpICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvY2FsLmxlbmd0aCB8fCBrZXlmcmFtZXMpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goKGZpbmlzaCAmJiAhaXNBdCAmJiAhaXNLZXlmcmFtZXMgPyBzZWxlY3RvcnMubWFwKGZpbmlzaCkgOiBzZWxlY3RvcnMpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHtcIiArIGxvY2FsLmpvaW4oXCIgXCIpICsgXCJ9XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgc3BlY1twcm9wXSwgdGhpcy5ydWxlcylcbiAgfVxuXG4gIC8vIDo6ICgpIFx1MjE5MiBzdHJpbmdcbiAgLy8gUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtb2R1bGUncyBDU1MgcnVsZXMuXG4gIGdldFJ1bGVzKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH1cblxuICAvLyA6OiAoKSBcdTIxOTIgc3RyaW5nXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cbiAgc3RhdGljIG5ld05hbWUoKSB7XG4gICAgbGV0IGlkID0gdG9wW0NPVU5UXSB8fCAxXG4gICAgdG9wW0NPVU5UXSA9IGlkICsgMVxuICAgIHJldHVybiBDICsgaWQudG9TdHJpbmcoMzYpXG4gIH1cblxuICAvLyA6OiAodW5pb248RG9jdW1lbnQsIFNoYWRvd1Jvb3Q+LCB1bmlvbjxbU3R5bGVNb2R1bGVdLCBTdHlsZU1vZHVsZT4pXG4gIC8vXG4gIC8vIE1vdW50IHRoZSBnaXZlbiBzZXQgb2YgbW9kdWxlcyBpbiB0aGUgZ2l2ZW4gRE9NIHJvb3QsIHdoaWNoIGVuc3VyZXNcbiAgLy8gdGhhdCB0aGUgQ1NTIHJ1bGVzIGRlZmluZWQgYnkgdGhlIG1vZHVsZSBhcmUgYXZhaWxhYmxlIGluIHRoYXRcbiAgLy8gY29udGV4dC5cbiAgLy9cbiAgLy8gUnVsZXMgYXJlIG9ubHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50IG9uY2UgcGVyIHJvb3QuXG4gIC8vXG4gIC8vIFJ1bGUgb3JkZXIgd2lsbCBmb2xsb3cgdGhlIG9yZGVyIG9mIHRoZSBtb2R1bGVzLCBzbyB0aGF0IHJ1bGVzIGZyb21cbiAgLy8gbW9kdWxlcyBsYXRlciBpbiB0aGUgYXJyYXkgdGFrZSBwcmVjZWRlbmNlIG9mIHRob3NlIGZyb20gZWFybGllclxuICAvLyBtb2R1bGVzLiBJZiB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZSByb290XG4gIC8vIGluIGEgd2F5IHRoYXQgY2hhbmdlcyB0aGUgb3JkZXIgb2YgYWxyZWFkeSBtb3VudGVkIG1vZHVsZXMsIHRoZSBvbGRcbiAgLy8gb3JkZXIgd2lsbCBiZSBjaGFuZ2VkLlxuICBzdGF0aWMgbW91bnQocm9vdCwgbW9kdWxlcykge1xuICAgIChyb290W1NFVF0gfHwgbmV3IFN0eWxlU2V0KHJvb3QpKS5tb3VudChBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXSlcbiAgfVxufVxuXG5sZXQgYWRvcHRlZFNldCA9IG51bGxcblxuY2xhc3MgU3R5bGVTZXQge1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgdHlwZW9mIENTU1N0eWxlU2hlZXQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGFkb3B0ZWRTZXQpIHtcbiAgICAgICAgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbYWRvcHRlZFNldC5zaGVldF0uY29uY2F0KHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzKVxuICAgICAgICByZXR1cm4gcm9vdFtTRVRdID0gYWRvcHRlZFNldFxuICAgICAgfVxuICAgICAgdGhpcy5zaGVldCA9IG5ldyBDU1NTdHlsZVNoZWV0XG4gICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFt0aGlzLnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgICBhZG9wdGVkU2V0ID0gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlVGFnID0gKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290KS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIilcbiAgICAgIGxldCB0YXJnZXQgPSByb290LmhlYWQgfHwgcm9vdFxuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLnN0eWxlVGFnLCB0YXJnZXQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVzID0gW11cbiAgICByb290W1NFVF0gPSB0aGlzXG4gIH1cblxuICBtb3VudChtb2R1bGVzKSB7XG4gICAgbGV0IHNoZWV0ID0gdGhpcy5zaGVldFxuICAgIGxldCBwb3MgPSAwIC8qIEN1cnJlbnQgcnVsZSBvZmZzZXQgKi8sIGogPSAwIC8qIEluZGV4IGludG8gdGhpcy5tb2R1bGVzICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbW9kID0gbW9kdWxlc1tpXSwgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihtb2QpXG4gICAgICBpZiAoaW5kZXggPCBqICYmIGluZGV4ID4gLTEpIHsgLy8gT3JkZXJpbmcgY29uZmxpY3RcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgai0tXG4gICAgICAgIGluZGV4ID0gLTFcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGorKywgMCwgbW9kKVxuICAgICAgICBpZiAoc2hlZXQpIGZvciAobGV0IGsgPSAwOyBrIDwgbW9kLnJ1bGVzLmxlbmd0aDsgaysrKVxuICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUobW9kLnJ1bGVzW2tdLCBwb3MrKylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChqIDwgaW5kZXgpIHBvcyArPSB0aGlzLm1vZHVsZXNbaisrXS5ydWxlcy5sZW5ndGhcbiAgICAgICAgcG9zICs9IG1vZC5ydWxlcy5sZW5ndGhcbiAgICAgICAgaisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgbGV0IHRleHQgPSBcIlwiXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGV4dCArPSB0aGlzLm1vZHVsZXNbaV0uZ2V0UnVsZXMoKSArIFwiXFxuXCJcbiAgICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgfVxuICB9XG59XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZVx1MjAxNHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuIiwgImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIlxufVxuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBnZWNrbyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvR2Vja29cXC9cXGQrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIGJyb2tlbk1vZGlmaWVyTmFtZXMgPSBtYWMgfHwgY2hyb21lICYmICtjaHJvbWVbMV0gPCA1N1xuXG4vLyBGaWxsIGluIHRoZSBkaWdpdCBrZXlzXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGJhc2VbNDggKyBpXSA9IGJhc2VbOTYgKyBpXSA9IFN0cmluZyhpKVxuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaVxuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxuICBzaGlmdFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSlcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgdmFyIGlnbm9yZUtleSA9IGJyb2tlbk1vZGlmaWVyTmFtZXMgJiYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHx8XG4gICAgaWUgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMSB8fFxuICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiIsICJpbXBvcnQgeyBUZXh0LCBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgRmFjZXQsIFN0YXRlRWZmZWN0LCBDaGFuZ2VTZXQsIGZpbmRDbHVzdGVyQnJlYWssIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIGZpbmRDb2x1bW4sIENoYXJDYXRlZ29yeSwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICAvLyBCcm93c2VycyBkaWZmZXIgb24gd2hldGhlciBzaGFkb3cgcm9vdHMgaGF2ZSBhIGdldFNlbGVjdGlvblxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIGlmIChyb290Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiBjb250YWlucyhkb20sIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IGRvbSA9PSBub2RlIHx8IGRvbS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9IDEgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmNvbnN0IFJlY3QwID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfTtcbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jLmJvZHk7XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB3aW5kb3dSZWN0KHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgbW92ZVkgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgKyBtb3ZlWSAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0ICsgbW92ZVggLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gY3VyLnNjcm9sbFRvcCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWCA9IGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZWRYLCB0b3A6IHJlY3QudG9wIC0gbW92ZWRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBtb3ZlZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBtb3ZlZFkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWCAmJiBNYXRoLmFicyhtb3ZlZFggLSBtb3ZlWCkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRZICYmIE1hdGguYWJzKG1vdmVkWSAtIG1vdmVZKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBET01TZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZXEoZG9tU2VsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvck5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgdGhpcy5mb2N1c05vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiB0aGlzLmZvY3VzT2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXQocmFuZ2UuYW5jaG9yTm9kZSwgcmFuZ2UuYW5jaG9yT2Zmc2V0LCByYW5nZS5mb2N1c05vZGUsIHJhbmdlLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgc2V0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBhbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IGFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY3VyLCBjdXIuc2Nyb2xsVG9wLCBjdXIuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChjdXIgPT0gY3VyLm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHN0YWNrW2krK10sIHRvcCA9IHN0YWNrW2krK10sIGxlZnQgPSBzdGFja1tpKytdO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxUb3AgIT0gdG9wKVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgc2NyYXRjaFJhbmdlO1xuZnVuY3Rpb24gdGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvID0gZnJvbSkge1xuICAgIGxldCByYW5nZSA9IHNjcmF0Y2hSYW5nZSB8fCAoc2NyYXRjaFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEtleShlbHQsIG5hbWUsIGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsga2V5OiBuYW1lLCBjb2RlOiBuYW1lLCBrZXlDb2RlOiBjb2RlLCB3aGljaDogY29kZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xuICAgIGxldCBkb3duID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIG9wdGlvbnMpO1xuICAgIGRvd24uc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudChkb3duKTtcbiAgICBsZXQgdXAgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIG9wdGlvbnMpO1xuICAgIHVwLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQodXApO1xuICAgIHJldHVybiBkb3duLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdXAuZGVmYXVsdFByZXZlbnRlZDtcbn1cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSAmJiBub2RlLmhvc3QpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xlYXJBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKG5vZGUuYXR0cmlidXRlc1swXSk7XG59XG5mdW5jdGlvbiBhdEVsZW1lbnRTdGFydChkb2MsIHNlbGVjdGlvbikge1xuICAgIGxldCBub2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yTm9kZSAhPSBub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlID09IGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLmRpcnR5ID0gMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgIH1cbiAgICBnZXQgZWRpdG9yVmlldygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY2Vzc2luZyB2aWV3IGluIG9ycGhhbiBjb250ZW50IHZpZXdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5lZGl0b3JWaWV3O1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmUodGhpcykgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zQmVmb3JlKHZpZXcpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkID09IHZpZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjaGlsZCBpbiBwb3NCZWZvcmVcIik7XG4gICAgfVxuICAgIHBvc0FmdGVyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlKHZpZXcpICsgdmlldy5sZW5ndGg7XG4gICAgfVxuICAgIC8vIFdpbGwgcmV0dXJuIGEgcmVjdGFuZ2xlIGRpcmVjdGx5IGJlZm9yZSAod2hlbiBzaWRlIDwgMCksIGFmdGVyXG4gICAgLy8gKHNpZGUgPiAwKSBvciBkaXJlY3RseSBvbiAod2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCkgdGhlXG4gICAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gICAgY29vcmRzQXQoX3BvcywgX3NpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICYgMiAvKiBEaXJ0eS5Ob2RlICovKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb207XG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuZG9tICYmIChuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFZpZXcgfHwgIWNvbnRlbnRWaWV3LnBhcmVudCAmJiBjb250ZW50Vmlldy5jYW5SZXVzZURPTShjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmV1c2VET00obmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gMCAvKiBEaXJ0eS5Ob3QgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjayAmJiAhdHJhY2sud3JpdHRlbiAmJiB0cmFjay5ub2RlID09IHBhcmVudCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZC5kb20sIG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGQuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiB0cmFjayAmJiB0cmFjay5ub2RlID09IHBhcmVudClcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KVxuICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlydHkgJiAxIC8qIERpcnR5LkNoaWxkICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSAwIC8qIERpcnR5Lk5vdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRpcnR5IHw9IDIgLyogRGlydHkuTm9kZSAqLztcbiAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KGFuZFBhcmVudCk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoY2hpbGRMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXMucGFyZW50OyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZExpc3QpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDIgLyogRGlydHkuTm9kZSAqLztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgJiAxIC8qIERpcnR5LkNoaWxkICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5kaXJ0eSB8PSAxIC8qIERpcnR5LkNoaWxkICovO1xuICAgICAgICAgICAgY2hpbGRMaXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjYW5SZXVzZURPTShvdGhlcikgeyByZXR1cm4gb3RoZXIuY29uc3RydWN0b3IgPT0gdGhpcy5jb25zdHJ1Y3RvcjsgfVxuICAgIC8vIFdoZW4gdGhpcyBpcyBhIHplcm8tbGVuZ3RoIHZpZXcgd2l0aCBhIHNpZGUsIHRoaXMgc2hvdWxkIHJldHVybiBhXG4gICAgLy8gbnVtYmVyIDw9IDAgdG8gaW5kaWNhdGUgaXQgaXMgYmVmb3JlIGl0cyBwb3NpdGlvbiwgb3IgYVxuICAgIC8vIG51bWJlciA+IDAgd2hlbiBhZnRlciBpdHMgcG9zaXRpb24uXG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxufVxuQ29udGVudFZpZXcucHJvdG90eXBlLmJyZWFrQWZ0ZXIgPSAwO1xuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0kMShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuY2xhc3MgQ2hpbGRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBwb3MsIGkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pID0gaTtcbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBmaW5kUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRoaXMucG9zIHx8IHBvcyA9PSB0aGlzLnBvcyAmJlxuICAgICAgICAgICAgICAgIChiaWFzID4gMCB8fCB0aGlzLmkgPT0gMCB8fCB0aGlzLmNoaWxkcmVuW3RoaXMuaSAtIDFdLmJyZWFrQWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYgPSBwb3MgLSB0aGlzLnBvcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlblstLXRoaXMuaV07XG4gICAgICAgICAgICB0aGlzLnBvcyAtPSBuZXh0Lmxlbmd0aCArIG5leHQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBsZXQgYmVmb3JlID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bZnJvbUldIDogbnVsbDtcbiAgICBsZXQgbGFzdCA9IGluc2VydC5sZW5ndGggPyBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBsZXQgYnJlYWtBdEVuZCA9IGxhc3QgPyBsYXN0LmJyZWFrQWZ0ZXIgOiBicmVha0F0U3RhcnQ7XG4gICAgLy8gQ2hhbmdlIHdpdGhpbiBhIHNpbmdsZSBjaGlsZFxuICAgIGlmIChmcm9tSSA9PSB0b0kgJiYgYmVmb3JlICYmICFicmVha0F0U3RhcnQgJiYgIWJyZWFrQXRFbmQgJiYgaW5zZXJ0Lmxlbmd0aCA8IDIgJiZcbiAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIHRvT2ZmLCBpbnNlcnQubGVuZ3RoID8gbGFzdCA6IG51bGwsIGZyb21PZmYgPT0gMCwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0b0kgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gY2hpbGRyZW5bdG9JXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbmQgb2YgdGhlIGNoaWxkIGFmdGVyIHRoZSB1cGRhdGUgaXMgcHJlc2VydmVkIGluIGBhZnRlcmBcbiAgICAgICAgaWYgKGFmdGVyICYmIHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgYSBjaGlsZCwgc2VwYXJhdGUgcGFydCBvZiBpdCB0byBhdm9pZCB0aGF0XG4gICAgICAgICAgICAvLyBiZWluZyBtYW5nbGVkIHdoZW4gdXBkYXRpbmcgdGhlIGNoaWxkIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKGZyb21JID09IHRvSSkge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuc3BsaXQodG9PZmYpO1xuICAgICAgICAgICAgICAgIHRvT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGFmdGVyIHRoZSByZXBsYWNlbWVudCBzaG91bGQgYmUgbWVyZ2VkIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IHJlcGxhY2luZyBlbGVtZW50LCB1cGRhdGUgYGNvbnRlbnRgXG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRFbmQgJiYgbGFzdCAmJiBhZnRlci5tZXJnZSgwLCB0b09mZiwgbGFzdCwgdHJ1ZSwgMCwgb3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdID0gYWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXJ0IG9mIHRoZSBhZnRlciBlbGVtZW50LCBpZiBuZWNlc3NhcnksIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byBgY29udGVudGAuXG4gICAgICAgICAgICAgICAgaWYgKHRvT2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZnRlci5tZXJnZSgwLCB0b09mZiwgbnVsbCwgZmFsc2UsIDAsIG9wZW5FbmQpO1xuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZnRlciA9PT0gbnVsbCB8fCBhZnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWZ0ZXIuYnJlYWtBZnRlcikge1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgYXQgYHRvSWAgaXMgZW50aXJlbHkgY292ZXJlZCBieSB0aGlzIHJhbmdlLlxuICAgICAgICAgICAgLy8gUHJlc2VydmUgaXRzIGxpbmUgYnJlYWssIGlmIGFueS5cbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIGxhc3QuYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBoYW5kbGVkIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50c1xuICAgICAgICAvLyBub3csIG1ha2Ugc3VyZSBgdG9JYCBwb2ludHMgYWZ0ZXIgdGhhdC5cbiAgICAgICAgdG9JKys7XG4gICAgfVxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBicmVha0F0U3RhcnQ7XG4gICAgICAgIGlmIChmcm9tT2ZmID4gMCkge1xuICAgICAgICAgICAgaWYgKCFicmVha0F0U3RhcnQgJiYgaW5zZXJ0Lmxlbmd0aCAmJiBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgaW5zZXJ0WzBdLCBmYWxzZSwgb3BlblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gaW5zZXJ0LnNoaWZ0KCkuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21PZmYgPCBiZWZvcmUubGVuZ3RoIHx8IGJlZm9yZS5jaGlsZHJlbi5sZW5ndGggJiYgYmVmb3JlLmNoaWxkcmVuW2JlZm9yZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBudWxsLCBmYWxzZSwgb3BlblN0YXJ0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIG1lcmdlIHdpZGdldHMgb24gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgd2hpbGUgKGZyb21JIDwgdG9JICYmIGluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW3RvSSAtIDFdLmJlY29tZShpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgdG9JLS07XG4gICAgICAgICAgICBpbnNlcnQucG9wKCk7XG4gICAgICAgICAgICBvcGVuRW5kID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW5bZnJvbUldLmJlY29tZShpbnNlcnRbMF0pKSB7XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICAgICAgaW5zZXJ0LnNoaWZ0KCk7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluc2VydC5sZW5ndGggJiYgZnJvbUkgJiYgdG9JIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFjaGlsZHJlbltmcm9tSSAtIDFdLmJyZWFrQWZ0ZXIgJiZcbiAgICAgICAgY2hpbGRyZW5bdG9JXS5tZXJnZSgwLCAwLCBjaGlsZHJlbltmcm9tSSAtIDFdLCBmYWxzZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgZnJvbUktLTtcbiAgICBpZiAoZnJvbUkgPCB0b0kgfHwgaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZHJlbihmcm9tSSwgdG9JLCBpbnNlcnQpO1xufVxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbkludG8ocGFyZW50LCBmcm9tLCB0bywgaW5zZXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgY3VyID0gcGFyZW50LmNoaWxkQ3Vyc29yKCk7XG4gICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXIuZmluZFBvcyh0bywgMSk7XG4gICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3VyLmZpbmRQb3MoZnJvbSwgLTEpO1xuICAgIGxldCBkTGVuID0gZnJvbSAtIHRvO1xuICAgIGZvciAobGV0IHZpZXcgb2YgaW5zZXJ0KVxuICAgICAgICBkTGVuICs9IHZpZXcubGVuZ3RoO1xuICAgIHBhcmVudC5sZW5ndGggKz0gZExlbjtcbiAgICByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG5sZXQgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6IFwiXCIsIHZlbmRvcjogXCJcIiwgcGxhdGZvcm06IFwiXCIgfTtcbmxldCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogeyBkb2N1bWVudEVsZW1lbnQ6IHsgc3R5bGU6IHt9IH0gfTtcbmNvbnN0IGllX2VkZ2UgPSAvKkBfX1BVUkVfXyovL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvKkBfX1BVUkVfXyovL01TSUUgXFxkLy50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC8qQF9fUFVSRV9fKi8vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgLypAX19QVVJFX18qLy9nZWNrb1xcLyhcXGQrKS9pLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhaWUgJiYgLypAX19QVVJFX18qLy9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgc2FmYXJpID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC8qQF9fUFVSRV9fKi8vTW9iaWxlXFwvXFx3Ky8udGVzdChuYXYudXNlckFnZW50KSB8fCBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbnZhciBicm93c2VyID0ge1xuICAgIG1hYzogaW9zIHx8IC8qQF9fUFVSRV9fKi8vTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgd2luZG93czogLypAX19QVVJFX18qLy9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBsaW51eDogLypAX19QVVJFX18qLy9MaW51eHxYMTEvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBpZSxcbiAgICBpZV92ZXJzaW9uOiBpZV91cHRvMTAgPyBkb2MuZG9jdW1lbnRNb2RlIHx8IDYgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwLFxuICAgIGdlY2tvLFxuICAgIGdlY2tvX3ZlcnNpb246IGdlY2tvID8gKygvKkBfX1BVUkVfXyovL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgY2hyb21lOiAhIWNocm9tZSxcbiAgICBjaHJvbWVfdmVyc2lvbjogY2hyb21lID8gK2Nocm9tZVsxXSA6IDAsXG4gICAgaW9zLFxuICAgIGFuZHJvaWQ6IC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgc2FmYXJpLFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC8qQF9fUFVSRV9fKi8vXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxufTtcblxuY29uc3QgTWF4Sm9pbkxlbiA9IDI1NjtcbmNsYXNzIFRleHRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBjcmVhdGVET00odGV4dERPTSkge1xuICAgICAgICB0aGlzLnNldERPTSh0ZXh0RE9NIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgICAgICBpZiAodGhpcy5kb20ubm9kZVZhbHVlICE9IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKGRvbSk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5IHw9IDQgLyogRGlydHkuQXR0cnMgKi8gfCAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy5zZXRBdHRycyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubWFyay50YWdOYW1lKSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgNCAvKiBEaXJ0eS5BdHRycyAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkge1xuICAgIGxldCBsZW5ndGggPSB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgIGlmICghKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pKSB7IC8vIFRoZXNlIGJyb3dzZXJzIHJlbGlhYmx5IHJldHVybiB2YWxpZCByZWN0YW5nbGVzIGZvciBlbXB0eSByYW5nZXNcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IDE7XG4gICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzaWRlIDwgMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBSZWN0MDtcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhZmxhdHRlbiAmJiByZWN0LndpZHRoID09IDApXG4gICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XG59XG4vLyBBbHNvIHVzZWQgZm9yIGNvbGxhcHNlZCByYW5nZXMgdGhhdCBkb24ndCBoYXZlIGEgcGxhY2Vob2xkZXIgd2lkZ2V0IVxuY2xhc3MgV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAod2lkZ2V0LmN1c3RvbVZpZXcgfHwgV2lkZ2V0Vmlldykod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA9PSB0aGlzLmxlbmd0aCAmJiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVxKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICBsZXQgdG9wID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRvcC5wYXJlbnQpXG4gICAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICBsZXQgdmlldyA9IHRvcC5lZGl0b3JWaWV3LCB0ZXh0ID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB0ZXh0ID8gdGV4dC5zbGljZShzdGFydCwgc3RhcnQgKyB0aGlzLmxlbmd0aCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJlY3QwO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zID4gMCA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAocG9zID4gMCA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwID8gaSA9PSAwIDogaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID8gcmVjdCA6IGZsYXR0ZW5SZWN0KHJlY3QsIHRoaXMuc2lkZSA+IDApO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NpdGlvblZpZXcgZXh0ZW5kcyBXaWRnZXRWaWV3IHtcbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgIGlmICghdG9wVmlldylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRE9NUG9zKHRleHQsIE1hdGgubWluKHBvcywgdGV4dC5ub2RlVmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgMCwgdG9wVmlldywgdGV4dCwgKHYsIHApID0+IHYuZG9tQXRQb3MocCksIHAgPT4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwLCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIHN5bmMoKSB7IHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKCkpOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcG9zRnJvbURPTUluQ29tcG9zaXRpb25UcmVlKG5vZGUsIG9mZnNldCwgdG9wVmlldywgdGV4dCk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCB0b3BWaWV3LCB0ZXh0LCAodiwgcG9zLCBzaWRlKSA9PiB2LmNvb3Jkc0F0KHBvcywgc2lkZSksIChwb3MsIHNpZGUpID0+IHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICAoX2EgPSB0aGlzLndpZGdldC50b3BWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjYW5SZXVzZURPTSgpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8vIFVzZXMgdGhlIG9sZCBzdHJ1Y3R1cmUgb2YgYSBjaHVuayBvZiBjb250ZW50IHZpZXcgZnJvemVuIGZvclxuLy8gY29tcG9zaXRpb24gdG8gdHJ5IGFuZCBmaW5kIGEgcmVhc29uYWJsZSBET00gbG9jYXRpb24gZm9yIHRoZSBnaXZlblxuLy8gb2Zmc2V0LlxuZnVuY3Rpb24gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIHZpZXcsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIHtcbiAgICBpZiAodmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdmlldy5kb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gQ29udGVudFZpZXcuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIGxldCBoYXNDb21wID0gY29udGFpbnMoY2hpbGQsIHRleHQpO1xuICAgICAgICAgICAgbGV0IGxlbiA9IGRlc2MubGVuZ3RoICsgKGhhc0NvbXAgPyB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gfHwgcG9zID09IGxlbiAmJiBkZXNjLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNDb21wID8gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIGRlc2MsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIDogZW50ZXJWaWV3KGRlc2MsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICBwb3MgLT0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgdmlldy5sZW5ndGgsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5kb20gPT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCB2aWV3LCB0ZXh0KSB7XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldykge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB2aWV3LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gMCwgaGFzQ29tcCA9IGNvbnRhaW5zKGNoaWxkLmRvbSwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoY2hpbGQuZG9tLCBub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICsgKGhhc0NvbXAgPyBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCBjaGlsZCwgdGV4dCkgOiBjaGlsZC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBwb3MgKz0gaGFzQ29tcCA/IHRleHQubm9kZVZhbHVlLmxlbmd0aCA6IGNoaWxkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmRvbSA9PSB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIHRleHQubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zKSB7XG4gICAgICAgIGxldCBpbWdSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIFNpbmNlIHRoZSA8aW1nPiBoZWlnaHQgZG9lc24ndCBjb3JyZXNwb25kIHRvIHRleHQgaGVpZ2h0LCB0cnlcbiAgICAgICAgLy8gdG8gYm9ycm93IHRoZSBoZWlnaHQgZnJvbSBzb21lIHNpYmxpbmcgbm9kZS5cbiAgICAgICAgbGV0IHNpYmxpbmdSZWN0ID0gaW5saW5lU2libGluZ1JlY3QodGhpcywgdGhpcy5zaWRlID4gMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWJsaW5nUmVjdCAmJiBzaWJsaW5nUmVjdC50b3AgPCBpbWdSZWN0LmJvdHRvbSAmJiBzaWJsaW5nUmVjdC5ib3R0b20gPiBpbWdSZWN0LnRvcFxuICAgICAgICAgICAgPyB7IGxlZnQ6IGltZ1JlY3QubGVmdCwgcmlnaHQ6IGltZ1JlY3QucmlnaHQsIHRvcDogc2libGluZ1JlY3QudG9wLCBib3R0b206IHNpYmxpbmdSZWN0LmJvdHRvbSB9IDogaW1nUmVjdDtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVTaWJsaW5nUmVjdCh2aWV3LCBzaWRlKSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcucGFyZW50LCBpbmRleCA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHZpZXcpIDogLTE7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIGlmIChzaWRlIDwgMCA/IGluZGV4ID4gMCA6IGluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggKyBzaWRlXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVGV4dFZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJlY3QgPSBuZXh0LmNvb3Jkc0F0KHNpZGUgPCAwID8gbmV4dC5sZW5ndGggOiAwLCBzaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJlY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IHNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnQucGFyZW50LmNoaWxkcmVuLmluZGV4T2YocGFyZW50KSArIChzaWRlIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHBhcmVudC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3QuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWZ0ZXIgJiYgKGVuZCA+IHBvcyB8fCBvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gYXR0cnNFcShhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPSBrZXlzQi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBudWxsO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKGNoYW5nZWQgPSBuYW1lKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoY2hhbmdlZCA9IG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gISFjaGFuZ2VkO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBjdXN0b21WaWV3KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IHNwZWMuc2lkZSB8fCAwLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSBibG9jayA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJiBhdHRyc0VxKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBvdGhlci5zcGVjLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmUgZGVjb3JhdGlvbiByYW5nZXMgbXVzdCBiZSB6ZXJvLWxlbmd0aFwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuY2xhc3MgUG9pbnREZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgd2lkZ2V0LCBpc1JlcGxhY2UpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRTaWRlLCBlbmRTaWRlLCB3aWRnZXQsIHNwZWMpO1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIHRoaXMuaXNSZXBsYWNlID0gaXNSZXBsYWNlO1xuICAgICAgICB0aGlzLm1hcE1vZGUgPSAhYmxvY2sgPyBNYXBNb2RlLlRyYWNrRGVsIDogc3RhcnRTaWRlIDw9IDAgPyBNYXBNb2RlLlRyYWNrQmVmb3JlIDogTWFwTW9kZS5UcmFja0FmdGVyO1xuICAgIH1cbiAgICAvLyBPbmx5IHJlbGV2YW50IHdoZW4gdGhpcy5ibG9jayA9PSB0cnVlXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2lkZSA8IHRoaXMuZW5kU2lkZSA/IEJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IEJsb2NrVHlwZS5XaWRnZXRBZnRlcjtcbiAgICB9XG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkgeyByZXR1cm4gdGhpcy5ibG9jayB8fCAhIXRoaXMud2lkZ2V0ICYmIHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+PSA1OyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB3aWRnZXRzRXEodGhpcy53aWRnZXQsIG90aGVyLndpZGdldCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPT0gb3RoZXIuYmxvY2sgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaWRlID09IG90aGVyLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVwbGFjZSAmJiAoZnJvbSA+IHRvIHx8IChmcm9tID09IHRvICYmIHRoaXMuc3RhcnRTaWRlID4gMCAmJiB0aGlzLmVuZFNpZGUgPD0gMCkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJhbmdlIGZvciByZXBsYWNlbWVudCBkZWNvcmF0aW9uXCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZXBsYWNlICYmIHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldpZGdldCBkZWNvcmF0aW9ucyBjYW4gb25seSBoYXZlIHplcm8tbGVuZ3RoIHJhbmdlc1wiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5Qb2ludERlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldEluY2x1c2l2ZShzcGVjLCBibG9jayA9IGZhbHNlKSB7XG4gICAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IHN0YXJ0LCBpbmNsdXNpdmVFbmQ6IGVuZCB9ID0gc3BlYztcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgc3RhcnQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gdm9pZCAwID8gc3RhcnQgOiBibG9jaywgZW5kOiBlbmQgIT09IG51bGwgJiYgZW5kICE9PSB2b2lkIDAgPyBlbmQgOiBibG9jayB9O1xufVxuZnVuY3Rpb24gd2lkZ2V0c0VxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8ICEhKGEgJiYgYiAmJiBhLmNvbXBhcmUoYikpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoZnJvbSwgdG8sIHJhbmdlcywgbWFyZ2luID0gMCkge1xuICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0gKyBtYXJnaW4gPj0gZnJvbSlcbiAgICAgICAgcmFuZ2VzW2xhc3RdID0gTWF0aC5tYXgocmFuZ2VzW2xhc3RdLCB0byk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZXMucHVzaChmcm9tLCB0byk7XG59XG5cbmNsYXNzIExpbmVWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgIH1cbiAgICAvLyBDb25zdW1lcyBzb3VyY2VcbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHNvdXJjZS50cmFuc2ZlckRPTSh0aGlzKTsgLy8gUmV1c2Ugc291cmNlLmRvbSB3aGVuIGFwcHJvcHJpYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0YXJ0KVxuICAgICAgICAgICAgdGhpcy5zZXREZWNvKHNvdXJjZSA/IHNvdXJjZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuIDogW10sIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgZW5kID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MoYXQpO1xuICAgICAgICBpZiAob2ZmKSB7XG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5baV0uc3BsaXQob2ZmKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLm1lcmdlKG9mZiwgdGhpcy5jaGlsZHJlbltpXS5sZW5ndGgsIG51bGwsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5bal0sIDApO1xuICAgICAgICB3aGlsZSAoaSA+IDAgJiYgdGhpcy5jaGlsZHJlbltpIC0gMV0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWy0taV0uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIHRyYW5zZmVyRE9NKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIG90aGVyLnNldERPTSh0aGlzLmRvbSk7XG4gICAgICAgIG90aGVyLnByZXZBdHRycyA9IHRoaXMucHJldkF0dHJzID09PSB1bmRlZmluZWQgPyB0aGlzLmF0dHJzIDogdGhpcy5wcmV2QXR0cnM7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgfVxuICAgIHNldERlY28oYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRyc0VxKHRoaXMuYXR0cnMsIGF0dHJzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKGNoaWxkLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgam9pbklubGluZUludG8odGhpcywgY2hpbGQsIG9wZW5TdGFydCk7XG4gICAgfVxuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYnVpbGRpbmcgYSBsaW5lIHZpZXcgaW4gQ29udGVudEJ1aWxkZXJcbiAgICBhZGRMaW5lRGVjbyhkZWNvKSB7XG4gICAgICAgIGxldCBhdHRycyA9IGRlY28uc3BlYy5hdHRyaWJ1dGVzLCBjbHMgPSBkZWNvLnNwZWMuY2xhc3M7XG4gICAgICAgIGlmIChhdHRycylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoYXR0cnMsIHRoaXMuYXR0cnMgfHwge30pO1xuICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyh7IGNsYXNzOiBjbHMgfSwgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgcmV1c2VET00obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgfD0gNCAvKiBEaXJ0eS5BdHRycyAqLyB8IDIgLyogRGlydHkuTm9kZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDQgLyogRGlydHkuQXR0cnMgKi8pIHtcbiAgICAgICAgICAgIGNsZWFyQXR0cmlidXRlcyh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldkF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLnByZXZBdHRycywgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGluZVwiKTtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnN5bmModHJhY2spO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGxhc3QgJiYgQ29udGVudFZpZXcuZ2V0KGxhc3QpIGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBsYXN0ID0gbGFzdC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCAhdGhpcy5sZW5ndGggfHxcbiAgICAgICAgICAgIGxhc3Qubm9kZU5hbWUgIT0gXCJCUlwiICYmICgoX2EgPSBDb250ZW50Vmlldy5nZXQobGFzdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICghYnJvd3Nlci5pb3MgfHwgIXRoaXMuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRleHRWaWV3KSkpIHtcbiAgICAgICAgICAgIGxldCBoYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkJSXCIpO1xuICAgICAgICAgICAgaGFjay5jbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChoYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IHRoaXMubGVuZ3RoID4gMjApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fCAvW14gLX5dLy50ZXN0KGNoaWxkLnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQuZG9tKTtcbiAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmVjdHNbMF0ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0b3RhbFdpZHRoID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICBiZWNvbWUoX290aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gQmxvY2tUeXBlLlRleHQ7IH1cbiAgICBzdGF0aWMgZmluZChkb2NWaWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBkb2NWaWV3LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSBkb2NWaWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBibG9jay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChibG9jayBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQgKyBibG9jay5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgdHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF90YWtlRGVjbywgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPT0gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy5sZW5ndGggLSBhdDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBCbG9ja1dpZGdldFZpZXcodGhpcy53aWRnZXQsIGxlbiwgdGhpcy50eXBlKTtcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vQ2hpbGRyZW47IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC52aWV3LnN0YXRlLmRvYy5zbGljZSh0aGlzLnBvc0F0U3RhcnQsIHRoaXMucG9zQXRFbmQpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgb3RoZXIudHlwZSA9PSB0aGlzLnR5cGUgJiZcbiAgICAgICAgICAgIG90aGVyLndpZGdldC5jb25zdHJ1Y3RvciA9PSB0aGlzLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCFvdGhlci53aWRnZXQuZXEodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5icmVha0FmdGVyID0gb3RoZXIuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgLy8gU2V0IHRvIGZhbHNlIGRpcmVjdGx5IGFmdGVyIGEgd2lkZ2V0IHRoYXQgY292ZXJzIHRoZSBwb3NpdGlvbiBhZnRlciBpdFxuICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gLTE7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICAgICAgdGhpcy5za2lwID0gcG9zO1xuICAgIH1cbiAgICBwb3NDb3ZlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuICFsYXN0LmJyZWFrQWZ0ZXIgJiYgIShsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QudHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlKTtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcihhY3RpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihbXSk7XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoIW9wZW5FbmQpXG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKFtdKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICB9XG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihbXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0YWtlID0gTWF0aC5taW4odGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZiwgbGVuZ3RoLCA1MTIgLyogVC5DaHVuayAqLyk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZS5zbGljZSgwLCBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gZGVjbztcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrV2lkZ2V0KG5ldyBCbG9ja1dpZGdldFZpZXcoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJkaXZcIiksIGxlbiwgdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcInNwYW5cIiksIGxlbiwgbGVuID8gMCA6IGRlY28uc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQWZ0ZXIgPSAhdmlldy5pc0VkaXRhYmxlICYmIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPD0gMCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyID09IDIgLyogQnVmLklmQ3Vyc29yICovICYmICFjdXJzb3JCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gPyAxIC8qIEJ1Zi5ZZXMgKi8gOiAyIC8qIEJ1Zi5JZkN1cnNvciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG59XG5cbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jbGFzcyBTY3JvbGxUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB5ID0gXCJuZWFyZXN0XCIsIHggPSBcIm5lYXJlc3RcIiwgeU1hcmdpbiA9IDUsIHhNYXJnaW4gPSA1KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDogbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luKTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKVxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAoY29udGV4dClcbiAgICAgICAgY29uc29sZS5lcnJvcihjb250ZXh0ICsgXCI6XCIsIGV4Y2VwdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKGV4Y2VwdGlvbik7XG59XG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBidWlsZEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgcHJvdmlkZSwgZGVjb3JhdGlvbnM6IGRlY28gfSA9IHNwZWMgfHwge307XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBmb2N1cyA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIGlmIChmb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdVcGRhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxuICAgIFt2aXNpYmxlIHJhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlzaWJsZVJhbmdlcykgY2hhbmdlZCBpbiB0aGlzXG4gICAgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBoZWlnaHQgb2YgYSBibG9jayBlbGVtZW50IGluIHRoZSBlZGl0b3JcbiAgICBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGhlaWdodENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcbiAgICBlZGl0b3IsIG9yIGVsZW1lbnRzIHdpdGhpbiB0aGUgZWRpdG9yLCBjaGFuZ2VkLlxuICAgICovXG4gICAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jQ2hhbmdlZCB8fCAodGhpcy5mbGFncyAmICg4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB1cGRhdGUgaW5kaWNhdGVzIGEgZm9jdXMgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGRvY3VtZW50IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSBzZXQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDsgfVxufVxuXG4vKipcblVzZWQgdG8gaW5kaWNhdGUgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiovXG52YXIgRGlyZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgLy8gKFRoZXNlIGFyZSBjaG9zZW4gdG8gbWF0Y2ggdGhlIGJhc2UgbGV2ZWxzLCBpbiBiaWRpIGFsZ29yaXRobVxuICAgIC8vIHRlcm1zLCBvZiBzcGFucyBpbiB0aGF0IGRpcmVjdGlvbi4pXG4gICAgLyoqXG4gICAgTGVmdC10by1yaWdodC5cbiAgICAqL1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJMVFJcIl0gPSAwXSA9IFwiTFRSXCI7XG4gICAgLyoqXG4gICAgUmlnaHQtdG8tbGVmdC5cbiAgICAqL1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJSVExcIl0gPSAxXSA9IFwiUlRMXCI7XG5yZXR1cm4gRGlyZWN0aW9ufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuY29uc3QgTFRSID0gRGlyZWN0aW9uLkxUUiwgUlRMID0gRGlyZWN0aW9uLlJUTDtcbi8vIERlY29kZSBhIHN0cmluZyB3aXRoIGVhY2ggdHlwZSBlbmNvZGVkIGFzIGxvZzIodHlwZSlcbmZ1bmN0aW9uIGRlYyhzdHIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDEgPDwgK3N0cltpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZjhcbmNvbnN0IExvd1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4NjY2ODg4ODg4Nzg3ODMzMzMzMzMzMzM3ODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg3ODY2NjY4ODg4MDg4ODg4NjYzMzgwODg4MzA4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4XCIpO1xuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDB4NjAwIHRvIDB4NmY5XG5jb25zdCBBcmFiaWNUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI0NDQ0NDQ4ODI2NjI3Mjg4OTk5OTk5OTk5OTkyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5OTk5OTk5OTk5OTk5OTk0NDQ0NDQ0NDQ0NjQ0MjIyODIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTQ5OTk5OTk5MjI5OTg5OTk5MjIzMzMzMzMzMzMzXCIpO1xuY29uc3QgQnJhY2tldHMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKSwgQnJhY2tldFN0YWNrID0gW107XG4vLyBUaGVyZSdzIGEgbG90IG1vcmUgaW5cbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9CaWRpQnJhY2tldHMudHh0LFxuLy8gd2hpY2ggYXJlIGxlZnQgb3V0IHRvIGtlZXAgY29kZSBzaXplIGRvd24uXG5mb3IgKGxldCBwIG9mIFtcIigpXCIsIFwiW11cIiwgXCJ7fVwiXSkge1xuICAgIGxldCBsID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgwKSwgciA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMSk7XG4gICAgQnJhY2tldHNbbF0gPSByO1xuICAgIEJyYWNrZXRzW3JdID0gLWw7XG59XG5mdW5jdGlvbiBjaGFyVHlwZShjaCkge1xuICAgIHJldHVybiBjaCA8PSAweGY3ID8gTG93VHlwZXNbY2hdIDpcbiAgICAgICAgMHg1OTAgPD0gY2ggJiYgY2ggPD0gMHg1ZjQgPyAyIC8qIFQuUiAqLyA6XG4gICAgICAgICAgICAweDYwMCA8PSBjaCAmJiBjaCA8PSAweDZmOSA/IEFyYWJpY1R5cGVzW2NoIC0gMHg2MDBdIDpcbiAgICAgICAgICAgICAgICAweDZlZSA8PSBjaCAmJiBjaCA8PSAweDhhYyA/IDQgLyogVC5BTCAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDB4MjAwMCA8PSBjaCAmJiBjaCA8PSAweDIwMGIgPyAyNTYgLyogVC5OSSAqLyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAweGZiNTAgPD0gY2ggJiYgY2ggPD0gMHhmZGZmID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9PSAweDIwMGMgPyAyNTYgLyogVC5OSSAqLyA6IDEgLyogVC5MICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kKG9yZGVyLCBpbmRleCwgbGV2ZWwsIGFzc29jKSB7XG4gICAgICAgIGxldCBtYXliZSA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBpbmRleCAmJiBzcGFuLnRvID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYW4ubGV2ZWwgPT0gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgc3BhbnMgbWF0Y2gsIGlmIGFzc29jICE9IDAsIHRha2UgdGhlIG9uZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gY292ZXJzIHRoYXQgc2lkZSwgb3RoZXJ3aXNlIHRha2UgdGhlIG9uZSB3aXRoIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgLy8gbGV2ZWwuXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlIDwgMCB8fCAoYXNzb2MgIT0gMCA/IChhc3NvYyA8IDAgPyBzcGFuLmZyb20gPCBpbmRleCA6IHNwYW4udG8gPiBpbmRleCkgOiBvcmRlclttYXliZV0ubGV2ZWwgPiBzcGFuLmxldmVsKSlcbiAgICAgICAgICAgICAgICAgICAgbWF5YmUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIG1heWJlO1xuICAgIH1cbn1cbi8vIFJldXNlZCBhcnJheSBvZiBjaGFyYWN0ZXIgdHlwZXNcbmNvbnN0IHR5cGVzID0gW107XG5mdW5jdGlvbiBjb21wdXRlT3JkZXIobGluZSwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IGxlbiA9IGxpbmUubGVuZ3RoLCBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLywgb3Bwb3NpdGVUeXBlID0gZGlyZWN0aW9uID09IExUUiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKCFsaW5lIHx8IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyAmJiAhQmlkaVJFLnRlc3QobGluZSkpXG4gICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGVuKTtcbiAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAvLyBudW1iZXIuXG4gICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlLCBwcmV2U3Ryb25nID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICB0eXBlID0gcHJldjtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgdHlwZXNbaV0gPSB0eXBlID09IDQgLyogVC5BTCAqLyA/IDIgLyogVC5SICovIDogdHlwZTtcbiAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgIH1cbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAvLyBOZXV0cmFsLlxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4sIE5JKVxuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlLCBwcmV2U3Ryb25nID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMTI4IC8qIFQuQ1MgKi8pIHtcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSAmJiBwcmV2ID09IHR5cGVzW2kgKyAxXSAmJiAocHJldiAmIDI0IC8qIFQuTnVtICovKSlcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMjU2IC8qIFQuTkkgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gNjQgLyogVC5FVCAqLylcbiAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgZW5kOyBqKyspXG4gICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgfVxuICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgIC8vIHNjb3BlLCBiaWRpcmVjdGlvbmFsIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgIGZvciAobGV0IGkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwLCBjaCwgYnIsIHR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICBpZiAoYnIgPSBCcmFja2V0c1tjaCA9IGxpbmUuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJyYWNrZXRTdGFja1tzSiArIDFdID09IC1icikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmbGFncyAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGVzW0JyYWNrZXRTdGFja1tzSl1dID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJyYWNrZXRTdGFjay5sZW5ndGggPT0gMTg5IC8qIEJyYWNrZXRlZC5NYXhEZXB0aCAqLykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0eXBlID0gdHlwZXNbaV0pID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodHlwZXNbaV0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSAyNTYgLyogVC5OSSAqLylcbiAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgIGxldCBiZWZvcmVMID0gKGkgPyB0eXBlc1tpIC0gMV0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgbGV0IGFmdGVyTCA9IChlbmQgPCBsZW4gPyB0eXBlc1tlbmRdIDogb3V0ZXJUeXBlKSA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZXJlIHdlIGRlcGFydCBmcm9tIHRoZSBkb2N1bWVudGVkIGFsZ29yaXRobSwgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcbiAgICAvLyBleHBsaWNpdCBlbWJlZGRpbmcgaW50byBhY2NvdW50LCB3ZSBjYW4gYnVpbGQgdXAgdGhlIG9yZGVyIG9uXG4gICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cbiAgICBsZXQgb3JkZXIgPSBbXTtcbiAgICBpZiAob3V0ZXJUeXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSAhPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIHJ0bCA9PSAodHlwZXNbaV0gIT0gMSAvKiBULkwgKi8pKVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IHN0YXJ0Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gaiwgbCA9IHR5cGVzWy0tal0gIT0gMiAvKiBULlIgKi87XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqID4gc3RhcnQgJiYgbCA9PSAodHlwZXNbaiAtIDFdICE9IDIgLyogVC5SICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaiwgZW5kLCBsID8gMiA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihzdGFydCwgaSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGksIHJ0bCA9IHR5cGVzW2krK10gPT0gMiAvKiBULlIgKi87XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBydGwgPT0gKHR5cGVzW2ldID09IDIgLyogVC5SICovKSlcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihzdGFydCwgaSwgcnRsID8gMSA6IDIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5mdW5jdGlvbiB0cml2aWFsT3JkZXIobGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtuZXcgQmlkaVNwYW4oMCwgbGVuZ3RoLCAwKV07XG59XG5sZXQgbW92ZWRPdmVyID0gXCJcIjtcbmZ1bmN0aW9uIG1vdmVWaXN1YWxseShsaW5lLCBvcmRlciwgZGlyLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmhlYWQgLSBsaW5lLmZyb20sIHNwYW5JID0gLTE7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICBpZiAoIWZvcndhcmQgfHwgIWxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBvcmRlclswXS5zaWRlKGZhbHNlLCBkaXIpO1xuICAgICAgICAgICAgc3BhbkkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0SW5kZXggPT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxhc3QgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QubGV2ZWwgIT0gZGlyKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbGFzdC5zaWRlKHRydWUsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYW5JIDwgMClcbiAgICAgICAgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV07XG4gICAgLy8gRW5kIG9mIHNwYW4uIChCdXQgbm90IGVuZCBvZiBsaW5lLS10aGF0IHdhcyBjaGVja2VkIGZvciBhYm92ZS4pXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcikpIHtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JICs9IGZvcndhcmQgPyAxIDogLTFdO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgIH1cbiAgICBsZXQgaW5kZXhGb3J3YXJkID0gZm9yd2FyZCA9PSAoc3Bhbi5kaXIgPT0gZGlyKTtcbiAgICBsZXQgbmV4dEluZGV4ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHN0YXJ0SW5kZXgsIGluZGV4Rm9yd2FyZCk7XG4gICAgbW92ZWRPdmVyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHN0YXJ0SW5kZXgsIG5leHRJbmRleCksIE1hdGgubWF4KHN0YXJ0SW5kZXgsIG5leHRJbmRleCkpO1xuICAgIGlmIChuZXh0SW5kZXggIT0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcikpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgaW5kZXhGb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKCFuZXh0U3BhbiAmJiBzcGFuLmxldmVsICE9IGRpcilcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEsIGRpcik7XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRTcGFuLmxldmVsIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IDEgOiAtMSwgbmV4dFNwYW4ubGV2ZWwpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5cbmNvbnN0IExpbmVCcmVha1BsYWNlaG9sZGVyID0gXCJcXHVmZmZmXCI7XG5jbGFzcyBET01SZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGluZVNlcGFyYXRvciA9IHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBhcHBlbmQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gdGV4dDtcbiAgICB9XG4gICAgbGluZUJyZWFrKCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gTGluZUJyZWFrUGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcbiAgICAgICAgICAgIHRoaXMucmVhZE5vZGUoY3VyKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKSwgbmV4dFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICBpZiAodmlldyAmJiBuZXh0VmlldyA/IHZpZXcuYnJlYWtBZnRlciA6XG4gICAgICAgICAgICAgICAgKHZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOiBpc0Jsb2NrRWxlbWVudChjdXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNCbG9ja0VsZW1lbnQobmV4dCkgJiYgKGN1ci5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgY3VyLmNtSWdub3JlKSkpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgbGV0IHRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihwb2ludC5vZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gMCwgcmUgPSB0aGlzLmxpbmVTZXBhcmF0b3IgPyBudWxsIDogL1xcclxcbj98XFxuL2c7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IC0xLCBicmVha1NpemUgPSAxLCBtO1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IHRleHQuaW5kZXhPZih0aGlzLmxpbmVTZXBhcmF0b3IsIG9mZik7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG0gPSByZS5leGVjKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKHRleHQuc2xpY2Uob2ZmLCBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWspKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGlmIChicmVha1NpemUgPiAxKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIHBvaW50LnBvcyA+IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5wb3MgLT0gYnJlYWtTaXplIC0gMTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRCcmVhayArIGJyZWFrU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgaWYgKGZyb21WaWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW5zaWRlKG5vZGUsIGZyb21WaWV3Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5saW5lQnJlYWspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbnNpZGUobm9kZSwgbWF4TGVuKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyA/IHBvaW50Lm5vZGUgPT0gbm9kZSA6IG5vZGUuY29udGFpbnMocG9pbnQubm9kZSkpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKG1heExlbiwgcG9pbnQub2Zmc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Jsb2NrRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAvXihESVZ8UHxMSXxVTHxPTHxCTE9DS1FVT1RFfEREfERUfEhcXGR8U0VDVElPTnxQUkUpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbn1cbmNsYXNzIERPTVBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucG9zID0gLTE7XG4gICAgfVxufVxuXG5jbGFzcyBEb2NWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28gPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtdO1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDApO1xuICAgIH1cbiAgICBnZXQgZWRpdG9yVmlldygpIHsgcmV0dXJuIHRoaXMudmlldzsgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLiBzY3JvbGxJbnRvVmlldyBjYW4gYmVcbiAgICAvLyB1c2VkIGFzIGEgaGludCB0byBjb21wdXRlIGEgbmV3IHZpZXdwb3J0IHRoYXQgaW5jbHVkZXMgdGhhdFxuICAgIC8vIHBvc2l0aW9uLCBpZiB3ZSBrbm93IHRoZSBlZGl0b3IgaXMgZ29pbmcgdG8gc2Nyb2xsIHRoYXQgcG9zaXRpb25cbiAgICAvLyBpbnRvIHZpZXcuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggfHwgdGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpdGlvbkRlY28uc2l6ZSAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IDAgLyogRGlydHkuTm90ICovICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAgIC8vIHVwZGF0ZVxuICAgIHVwZGF0ZUlubmVyKGNoYW5nZXMsIG9sZExlbmd0aCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0cmFjayk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gMCAvKiBEaXJ0eS5Ob3QgKi87XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgKHRyYWNrLndyaXR0ZW4gfHwgb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlICE9IHRyYWNrLm5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGNoaWxkLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlR2FwcyhnYXBzKTtcbiAgICB9XG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gY2hhbmdlc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0O1xuICAgICAgICAgICAgbGV0IHsgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIERPTSBzZWxlY3Rpb24gdG8gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICB1cGRhdGVTZWxlY3Rpb24obXVzdFJlYWQgPSBmYWxzZSwgZnJvbVBvaW50ZXIgPSBmYWxzZSkge1xuICAgICAgICBpZiAobXVzdFJlYWQgfHwgIXRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmICghKGZyb21Qb2ludGVyIHx8IHRoaXMubWF5Q29udHJvbFNlbGVjdGlvbigpKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZvcmNlID0gdGhpcy5mb3JjZVNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgLy8gRklYTUUgbmVlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHNlbGVjdGlvbiBmYWxscyBpbnNpZGUgYSBibG9jayByYW5nZVxuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5kb21BdFBvcyhtYWluLmFuY2hvcik7XG4gICAgICAgIGxldCBoZWFkID0gbWFpbi5lbXB0eSA/IGFuY2hvciA6IHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKTtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IG9uIEZpcmVmb3ggd2hlbiBuZXh0IHRvIGFuIHVuZWRpdGFibGUgbm9kZSB0b1xuICAgICAgICAvLyBhdm9pZCBpbnZpc2libGUgY3Vyc29yIGJ1Z3MgKCMxMTEpXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGhlcmUsIG9yIGluIGFuIGVxdWl2YWxlbnQgcG9zaXRpb24sIGRvbid0IHRvdWNoIGl0XG4gICAgICAgIGlmIChmb3JjZSB8fCAhZG9tU2VsLmZvY3VzTm9kZSB8fFxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkLm5vZGUsIGhlYWQub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIHVuZWRpdGFibGUgbm9kZSwgYW5kIG5vdCBicmluZyBpdCBiYWNrIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gaXRzIHByb3BlciBwb3NpdGlvbi4gVGhpcyB0cmllcyB0b1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiB0aGlzLmRvbS5jb250YWlucyhkb21TZWwuZm9jdXNOb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICBpblVuZWRpdGFibGUoZG9tU2VsLmZvY3VzTm9kZSwgdGhpcy5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmF3U2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMudmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1NlbCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRUbyA9IG5leHRUb1VuZWRpdGFibGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogTmV4dFRvLkJlZm9yZSAqLyB8IDIgLyogTmV4dFRvLkFmdGVyICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbmVhcmJ5VGV4dE5vZGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQsIG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyAwIDogdGV4dC5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5iaWRpTGV2ZWwgIT0gbnVsbCAmJiBkb21TZWwuY3Vyc29yQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21TZWwuY3Vyc29yQmlkaUxldmVsID0gbWFpbi5iaWRpTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd1NlbC5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBjYWxsIGFib3ZlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRkZW4sIGFuZCB0aGVuIHJhaXNlIGFuIGVycm9yIG9uIHRoZSBjYWxsIHRvIGV4dGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyAoIzk0MCkuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuZXh0ZW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5hbmNob3IgPiBtYWluLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpdGlvbkRlY28uc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgY3Vyc29yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICghc2VsIHx8ICFjdXJzb3IuZW1wdHkgfHwgIWN1cnNvci5hc3NvYyB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHRoaXMsIGN1cnNvci5oZWFkKTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbGluZS5wb3NBdFN0YXJ0O1xuICAgICAgICBpZiAoY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0IHx8IGN1cnNvci5oZWFkID09IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgLTEpLCBhZnRlciA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIDEpO1xuICAgICAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgYmVmb3JlLmJvdHRvbSA+IGFmdGVyLnRvcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tQXRQb3MoY3Vyc29yLmhlYWQgKyBjdXJzb3IuYXNzb2MpO1xuICAgICAgICBzZWwuY29sbGFwc2UoZG9tLm5vZGUsIGRvbS5vZmZzZXQpO1xuICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBjdXJzb3IuYXNzb2MgPCAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIsIFwibGluZWJvdW5kYXJ5XCIpO1xuICAgICAgICAvLyBUaGlzIGNhbiBnbyB3cm9uZyBpbiBjb3JuZXIgY2FzZXMgbGlrZSBzaW5nbGUtY2hhcmFjdGVyIGxpbmVzLFxuICAgICAgICAvLyBzbyBjaGVjayBhbmQgcmVzZXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB2aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3UmFuZ2UgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5kb2NWaWV3LnBvc0Zyb21ET00obmV3UmFuZ2UuYW5jaG9yTm9kZSwgbmV3UmFuZ2UuYW5jaG9yT2Zmc2V0KSAhPSBjdXJzb3IuZnJvbSlcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICAgIH1cbiAgICBtYXlDb250cm9sU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgYWN0aXZlID0gdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmRvbSB8fFxuICAgICAgICAgICAgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpICYmICEoYWN0aXZlICYmIHRoaXMuZG9tLmNvbnRhaW5zKGFjdGl2ZSkpO1xuICAgIH1cbiAgICBuZWFyZXN0KGRvbSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcbiAgICAgICAgICAgIGxldCBkb21WaWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1cik7XG4gICAgICAgICAgICBpZiAoZG9tVmlldyAmJiBkb21WaWV3LnJvb3RWaWV3ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbVZpZXc7XG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5lYXJlc3Qobm9kZSk7XG4gICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGZpbmQgcG9zaXRpb24gZm9yIGEgRE9NIHBvc2l0aW9uIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIHZpZXcucG9zQXRTdGFydDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCAtMSk7XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmYgPCBjaGlsZC5sZW5ndGggfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tQXRQb3Mob2ZmKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubGVuZ3RoLCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzdGFydCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIgLSBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gc3RhcnQgfHxcbiAgICAgICAgICAgICAgICAocG9zID09IHN0YXJ0ICYmIGNoaWxkLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSAmJiBjaGlsZC50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJlxuICAgICAgICAgICAgICAgICAgICAoIWkgfHwgc2lkZSA9PSAyIHx8IHRoaXMuY2hpbGRyZW5baSAtIDFdLmJyZWFrQWZ0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNoaWxkcmVuW2kgLSAxXS50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgJiYgc2lkZSA+IC0yKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5jb29yZHNBdChwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBsdHIgPyByZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LmxlZnQgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgeyBpIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSk7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY2hpbGRyZW5baV0uZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSBjaGlsZC5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd29ya2FibGUgbGluZSBleGlzdHMsIGZvcmNlIGEgbGF5b3V0IG9mIGEgbWVhc3VyYWJsZSBlbGVtZW50XG4gICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGxpbmVIZWlnaHQsIGNoYXJXaWR0aDtcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgIGR1bW15LnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCI7XG4gICAgICAgIGR1bW15LnRleHRDb250ZW50ID0gXCJhYmMgZGVmIGdoaSBqa2wgbW5vIHBxciBzdHVcIjtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkdW1teSk7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGNsaWVudFJlY3RzRm9yKGR1bW15LmZpcnN0Q2hpbGQpWzBdO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IGR1bW15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IHJlY3QgPyByZWN0LndpZHRoIC8gMjcgOiA3O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGggfTtcbiAgICB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTW92ZSBiYWNrIHRvIHN0YXJ0IG9mIGxhc3QgZWxlbWVudCB3aGVuIHBvc3NpYmxlLCBzbyB0aGF0XG4gICAgICAgIC8vIGBDaGlsZEN1cnNvci5maW5kUG9zYCBkb2Vzbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoZSBlZGdlIGNhc2VcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIGkpO1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdnMubGluZUJsb2NrQXQoZW5kKS5ib3R0b20gLSB2cy5saW5lQmxvY2tBdChwb3MpLnRvcDtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgYWxsRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykubWFwKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaV0gPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pYyA/IGQodGhpcy52aWV3KSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gYWxsRGVjby5sZW5ndGg7IGkgPCBhbGxEZWNvLmxlbmd0aCArIDM7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaV0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi5hbGxEZWNvLFxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGxldCB7IHJhbmdlIH0gPSB0YXJnZXQ7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5jb29yZHNBdChyYW5nZS5oZWFkLCByYW5nZS5lbXB0eSA/IHJhbmdlLmFzc29jIDogcmFuZ2UuaGVhZCA+IHJhbmdlLmFuY2hvciA/IC0xIDogMSksIG90aGVyO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgKG90aGVyID0gdGhpcy5jb29yZHNBdChyYW5nZS5hbmNob3IsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyAtMSA6IDEpKSlcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IE1hdGgubWluKHJlY3QubGVmdCwgb3RoZXIubGVmdCksIHRvcDogTWF0aC5taW4ocmVjdC50b3AsIG90aGVyLnRvcCksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KHJlY3QucmlnaHQsIG90aGVyLnJpZ2h0KSwgYm90dG9tOiBNYXRoLm1heChyZWN0LmJvdHRvbSwgb3RoZXIuYm90dG9tKSB9O1xuICAgICAgICBsZXQgbUxlZnQgPSAwLCBtUmlnaHQgPSAwLCBtVG9wID0gMCwgbUJvdHRvbSA9IDA7XG4gICAgICAgIGZvciAobGV0IG1hcmdpbnMgb2YgdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNjcm9sbE1hcmdpbnMpLm1hcChmID0+IGYodGhpcy52aWV3KSkpXG4gICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gbWFyZ2lucztcbiAgICAgICAgICAgICAgICBpZiAobGVmdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtTGVmdCA9IE1hdGgubWF4KG1MZWZ0LCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbVJpZ2h0ID0gTWF0aC5tYXgobVJpZ2h0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtVG9wID0gTWF0aC5tYXgobVRvcCwgdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1Cb3R0b20gPSBNYXRoLm1heChtQm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1MZWZ0LCB0b3A6IHJlY3QudG9wIC0gbVRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbVJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbUJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcy52aWV3LnNjcm9sbERPTSwgdGFyZ2V0UmVjdCwgcmFuZ2UuaGVhZCA8IHJhbmdlLmFuY2hvciA/IC0xIDogMSwgdGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueE1hcmdpbiwgdGFyZ2V0LnlNYXJnaW4sIHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJldHdlZW5VbmVkaXRhYmxlKHBvcykge1xuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gMCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSBwb3Mubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmhlaWdodCA9PSB0aGlzLmhlaWdodDsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuaGVpZ2h0OyB9XG59XG5mdW5jdGlvbiBjb21wb3NpdGlvblN1cnJvdW5kaW5nTm9kZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgbGV0IHRleHROb2RlID0gc2VsLmZvY3VzTm9kZSAmJiBuZWFyYnlUZXh0Tm9kZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIDApO1xuICAgIGlmICghdGV4dE5vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjVmlldyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KHRleHROb2RlKTtcbiAgICBpZiAoIWNWaWV3KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoY1ZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldykge1xuICAgICAgICBsZXQgdG9wTm9kZSA9IHRleHROb2RlO1xuICAgICAgICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IGNWaWV3LmRvbSlcbiAgICAgICAgICAgIHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGxldCBwcmV2ID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHdoaWxlIChwcmV2ICYmICFDb250ZW50Vmlldy5nZXQocHJldikpXG4gICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGxldCBwb3MgPSBwcmV2ID8gQ29udGVudFZpZXcuZ2V0KHByZXYpLnBvc0F0RW5kIDogY1ZpZXcucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCB0bzogcG9zLCBub2RlOiB0b3BOb2RlLCB0ZXh0OiB0ZXh0Tm9kZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHsgcGFyZW50IH0gPSBjVmlldztcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY1ZpZXcgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb20gPSBjVmlldy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0bzogZnJvbSArIGNWaWV3Lmxlbmd0aCwgbm9kZTogY1ZpZXcuZG9tLCB0ZXh0OiB0ZXh0Tm9kZSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb21wb3NpdGlvbkRlY28odmlldywgY2hhbmdlcykge1xuICAgIGxldCBzdXJyb3VuZGluZyA9IGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpO1xuICAgIGlmICghc3Vycm91bmRpbmcpXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgbGV0IHsgZnJvbSwgdG8sIG5vZGUsIHRleHQ6IHRleHROb2RlIH0gPSBzdXJyb3VuZGluZztcbiAgICBsZXQgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGZyb20sIDEpLCBuZXdUbyA9IE1hdGgubWF4KG5ld0Zyb20sIGNoYW5nZXMubWFwUG9zKHRvLCAtMSkpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB0ZXh0ID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUgOlxuICAgICAgICBuZXcgRE9NUmVhZGVyKFtdLCBzdGF0ZSkucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCkudGV4dDtcbiAgICBpZiAobmV3VG8gLSBuZXdGcm9tIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhuZXdGcm9tLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBuZXdGcm9tICsgdGV4dC5sZW5ndGgpLCBMaW5lQnJlYWtQbGFjZWhvbGRlcikgPT0gdGV4dClcbiAgICAgICAgICAgIG5ld1RvID0gbmV3RnJvbSArIHRleHQubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoTWF0aC5tYXgoMCwgbmV3VG8gLSB0ZXh0Lmxlbmd0aCksIG5ld1RvLCBMaW5lQnJlYWtQbGFjZWhvbGRlcikgPT0gdGV4dClcbiAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyAtIHRleHQubGVuZ3RoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcobmV3RnJvbSwgbmV3VG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSAhPSB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIGxldCB0b3BWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgIGlmICh0b3BWaWV3IGluc3RhbmNlb2YgQ29tcG9zaXRpb25WaWV3KVxuICAgICAgICB0b3BWaWV3ID0gdG9wVmlldy53aWRnZXQudG9wVmlldztcbiAgICBlbHNlIGlmICh0b3BWaWV3KVxuICAgICAgICB0b3BWaWV3LnBhcmVudCA9IG51bGw7XG4gICAgcmV0dXJuIERlY29yYXRpb24uc2V0KERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IENvbXBvc2l0aW9uV2lkZ2V0KG5vZGUsIHRleHROb2RlLCB0b3BWaWV3KSwgaW5jbHVzaXZlOiB0cnVlIH0pXG4gICAgICAgIC5yYW5nZShuZXdGcm9tLCBuZXdUbykpO1xufVxuY2xhc3MgQ29tcG9zaXRpb25XaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3AsIHRleHQsIHRvcFZpZXcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG9wVmlldyA9IHRvcFZpZXc7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLnRvcCA9PSBvdGhlci50b3AgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIHRoaXMudG9wOyB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBjdXN0b21WaWV3KCkgeyByZXR1cm4gQ29tcG9zaXRpb25WaWV3OyB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQsIHNpZGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwICYmIHNpZGUgPD0gMCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XG4gICAgICAgIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAyIC8qIE5leHRUby5BZnRlciAqLyA6IDApO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5mdW5jdGlvbiBpblVuZWRpdGFibGUobm9kZSwgaW5zaWRlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyICYmIGN1ciAhPSBpbnNpZGU7IGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPdmVybGFwID0gIWR4IHx8IChkeCA+IDAgPyBpIDwgcmVjdHMubGVuZ3RoIC0gMSA6IGkgPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiByZWN0LmJvdHRvbSAmJiAoIWFib3ZlUmVjdCB8fCBhYm92ZVJlY3QuYm90dG9tIDwgcmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPCByZWN0LnRvcCAmJiAoIWJlbG93UmVjdCB8fCBiZWxvd1JlY3QudG9wID4gcmVjdC50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWJvdmVSZWN0ICYmIHlPdmVybGFwKGFib3ZlUmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSB1cEJvdChhYm92ZVJlY3QsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiB5T3ZlcmxhcChiZWxvd1JlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gdXBUb3AoYmVsb3dSZWN0LCByZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFib3ZlUmVjdCAmJiBhYm92ZVJlY3QuYm90dG9tID49IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGFib3ZlO1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGFib3ZlUmVjdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIGJlbG93UmVjdC50b3AgPD0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYmVsb3c7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYmVsb3dSZWN0O1xuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QpXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0OiAwIH07XG4gICAgbGV0IGNsaXBYID0gTWF0aC5tYXgoY2xvc2VzdFJlY3QubGVmdCwgTWF0aC5taW4oY2xvc2VzdFJlY3QucmlnaHQsIHgpKTtcbiAgICBpZiAoY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZG9tUG9zSW5UZXh0KGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBpZiAoY2xvc2VzdE92ZXJsYXAgJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgIT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gZG9tUG9zQXRDb29yZHMoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGxldCBvZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5jaGlsZE5vZGVzLCBjbG9zZXN0KSArXG4gICAgICAgICh4ID49IChjbG9zZXN0UmVjdC5sZWZ0ICsgY2xvc2VzdFJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZG9tUG9zSW5UZXh0KG5vZGUsIHgsIHkpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCBjbG9zZXN0T2Zmc2V0ID0gLTEsIGNsb3Nlc3REWSA9IDFlOSwgZ2VuZXJhbFNpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKG5vZGUsIGksIGkgKyAxKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFnZW5lcmFsU2lkZSlcbiAgICAgICAgICAgICAgICBnZW5lcmFsU2lkZSA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgZHkgPSAocmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogeSAtIHJlY3QuYm90dG9tKSAtIDE7XG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0IC0gMSA8PSB4ICYmIHJlY3QucmlnaHQgKyAxID49IHggJiYgZHkgPCBjbG9zZXN0RFkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB4ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIGFmdGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFJUTCBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2V0dGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdHMgZm9yIGVtcHR5IHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSB0ZXh0UmFuZ2Uobm9kZSwgaSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gIXJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHkgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGFmdGVyID8gMSA6IDApIH07XG4gICAgICAgICAgICAgICAgY2xvc2VzdE9mZnNldCA9IGkgKyAoYWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERZID0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBjbG9zZXN0T2Zmc2V0ID4gLTEgPyBjbG9zZXN0T2Zmc2V0IDogZ2VuZXJhbFNpZGUgPiAwID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogMCB9O1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgeyB4LCB5IH0sIHByZWNpc2UsIGJpYXMgPSAtMSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jVG9wID0gY29udGVudC50b3AgKyB2aWV3LnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIGxldCBibG9jaywgeyBkb2NIZWlnaHQgfSA9IHZpZXcudmlld1N0YXRlO1xuICAgIGxldCB5T2Zmc2V0ID0geSAtIGRvY1RvcDtcbiAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh5T2Zmc2V0ID4gZG9jSGVpZ2h0KVxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgIC8vIFNjYW4gZm9yIGEgdGV4dCBibG9jayBuZWFyIHRoZSBxdWVyaWVkIHkgcG9zaXRpb25cbiAgICBmb3IgKGxldCBoYWxmTGluZSA9IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3ApIC8gdmlldy5kZWZhdWx0TGluZUhlaWdodCk7XG4gICAgICAgIGludG8gKz0gbGluZSAqIHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xuICAgIHJldHVybiBibG9jay5mcm9tICsgZmluZENvbHVtbihjb250ZW50LCBpbnRvLCB2aWV3LnN0YXRlLnRhYlNpemUpO1xufVxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXG4vLyB0aGUgc3BhY2UgYmV0d2VlbiBsaW5lcyBhcyBiZWxvbmdpbmcgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gbGluZSBiZWZvcmUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3Qgc3VjaCBhIHJlc3VsdCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBsZXQgbGVuO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7IG5leHQ7IG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKVxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0ZXh0UmFuZ2Uobm9kZSwgbGVuIC0gMSwgbGVuKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4geDtcbn1cbi8vIENocm9tZSB3aWxsIG1vdmUgcG9zaXRpb25zIGJldHdlZW4gbGluZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGxpbmVcbmZ1bmN0aW9uIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGlmIChvZmZzZXQgIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIG1vdmVUb0xpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXApIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8ICF2aWV3LmxpbmVXcmFwcGluZyA/IG51bGxcbiAgICAgICAgOiB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0LmFzc29jIDwgMCAmJiBzdGFydC5oZWFkID4gbGluZS5mcm9tID8gc3RhcnQuaGVhZCAtIDEgOiBzdGFydC5oZWFkKTtcbiAgICBpZiAoY29vcmRzKSB7XG4gICAgICAgIGxldCBlZGl0b3JSZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB2aWV3LnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGZvcndhcmQgPT0gKGRpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKSA/IGVkaXRvclJlY3QucmlnaHQgLSAxIDogZWRpdG9yUmVjdC5sZWZ0ICsgMSxcbiAgICAgICAgICAgIHk6IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyIH0pO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xuICAgIH1cbiAgICBsZXQgbGluZVZpZXcgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgc3RhcnQuaGVhZCk7XG4gICAgbGV0IGVuZCA9IGxpbmVWaWV3ID8gKGZvcndhcmQgPyBsaW5lVmlldy5wb3NBdEVuZCA6IGxpbmVWaWV3LnBvc0F0U3RhcnQpIDogKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS5mcm9tIDogbGluZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zKSwgZG9jVG9wID0gdmlldy5kb2N1bWVudFRvcDtcbiAgICBpZiAoc3RhcnRDb29yZHMpIHtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBzdGFydENvb3Jkcy5sZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBzdGFydFkgPSBkaXIgPCAwID8gc3RhcnRDb29yZHMudG9wIDogc3RhcnRDb29yZHMuYm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzdGFydFBvcyk7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gTWF0aC5taW4ocmVjdC5yaWdodCAtIHJlY3QubGVmdCwgdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggKiAoc3RhcnRQb3MgLSBsaW5lLmZyb20pKTtcbiAgICAgICAgc3RhcnRZID0gKGRpciA8IDAgPyBsaW5lLnRvcCA6IGxpbmUuYm90dG9tKSArIGRvY1RvcDtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVkR29hbCA9IHJlY3QubGVmdCArIGdvYWw7XG4gICAgbGV0IGRpc3QgPSBkaXN0YW5jZSAhPT0gbnVsbCAmJiBkaXN0YW5jZSAhPT0gdm9pZCAwID8gZGlzdGFuY2UgOiAodmlldy5kZWZhdWx0TGluZUhlaWdodCA+PiAxKTtcbiAgICBmb3IgKGxldCBleHRyYSA9IDA7OyBleHRyYSArPSAxMCkge1xuICAgICAgICBsZXQgY3VyWSA9IHN0YXJ0WSArIChkaXN0ICsgZXh0cmEpICogZGlyO1xuICAgICAgICBsZXQgcG9zID0gcG9zQXRDb29yZHModmlldywgeyB4OiByZXNvbHZlZEdvYWwsIHk6IGN1clkgfSwgZmFsc2UsIGRpcik7XG4gICAgICAgIGlmIChjdXJZIDwgcmVjdC50b3AgfHwgY3VyWSA+IHJlY3QuYm90dG9tIHx8IChkaXIgPCAwID8gcG9zIDwgc3RhcnRQb3MgOiBwb3MgPiBzdGFydFBvcykpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIHN0YXJ0LmFzc29jLCB1bmRlZmluZWQsIGdvYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBhdG9tcyA9IHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgYXRvbXMpIHtcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcy5mcm9tIC0gMSwgcG9zLmZyb20gKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5mcm9tID4gZnJvbSAmJiBwb3MuZnJvbSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIDEpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlZClcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxufVxuXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XG4gICAgICAgIC8vIE9uIGlPUywgc29tZSBrZXlzIG5lZWQgdG8gaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGhhcHBlblxuICAgICAgICAvLyAoYWZ0ZXIgd2hpY2ggd2UgcmV0cm9hY3RpdmVseSBoYW5kbGUgdGhlbSBhbmQgcmVzZXQgdGhlIERPTSkgdG9cbiAgICAgICAgLy8gYXZvaWQgbWVzc2luZyB1cCB0aGUgdmlydHVhbCBrZXlib2FyZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb250ZXh0TWVudSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuY3VzdG9tSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxuICAgICAgICAvLyBvZiBjaGFuZ2VzIG1hZGUgZHVyaW5nIHRoZSBjb21wb3NpdGlvbi4gVGhlIGNvdW50IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gYXZvaWQgdHJlYXRpbmcgdGhlIHN0YXJ0IHN0YXRlIG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIGFueVxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG5leHQgY2hhbmdlIHNob3VsZCBiZSBtYXJrZWQgYXMgc3RhcnRpbmcgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXG4gICAgICAgIC8vIGZpcnN0LCBmYWxzZSBtZWFucyBmaXJzdCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBmb3IgdGhpc1xuICAgICAgICAvLyBjb21wb3NpdGlvbilcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHx8IHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm11c3RGbHVzaE9ic2VydmVyKGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgICAgICB9LCBoYW5kbGVyT3B0aW9uc1t0eXBlXSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5jaHJvbWVfdmVyc2lvbiA9PSAxMDIpIHsgLy8gRklYTUUgcmVtb3ZlIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgICAgIC8vIE9uIENocm9tZSAxMDIsIHZpZXdwb3J0IHVwZGF0ZXMgc29tZWhvdyBzdG9wIHdoZWVsLWJhc2VkXG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcuIFR1cm5pbmcgb2ZmIHBvaW50ZXIgZXZlbnRzIGR1cmluZyB0aGUgc2Nyb2xsIHNlZW1zXG4gICAgICAgICAgICAvLyB0byBhdm9pZCB0aGUgaXNzdWUuXG4gICAgICAgICAgICB2aWV3LnNjcm9sbERPTS5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNocm9tZVNjcm9sbEhhY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmNocm9tZVNjcm9sbEhhY2spO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hyb21lU2Nyb2xsSGFjayA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnModmlldywgcGx1Z2lucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBoYW5kbGVycztcbiAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucylcbiAgICAgICAgICAgIGlmIChoYW5kbGVycyA9IChfYSA9IHBsdWdpbi51cGRhdGUodmlldykuc3BlYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzLnB1c2goeyBwbHVnaW46IHBsdWdpbi52YWx1ZSwgaGFuZGxlcnMgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5pbmRleE9mKHR5cGUpIDwgMCAmJiB0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkge1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJ1blNjcm9sbEhhbmRsZXJzKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQ7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiB0aGlzLmN1c3RvbUhhbmRsZXJzKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IHNldC5oYW5kbGVycy5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChzZXQucGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgRGF0ZS5ub3coKSA8IHRoaXMubGFzdEVzY1ByZXNzICsgMjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSh2aWV3KSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkodmlldykge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhYnJvd3Nlci5pb3MgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0IDwgMTAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG11c3RGbHVzaE9ic2VydmVyKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIGV2ZW50LmtleUNvZGUgIT0gMjI5O1xuICAgIH1cbiAgICBzdGFydE1vdXNlU2VsZWN0aW9uKG1vdXNlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBtb3VzZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdNb3ZlID0gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgJiYgZ2V0Q2xpY2tUeXBlKHN0YXJ0RXZlbnQpID09IDEgPyBudWxsIDogZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChzdGFydEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdFNlbGVjdCB8fCAhc2VsZWN0aW9uLmVxKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24pIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24ubWFpbi5hc3NvYyAhPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCAmJiB0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgKChjVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKSkgJiYgY1ZpZXcuaWdub3JlRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGhhbmRsZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBoYW5kbGVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJXHUyMDE0YWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlLnRvVGV4dChpbnB1dCk7XG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuZXZlcnkociA9PiByLmVtcHR5KSAmJiBsYXN0TGluZXdpc2VDb3B5ID09IHRleHQudG9TdHJpbmcoKTtcbiAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5wYXN0ZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgIH0pO1xufVxuaGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSBEYXRlLm5vdygpO1xuICAgIGVsc2UgaWYgKG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSAwO1xufTtcbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJPcHRpb25zLnRvdWNoc3RhcnQgPSBoYW5kbGVyT3B0aW9ucy50b3VjaG1vdmUgPSB7IHBhc3NpdmU6IHRydWUgfTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKSk7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmxldCBpbnNpZGVZID0gKHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbTtcbmxldCBpbnNpZGUgPSAoeCwgeSwgcmVjdCkgPT4gaW5zaWRlWSh5LCByZWN0KSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBiZXNpZGUgaXQuXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBpbnNpZGVZKHksIGJlZm9yZSkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBxdWVyeVBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBsYXN0ID0gc3RhcnQsIGxhc3RFdmVudCA9IGV2ZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXI7XG4gICAgICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGV2ZW50LmNsaWVudFggPT0gbGFzdEV2ZW50LmNsaWVudFggJiYgZXZlbnQuY2xpZW50WSA9PSBsYXN0RXZlbnQuY2xpZW50WSlcbiAgICAgICAgICAgICAgICBjdXIgPSBsYXN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyID0gbGFzdCA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgc3RhcnRTZWwucmFuZ2VzLmxlbmd0aCA+IDEgJiYgc3RhcnRTZWwucmFuZ2VzLnNvbWUociA9PiByLmVxKHJhbmdlKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVJhbmdlKHN0YXJ0U2VsLCByYW5nZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKHNlbCwgcmFuZ2UpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoc2VsLnJhbmdlc1tpXS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbiB9IH0gPSB2aWV3LnN0YXRlO1xuICAgIGxldCB7IG1vdXNlU2VsZWN0aW9uIH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgaWYgKG1vdXNlU2VsZWN0aW9uKVxuICAgICAgICBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IG1haW47XG4gICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdmlldy5zdGF0ZS5zbGljZURvYyhtYWluLmZyb20sIG1haW4udG8pKTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCBkaXJlY3QpIHtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZHJvcFBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCB7IG1vdXNlU2VsZWN0aW9uIH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBtb3VzZVNlbGVjdGlvbiAmJiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyAmJiBtb3VzZVNlbGVjdGlvbi5kcmFnTW92ZSA/XG4gICAgICAgIHsgZnJvbTogbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcuZnJvbSwgdG86IG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nLnRvIH0gOiBudWxsO1xuICAgIGxldCBpbnMgPSB7IGZyb206IGRyb3BQb3MsIGluc2VydDogdGV4dCB9O1xuICAgIGxldCBjaGFuZ2VzID0gdmlldy5zdGF0ZS5jaGFuZ2VzKGRlbCA/IFtkZWwsIGluc10gOiBpbnMpO1xuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgLTEpLCBoZWFkOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAxKSB9LFxuICAgICAgICB1c2VyRXZlbnQ6IGRlbCA/IFwibW92ZS5kcm9wXCIgOiBcImlucHV0LmRyb3BcIlxuICAgIH0pO1xufVxuaGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7IC8vIEZvciBhIGZpbGUgZHJvcCwgcmVhZCB0aGUgZmlsZSdzIHRleHQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCB0ZXh0ID0gQXJyYXkoZmlsZXMubGVuZ3RoKSwgcmVhZCA9IDA7XG4gICAgICAgIGxldCBmaW5pc2hGaWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCsrcmVhZCA9PSBmaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQuZmlsdGVyKHMgPT4gcyAhPSBudWxsKS5qb2luKHZpZXcuc3RhdGUubGluZUJyZWFrKSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZpbmlzaEZpbGU7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghL1tcXHgwMC1cXHgwOFxceDBlLVxceDFmXXsyfS8udGVzdChyZWFkZXIucmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgZmluaXNoRmlsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKSwgdHJ1ZSk7XG4gICAgfVxufTtcbmhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlUGFzdGUodmlldyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogY29udGVudC5qb2luKHN0YXRlLmxpbmVCcmVhayksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm47XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgdGV4dCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09IFwiY3V0XCIgJiYgIXZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiZGVsZXRlLmN1dFwiXG4gICAgICAgIH0pO1xufTtcbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuaGFzRm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZClcbiAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICB9LCAxMCk7XG59XG5oYW5kbGVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24sIG1vdmUgaXQgYmFjayB0byB3aGVyZSBpdCB3YXNcbiAgICBpZiAoIXZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAmJiAodmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgfHwgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0KSkge1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xuaGFuZGxlcnMuYmx1ciA9IHZpZXcgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbmhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBoYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9PSBudWxsKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xuaGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIEZvcmNlIHRoZSBjb21wb3NpdGlvbiBzdGF0ZSB0byBiZSBjbGVhcmVkIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwICYmIHZpZXcuZG9jVmlldy5jb21wb3NpdGlvbkRlY28uc2l6ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICB9LCA1MCk7XG59O1xuaGFuZGxlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdENvbnRleHRNZW51ID0gRGF0ZS5ub3coKTtcbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICAvLyBCZWNhdXNlIENocm9tZSBBbmRyb2lkIGRvZXNuJ3QgZmlyZSB1c2VmdWwga2V5IGV2ZW50cywgdXNlXG4gICAgLy8gYmVmb3JlaW5wdXQgdG8gZGV0ZWN0IGJhY2tzcGFjZSAoYW5kIHBvc3NpYmx5IGVudGVyIGFuZCBkZWxldGUsXG4gICAgLy8gYnV0IHRob3NlIHVzdWFsbHkgZG9uJ3QgZXZlbiBzZWVtIHRvIGZpcmUgYmVmb3JlaW5wdXQgZXZlbnRzIGF0XG4gICAgLy8gdGhlIG1vbWVudCkgYW5kIGZha2UgYSBrZXkgZXZlbnQgZm9yIGl0LlxuICAgIC8vXG4gICAgLy8gKHByZXZlbnREZWZhdWx0IG9uIGJlZm9yZWlucHV0LCB0aG91Z2ggc3VwcG9ydGVkIGluIHRoZSBzcGVjLFxuICAgIC8vIHNlZW1zIHRvIGRvIG5vdGhpbmcgYXQgYWxsIG9uIENocm9tZSkuXG4gICAgbGV0IHBlbmRpbmc7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCAmJiAocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5pbnB1dFR5cGUgPT0gZXZlbnQuaW5wdXRUeXBlKSkpIHtcbiAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkocGVuZGluZy5rZXksIHBlbmRpbmcua2V5Q29kZSk7XG4gICAgICAgIGlmIChwZW5kaW5nLmtleSA9PSBcIkJhY2tzcGFjZVwiIHx8IHBlbmRpbmcua2V5ID09IFwiRGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydFZpZXdIZWlnaHQgPSAoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIEJhY2tzcGFjaW5nIG5lYXIgdW5lZGl0YWJsZSBub2RlcyBvbiBDaHJvbWUgQW5kcm9pZCBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXMgdGhlIHZpcnR1YWwga2V5Ym9hcmQuIFRoaXMgdHJpZXMgdG8gY3J1ZGVseSBkZXRlY3RcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFuZCByZWZvY3VzIHRvIGdldCBpdCBiYWNrLlxuICAgICAgICAgICAgICAgIGlmICgoKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMCkgPiBzdGFydFZpZXdIZWlnaHQgKyAxMCAmJiB2aWV3Lmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbmNsYXNzIEhlaWdodE9yYWNsZSB7XG4gICAgY29uc3RydWN0b3IobGluZVdyYXBwaW5nKSB7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmRvYyA9IFRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSA3O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICAgICAgLy8gVXNlZCB0byB0cmFjaywgZHVyaW5nIHVwZGF0ZUhlaWdodCwgaWYgYW55IGFjdHVhbCBoZWlnaHRzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGhlaWdodEZvckdhcChmcm9tLCB0bykge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmRvYy5saW5lQXQodG8pLm51bWJlciAtIHRoaXMuZG9jLmxpbmVBdChmcm9tKS5udW1iZXIgKyAxO1xuICAgICAgICBpZiAodGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICBsaW5lcyArPSBNYXRoLmNlaWwoKCh0byAtIGZyb20pIC0gKGxpbmVzICogdGhpcy5saW5lTGVuZ3RoICogMC41KSkgLyB0aGlzLmxpbmVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgdHlwZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICBsZXQgZGV0YWlsID0gKEFycmF5LmlzQXJyYXkodGhpcy50eXBlKSA/IHRoaXMudHlwZSA6IFt0aGlzXSlcbiAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuaXNBcnJheShvdGhlci50eXBlKSA/IG90aGVyLnR5cGUgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBkZXRhaWwpO1xuICAgIH1cbn1cbnZhciBRdWVyeVR5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChRdWVyeVR5cGUpIHtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NcIl0gPSAwXSA9IFwiQnlQb3NcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlIZWlnaHRcIl0gPSAxXSA9IFwiQnlIZWlnaHRcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NOb0hlaWdodFwiXSA9IDJdID0gXCJCeVBvc05vSGVpZ2h0XCI7XG5yZXR1cm4gUXVlcnlUeXBlfSkoUXVlcnlUeXBlIHx8IChRdWVyeVR5cGUgPSB7fSkpO1xuY29uc3QgRXBzaWxvbiA9IDFlLTM7XG5jbGFzcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvdmVyZWRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB0aGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgZmxhZ3MgPSAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIGdldCBvdXRkYXRlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBGbGFnLk91dGRhdGVkICovKSA+IDA7IH1cbiAgICBzZXQgb3V0ZGF0ZWQodmFsdWUpIHsgdGhpcy5mbGFncyA9ICh2YWx1ZSA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApIHwgKHRoaXMuZmxhZ3MgJiB+MiAvKiBGbGFnLk91dGRhdGVkICovKTsgfVxuICAgIHNldEhlaWdodChvcmFjbGUsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNlIGNhc2UgaXMgdG8gcmVwbGFjZSBhIGxlYWYgbm9kZSwgd2hpY2ggc2ltcGx5IGJ1aWxkcyBhIHRyZWVcbiAgICAvLyBmcm9tIHRoZSBuZXcgbm9kZXMgYW5kIHJldHVybnMgdGhhdCAoSGVpZ2h0TWFwQnJhbmNoIGFuZFxuICAgIC8vIEhlaWdodE1hcEdhcCBvdmVycmlkZSB0aGlzIHRvIGFjdHVhbGx5IHVzZSBmcm9tL3RvKVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cbiAgICBkZWNvbXBvc2VMZWZ0KF90bywgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgZGVjb21wb3NlUmlnaHQoX2Zyb20sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGFwcGx5Q2hhbmdlcyhkZWNvcmF0aW9ucywgb2xkRG9jLCBvcmFjbGUsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0LnRvID49IHRvQSA/IHN0YXJ0IDogbWUubGluZUF0KHRvQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9sZERvYywgMCwgMCk7XG4gICAgICAgICAgICB0b0IgKz0gZW5kLnRvIC0gdG9BO1xuICAgICAgICAgICAgdG9BID0gZW5kLnRvO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIHN0YXJ0LmZyb20gPD0gY2hhbmdlc1tpIC0gMV0udG9BKSB7XG4gICAgICAgICAgICAgICAgZnJvbUEgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQTtcbiAgICAgICAgICAgICAgICBmcm9tQiA9IGNoYW5nZXNbaSAtIDFdLmZyb21CO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCBzdGFydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9sZERvYywgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQiArPSBzdGFydC5mcm9tIC0gZnJvbUE7XG4gICAgICAgICAgICBmcm9tQSA9IHN0YXJ0LmZyb207XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBOb2RlQnVpbGRlci5idWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tQiwgdG9CKTtcbiAgICAgICAgICAgIG1lID0gbWUucmVwbGFjZShmcm9tQSwgdG9BLCBub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9kb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIGxpbmVBdChfdmFsdWUsIF90eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQoMCwgZG9jLCB0b3AsIG9mZnNldCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIHRvID49IG9mZnNldClcbiAgICAgICAgICAgIGYodGhpcy5ibG9ja0F0KDAsIGRvYywgdG9wLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgX2ZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgQmxvY2tUeXBlLlRleHQpO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IDA7IC8vIEFtb3VudCBvZiBjb2xsYXBzZWQgY29udGVudCBpbiB0aGUgbGluZVxuICAgICAgICB0aGlzLndpZGdldEhlaWdodCA9IDA7IC8vIE1heGltdW0gaW5saW5lIHdpZGdldCBoZWlnaHRcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgbGluZXMoZG9jLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IGRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0OiB0aGlzLmhlaWdodCAvIChsYXN0TGluZSAtIGZpcnN0TGluZSArIDEpIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gbGluZUhlaWdodCkpKTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBkb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBsaW5lSGVpZ2h0ICogbGluZSwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpO1xuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIGRvYywgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgZG9jLCB0b3AsIG9mZnNldCk7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGgsIG51bWJlciB9ID0gZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgbGluZUhlaWdodCAqIChudW1iZXIgLSBmaXJzdExpbmUpLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGluZUhlaWdodCB9ID0gdGhpcy5saW5lcyhkb2MsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KGZyb20sIG9mZnNldCksIGVuZCA9IE1hdGgubWluKG9mZnNldCArIHRoaXMubGVuZ3RoLCB0byk7IHBvcyA8PSBlbmQ7KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodCAqIChsaW5lLm51bWJlciAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgdG9wLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCkpO1xuICAgICAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCAtIHRvO1xuICAgICAgICBpZiAoYWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBuZXcgSGVpZ2h0TWFwR2FwKGxhc3QubGVuZ3RoICsgYWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChhZnRlciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA+IDApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzWzBdID0gbmV3IEhlaWdodE1hcEdhcChmcm9tICsgZmlyc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy51bnNoaWZ0KG5ldyBIZWlnaHRNYXBHYXAoZnJvbSAtIDEpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBIZWlnaHRNYXBHYXAodG8gLSAxKSwgbnVsbCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKHRoaXMubGVuZ3RoIC0gZnJvbSAtIDEpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHBhcnQgb2YgdGhpcyBnYXAgd2l0aCBtZWFzdXJlZCBsaW5lcy4gV2Uga25vdyB0aGVyZVxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgd2lkZ2V0cyBvciBjb2xsYXBzZWQgcmFuZ2VzIGluIHRob3NlIGxpbmVzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGV5IHdvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBoZWlnaHRtYXAgKGdhcHNcbiAgICAgICAgICAgIC8vIG9ubHkgY29udGFpbiBwbGFpbiB0ZXh0KS5cbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdLCBwb3MgPSBNYXRoLm1heChvZmZzZXQsIG1lYXN1cmVkLmZyb20pLCBzaW5nbGVIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIGxldCB3YXNDaGFuZ2VkID0gb3JhY2xlLmhlaWdodENoYW5nZWQ7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gd2FzQ2hhbmdlZCB8fCBzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMubGluZXMob3JhY2xlLmRvYywgb2Zmc2V0KS5saW5lSGVpZ2h0KSA+PSBFcHNpbG9uO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG9yYWNsZS5oZWlnaHRGb3JHYXAob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBnYXAoJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwQnJhbmNoIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCBicmssIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlZnQubGVuZ3RoICsgYnJrICsgcmlnaHQubGVuZ3RoLCBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCwgYnJrIHwgKGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGJyZWFrKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDEgLyogRmxhZy5CcmVhayAqLzsgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBtaWQgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaGVpZ2h0IDwgbWlkID8gdGhpcy5sZWZ0LmJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmJsb2NrQXQoaGVpZ2h0LCBkb2MsIG1pZCwgb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWspO1xuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIGRvYywgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgbGV0IGxlZnQgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodCA/IHZhbHVlIDwgcmlnaHRUb3AgOiB2YWx1ZSA8IHJpZ2h0T2Zmc2V0O1xuICAgICAgICBsZXQgYmFzZSA9IGxlZnQgPyB0aGlzLmxlZnQubGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayB8fCAobGVmdCA/IGJhc2UudG8gPCByaWdodE9mZnNldCA6IGJhc2UuZnJvbSA+IHJpZ2h0T2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgc3ViUXVlcnkgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0ID8gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgOiBRdWVyeVR5cGUuQnlQb3M7XG4gICAgICAgIGlmIChsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuam9pbih0aGlzLnJpZ2h0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgZG9jLCB0b3AsIG9mZnNldCkuam9pbihiYXNlKTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIGRvYywgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmICh0byA+PSByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gdGhpcy5saW5lQXQocmlnaHRPZmZzZXQsIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCB0b3AsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IG1pZC5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCBtaWQuZnJvbSAtIDEsIGRvYywgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKG1pZC50byA+PSBmcm9tICYmIG1pZC5mcm9tIDw9IHRvKVxuICAgICAgICAgICAgICAgIGYobWlkKTtcbiAgICAgICAgICAgIGlmICh0byA+IG1pZC50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKG1pZC50byArIDEsIHRvLCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRvIDwgcmlnaHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdC5yZXBsYWNlKGZyb20sIHRvLCBub2RlcyksIHRoaXMucmlnaHQpO1xuICAgICAgICBpZiAoZnJvbSA+IHRoaXMubGVmdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQsIHRoaXMucmlnaHQucmVwbGFjZShmcm9tIC0gcmlnaHRTdGFydCwgdG8gLSByaWdodFN0YXJ0LCBub2RlcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlTGVmdChmcm9tLCByZXN1bHQpO1xuICAgICAgICBsZXQgbGVmdCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpXG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgbGVmdCAtIDEpO1xuICAgICAgICBpZiAodG8gPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlUmlnaHQodG8sIHJlc3VsdCk7XG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihyZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgICAgICBpZiAodG8gPD0gbGVmdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIGlmICh0byA+PSBsZWZ0KVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA+IGxlZnQpXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmRlY29tcG9zZUxlZnQodG8gLSBsZWZ0LCByZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoLCByaWdodCA9IGxlZnQgKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAoZnJvbSA+PSByaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmRlY29tcG9zZVJpZ2h0KGZyb20gLSByaWdodCwgcmVzdWx0KTtcbiAgICAgICAgaWYgKGZyb20gPCBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5sZWZ0LmRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrICYmIGZyb20gPCByaWdodClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgYmFsYW5jZWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQuc2l6ZSA+IDIgKiByaWdodC5zaXplIHx8IHJpZ2h0LnNpemUgPiAyICogbGVmdC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZih0aGlzLmJyZWFrID8gW2xlZnQsIG51bGwsIHJpZ2h0XSA6IFtsZWZ0LCByaWdodF0pO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKVxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMub3JhY2xlLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrKG5ldyBIZWlnaHRNYXBCbG9jayhsZW4sIGhlaWdodCwgZGVjby50eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgaGVpZ2h0ID49IHJlbGV2YW50V2lkZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lRGVjbyhoZWlnaHQsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChibG9jayk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSlcbiAgICAgICAgICAgIHRoaXMuY292ZXJpbmcgPSBibG9jaztcbiAgICB9XG4gICAgYWRkTGluZURlY28oaGVpZ2h0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHBhcmVudFJlY3QuYm90dG9tIDogTWF0aC5taW4oYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBzdHlsZS5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgfHwgc3R5bGUucG9zaXRpb24gPT0gXCJmaXhlZFwiID8gZWx0Lm9mZnNldFBhcmVudCA6IGVsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0LCByaWdodDogTWF0aC5tYXgobGVmdCwgcmlnaHQpIC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IE1hdGgubWF4KHRvcCwgYm90dG9tKSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG5mdW5jdGlvbiBmdWxsUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBwYWRkaW5nVG9wLCBib3R0b206IHJlY3QuYm90dG9tIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXG4vLyBsaW5lcyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBhcyBhIGtsdWRnZSB0byBrZWVwIHRoZSBlZGl0b3Jcbi8vIHJlc3BvbnNpdmUgd2hlbiBhIHJpZGljdWxvdXNseSBsb25nIGxpbmUgaXMgbG9hZGVkIGludG8gaXQuXG5jbGFzcyBMaW5lR2FwIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc2l6ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnQSA9IGFbaV0sIGdCID0gYltpXTtcbiAgICAgICAgICAgIGlmIChnQS5mcm9tICE9IGdCLmZyb20gfHwgZ0EudG8gIT0gZ0IudG8gfHwgZ0Euc2l6ZSAhPSBnQi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyh3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgTGluZUdhcFdpZGdldCh0aGlzLnNpemUsIHdyYXBwaW5nKSB9KS5yYW5nZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIExpbmVHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCB2ZXJ0aWNhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5zaXplID09IHRoaXMuc2l6ZSAmJiBvdGhlci52ZXJ0aWNhbCA9PSB0aGlzLnZlcnRpY2FsOyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSBcIjJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsID8gdGhpcy5zaXplIDogLTE7IH1cbn1cbmNsYXNzIFZpZXdTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29udGVudERPTS1sb2NhbCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCwgdG9wOiAwLCBib3R0b206IDAgfTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IDA7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBCcmllZmx5IHNldCB0byB0cnVlIHdoZW4gcHJpbnRpbmcsIHRvIGRpc2FibGUgdmlld3BvcnQgbGltaXRpbmdcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBGbGFnIHNldCB3aGVuIGVkaXRvciBjb250ZW50IHdhcyByZWRyYXduLCBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgc3RhZ2Uga25vd3MgaXQgbXVzdCByZWFkIERPTSBsYXlvdXRcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBudWxsKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZS5kb2MsIHRoaXMuaGVpZ2h0TWFwLCB0aGlzLnZpZXdwb3J0cyk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdwb3J0TGluZXMoKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnRMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodE1hcC5mb3JFYWNoTGluZSh0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHRoaXMuc3RhdGUuZG9jLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaCh0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gYmxvY2sgOiBzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MsIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIGhlaWdodENoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRNYXAuaGVpZ2h0ICE9IHByZXZIZWlnaHQpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdXBkYXRlTGluZXMgPSAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8XG4gICAgICAgICAgICB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHVwZGF0ZUxpbmVzKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb20uY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSBkb20uY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIC8vIFZlcnRpY2FsIHBhZGRpbmdcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwLCBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcldpZHRoICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBpeGVsIHZpZXdwb3J0XG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gKHRoaXMucHJpbnRpbmcgPyBmdWxsUGl4ZWxSYW5nZSA6IHZpc2libGVQaXhlbFJhbmdlKShkb20sIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgICAgIGxldCBkVG9wID0gcGl4ZWxWaWV3cG9ydC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBkQm90dG9tID0gcGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSBwaXhlbFZpZXdwb3J0O1xuICAgICAgICBsZXQgaW5WaWV3ID0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSA+IHRoaXMucGl4ZWxWaWV3cG9ydC50b3AgJiYgdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ID4gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQ7XG4gICAgICAgIGlmIChpblZpZXcgIT0gdGhpcy5pblZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gaW5WaWV3O1xuICAgICAgICAgICAgaWYgKGluVmlldylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmluVmlldyAmJiAhdGhpcy5zY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IGRvbS5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykpXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGggfSA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbGluZUhlaWdodCA+IDAgJiYgb3JhY2xlLnJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgdnAgb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0cyA9IHZwLmZyb20gPT0gdGhpcy52aWV3cG9ydC5mcm9tID8gbGluZUhlaWdodHMgOiB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2cCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSAocmVmcmVzaCA/IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUsIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldKSA6IHRoaXMuaGVpZ2h0TWFwKS51cGRhdGVIZWlnaHQob3JhY2xlLCAwLCByZWZyZXNoLCBuZXcgTWVhc3VyZWRIZWlnaHRzKHZwLmZyb20sIGhlaWdodHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmFjbGUuaGVpZ2h0Q2hhbmdlZClcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICgocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgfHwgdmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHMocmVmcmVzaCA/IFtdIDogdGhpcy5saW5lR2FwcywgdmlldykpO1xuICAgICAgICByZXN1bHQgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jKSB7XG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSBpbiB0aGUgcmVhZCBzdGFnZSwgYmVjYXVzZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gdG8gYSBsaW5lIGVuZCBpcyBnb2luZyB0byB0cmlnZ2VyIGEgbGF5b3V0IGFueXdheSwgc28gaXRcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGEgcHVyZSB3cml0ZS4gSXQgc2hvdWxkIGJlIHJhcmUgdGhhdCBpdCBkb2VzIGFueVxuICAgICAgICAgICAgLy8gd3JpdGluZy5cbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy5lbmZvcmNlQ3Vyc29yQXNzb2MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZVRvcCgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7IH1cbiAgICBnZXQgdmlzaWJsZUJvdHRvbSgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSk7IH1cbiAgICBnZXRWaWV3cG9ydChiaWFzLCBzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGRpdmlkZSBWUC5NYXJnaW4gYmV0d2VlbiB0aGUgdG9wIGFuZCB0aGVcbiAgICAgICAgLy8gYm90dG9tLCBkZXBlbmRpbmcgb24gdGhlIGJpYXMgKHRoZSBjaGFuZ2UgaW4gdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGxhc3QgdXBkYXRlKS4gSXQnbGwgaG9sZCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgbGV0IG1hcmdpblRvcCA9IDAuNSAtIE1hdGgubWF4KC0wLjUsIE1hdGgubWluKDAuNSwgYmlhcyAvIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMikpO1xuICAgICAgICBsZXQgbWFwID0gdGhpcy5oZWlnaHRNYXAsIGRvYyA9IHRoaXMuc3RhdGUuZG9jLCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIGRvYywgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwb3NpdGlvbnMgaW4gdGhlIHZpZXdwb3J0IHdoZXJlIHRoZSBzdGFydCBvciBlbmQgb2YgYVxuICAgIC8vIGxpbmUgc2hvdWxkIGJlIGhpZGRlbiwgdHJ5aW5nIHRvIHJldXNlIGV4aXN0aW5nIGxpbmUgZ2FwcyB3aGVuXG4gICAgLy8gYXBwcm9wcmlhdGUgdG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVkcmF3cy5cbiAgICAvLyBVc2VzIGNydWRlIGNoYXJhY3Rlci1jb3VudGluZyBmb3IgdGhlIHBvc2l0aW9uaW5nIGFuZCBzaXppbmcsXG4gICAgLy8gc2luY2UgYWN0dWFsIERPTSBjb29yZGluYXRlcyBhcmVuJ3QgYWx3YXlzIGF2YWlsYWJsZSBhbmRcbiAgICAvLyBwcmVkaWN0YWJsZS4gUmVsaWVzIG9uIGdlbmVyb3VzIG1hcmdpbnMgKHNlZSBMRy5NYXJnaW4pIHRvIGhpZGVcbiAgICAvLyB0aGUgYXJ0aWZhY3RzIHRoaXMgbWlnaHQgcHJvZHVjZSBmcm9tIHRoZSB1c2VyLlxuICAgIGVuc3VyZUxpbmVHYXBzKGN1cnJlbnQsIG1heU1lYXN1cmUpIHtcbiAgICAgICAgbGV0IHdyYXBwaW5nID0gdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nO1xuICAgICAgICBsZXQgbWFyZ2luID0gd3JhcHBpbmcgPyAxMDAwMCAvKiBMRy5NYXJnaW5XcmFwICovIDogMjAwMCAvKiBMRy5NYXJnaW4gKi8sIGhhbGZNYXJnaW4gPSBtYXJnaW4gPj4gMSwgZG91YmxlTWFyZ2luID0gbWFyZ2luIDw8IDE7XG4gICAgICAgIC8vIFRoZSBub24td3JhcHBpbmcgbG9naWMgd29uJ3Qgd29yayBhdCBhbGwgaW4gcHJlZG9taW5hbnRseSByaWdodC10by1sZWZ0IHRleHQuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgJiYgIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBsZXQgYWRkR2FwID0gKGZyb20sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpID0+IHtcbiAgICAgICAgICAgIGlmICh0byAtIGZyb20gPCBoYWxmTWFyZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbi5tYWluLCBhdm9pZCA9IFtzZWwuZnJvbV07XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSlcbiAgICAgICAgICAgICAgICBhdm9pZC5wdXNoKHNlbC50byk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgYXZvaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAoZnJvbSwgcG9zIC0gMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAocG9zICsgMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCB0bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnYXAgPSBmaW5kKGN1cnJlbnQsIGdhcCA9PiBnYXAuZnJvbSA+PSBsaW5lLmZyb20gJiYgZ2FwLnRvIDw9IGxpbmUudG8gJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYXAuZnJvbSAtIGZyb20pIDwgaGFsZk1hcmdpbiAmJiBNYXRoLmFicyhnYXAudG8gLSB0bykgPCBoYWxmTWFyZ2luICYmXG4gICAgICAgICAgICAgICAgIWF2b2lkLnNvbWUocG9zID0+IGdhcC5mcm9tIDwgcG9zICYmIGdhcC50byA+IHBvcykpO1xuICAgICAgICAgICAgaWYgKCFnYXApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBkb3duLCBzbmFwIGdhcCBlbmRzIHRvIGxpbmUgc3RhcnRzIHRvIGF2b2lkIHNoaWZ0cyBpbiB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIGlmICh0byA8IGxpbmUudG8gJiYgbWF5TWVhc3VyZSAmJiB3cmFwcGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlNZWFzdXJlLnZpc2libGVSYW5nZXMuc29tZShyID0+IHIuZnJvbSA8PSB0byAmJiByLnRvID49IHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbWF5TWVhc3VyZS5tb3ZlVG9MaW5lQm91bmRhcnkoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0byksIGZhbHNlLCB0cnVlKS5oZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlld3BvcnRMaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0cnVjdHVyZSA9IGxpbmVTdHJ1Y3R1cmUobGluZS5mcm9tLCBsaW5lLnRvLCB0aGlzLnN0YXRlRGVjbyk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0IC0gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQpIC8gMiArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld0Zyb20gPiBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgYWRkR2FwKGxpbmUuZnJvbSwgdmlld0Zyb20sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICBpZiAodmlld1RvIDwgbGluZS50bylcbiAgICAgICAgICAgICAgICBhZGRHYXAodmlld1RvLCBsaW5lLnRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSByYW5nZXMubGVuZ3RoICE9IHRoaXMudmlzaWJsZVJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChyLCBpKSA9PiByLmZyb20gIT0gcmFuZ2VzW2ldLmZyb20gfHwgci50byAhPSByYW5nZXNbaV0udG8pO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkID8gNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovIDogMDtcbiAgICB9XG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiAocG9zID49IHRoaXMudmlld3BvcnQuZnJvbSAmJiBwb3MgPD0gdGhpcy52aWV3cG9ydC50byAmJiB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChiID0+IGIuZnJvbSA8PSBwb3MgJiYgYi50byA+PSBwb3MpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQocG9zLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLnN0YXRlLmRvYywgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGdldCBkb2NIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jSGVpZ2h0ICsgdGhpcy5wYWRkaW5nVG9wICsgdGhpcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGVEZWNvKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBwb3MgPSBmcm9tLCB0b3RhbCA9IDA7XG4gICAgUmFuZ2VTZXQuc3BhbnMoc3RhdGVEZWNvLCBmcm9tLCB0bywge1xuICAgICAgICBzcGFuKCkgeyB9LFxuICAgICAgICBwb2ludChmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZnJvbSAtIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgfSwgMjApOyAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gY29sbGFwc2VkIHJhbmdlcyBvZiBhIHNpZ25pZmljYW50IHNpemVcbiAgICBpZiAocG9zIDwgdG8pIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvIH0pO1xuICAgICAgICB0b3RhbCArPSB0byAtIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHsgdG90YWwsIHJhbmdlcyB9O1xufVxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xuICAgIGlmIChyYXRpbyA8PSAwKVxuICAgICAgICByZXR1cm4gcmFuZ2VzWzBdLmZyb207XG4gICAgaWYgKHJhdGlvID49IDEpXG4gICAgICAgIHJldHVybiByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgIGxldCBkaXN0ID0gTWF0aC5mbG9vcih0b3RhbCAqIHJhdGlvKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldLCBzaXplID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGlzdCA8PSBzaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xuICAgICAgICBkaXN0IC09IHNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgcG9zKSB7XG4gICAgbGV0IGNvdW50ZWQgPSAwO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XG4gICAgICAgIGlmIChwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgIGNvdW50ZWQgKz0gcG9zIC0gZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZWQgKz0gdG8gLSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlZCAvIHN0cnVjdHVyZS50b3RhbDtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcbiAgICBmb3IgKGxldCB2YWwgb2YgYXJyYXkpXG4gICAgICAgIGlmIChmKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XG4vLyB0aGUgRE9NIGNhbiBoYW5kbGUuXG5jb25zdCBJZFNjYWxlciA9IHtcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIGZyb21ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBzY2FsZTogMVxufTtcbi8vIFdoZW4gdGhlIGhlaWdodCBpcyB0b28gYmlnICg+IFZQLk1heERPTUhlaWdodCksIHNjYWxlIGRvd24gdGhlXG4vLyByZWdpb25zIG91dHNpZGUgdGhlIHZpZXdwb3J0cyBzbyB0aGF0IHRoZSB0b3RhbCBoZWlnaHQgaXNcbi8vIFZQLk1heERPTUhlaWdodC5cbmNsYXNzIEJpZ1NjYWxlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBoZWlnaHRNYXAsIHZpZXdwb3J0cykge1xuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wID0gaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgMCwgMCkudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKS5ib3R0b207XG4gICAgICAgICAgICB2cEhlaWdodCArPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdG9wLCBib3R0b20sIGRvbVRvcDogMCwgZG9tQm90dG9tOiAwIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gKDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovIC0gdnBIZWlnaHQpIC8gKGhlaWdodE1hcC5oZWlnaHQgLSB2cEhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSBvYmouZG9tQm90dG9tID0gb2JqLmRvbVRvcCArIChvYmouYm90dG9tIC0gb2JqLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gb2JqLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC50b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAuZG9tVG9wICsgKG4gLSB2cC50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbURPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC5kb21Ub3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyAobiAtIGRvbUJhc2UpIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAudG9wICsgKG4gLSB2cC5kb21Ub3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY2FsZUJsb2NrKGJsb2NrLCBzY2FsZXIpIHtcbiAgICBpZiAoc2NhbGVyLnNjYWxlID09IDEpXG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICBsZXQgYlRvcCA9IHNjYWxlci50b0RPTShibG9jay50b3ApLCBiQm90dG9tID0gc2NhbGVyLnRvRE9NKGJsb2NrLmJvdHRvbSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oYmxvY2suZnJvbSwgYmxvY2subGVuZ3RoLCBiVG9wLCBiQm90dG9tIC0gYlRvcCwgQXJyYXkuaXNBcnJheShibG9jay50eXBlKSA/IGJsb2NrLnR5cGUubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLnR5cGUpO1xufVxuXG5jb25zdCB0aGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiBzdHJzID0+IHN0cnMuam9pbihcIiBcIikgfSk7XG5jb25zdCBkYXJrVGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XG5jb25zdCBiYXNlVGhlbWVJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VMaWdodElEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZURhcmtJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG5jb25zdCBsaWdodERhcmtJRHMgPSB7IFwiJmxpZ2h0XCI6IFwiLlwiICsgYmFzZUxpZ2h0SUQsIFwiJmRhcmtcIjogXCIuXCIgKyBiYXNlRGFya0lEIH07XG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xuICAgIHJldHVybiBuZXcgU3R5bGVNb2R1bGUoc3BlYywge1xuICAgICAgICBmaW5pc2goc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtID09IFwiJlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgc2VsZWN0b3I6ICR7bX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVzW21dO1xuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL2J1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwge1xuICAgIFwiJi5jbS1lZGl0b3JcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIixcbiAgICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIixcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA0cHhcIlxuICAgIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTGF5ZXJcIjoge1xuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIlxuICAgIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgekluZGV4OiAxMDAsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiIzQ0NFwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRhYlwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gICAgfSxcbiAgICBcIi5jbS13aWRnZXRCdWZmZXJcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY2xhc3MgRE9NQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgICAgICB0aGlzLnR5cGVPdmVyID0gdHlwZU92ZXI7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHsgaW1wcmVjaXNlSGVhZDogaUhlYWQsIGltcHJlY2lzZUFuY2hvcjogaUFuY2hvciB9ID0gdmlldy5kb2NWaWV3O1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSAmJiBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSB2aWV3LmRvY1ZpZXcuZG9tQm91bmRzQXJvdW5kKHN0YXJ0LCBlbmQsIDApKSkge1xuICAgICAgICAgICAgbGV0IHNlbFBvaW50cyA9IGlIZWFkIHx8IGlBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldy5zdGF0ZSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gcmVhZGVyLnRleHQ7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHNlbGVjdGlvbkZyb21Qb2ludHMoc2VsUG9pbnRzLCB0aGlzLmJvdW5kcy5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5hbmNob3JOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBsZXQgeyBuZXdTZWwgfSA9IGRvbUNoYW5nZSwgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9tQ2hhbmdlLmJvdW5kcztcbiAgICAgICAgbGV0IHByZWZlcnJlZFBvcyA9IHNlbC5mcm9tLCBwcmVmZXJyZWRTaWRlID0gbnVsbDtcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXG4gICAgICAgIC8vIEFuZHJvaWQsIHdoZW4gc29tZXRoaW5nIHdhcyBkZWxldGVkKVxuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID09PSA4ICYmIHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA+IERhdGUubm93KCkgLSAxMDAgfHxcbiAgICAgICAgICAgIGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyB8fCAhdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgbmV3U2VsLm1haW4uZXEoc2VsKSkpIHtcbiAgICAgICAgbmV3U2VsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcbiAgICAgICAgL15cXC4gPyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSkge1xuICAgICAgICAvLyBEZXRlY3QgaW5zZXJ0LXBlcmlvZC1vbi1kb3VibGUtc3BhY2UgTWFjIGFuZCBBbmRyb2lkIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cbiAgICAgICAgaWYgKG5ld1NlbCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAyKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyLmNocm9tZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkICYmXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGlmIHlvdSBpbnNlcnQgYSBzcGFjZSBhdCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkXG4gICAgICAgIC8vIGxpbmUsIGl0IHdpbGwgYWN0dWFsbHkgaW5zZXJ0IGEgbmV3bGluZSBhbmQgYSBzcGFjZSwgY2F1c2luZyBhXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcbiAgICAgICAgaWYgKG5ld1NlbClcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkodmlldykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChpbnB1dEhhbmRsZXIpLnNvbWUoaCA9PiBoKHZpZXcsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8sIHRleHQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZysrO1xuICAgICAgICBsZXQgdHI7XG4gICAgICAgIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXG4gICAgICAgICAgICAoIW5ld1NlbCB8fCBuZXdTZWwubWFpbi5lbXB0eSAmJiBuZXdTZWwubWFpbi5mcm9tID09IGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgpICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsLnRvID4gY2hhbmdlLnRvID8gc3RhcnRTdGF0ZS5zbGljZURvYyhjaGFuZ2UudG8sIHNlbC50bykgOiBcIlwiO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgIXN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uZXEobmV3U2VsLm1haW4pICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBuZXdTZWwubWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhcHBseSBhIGNvbXBvc2l0aW9uIGNoYW5nZSB0byBhbGwgY3Vyc29yc1xuICAgICAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvID49IHNlbC50byAtIDEwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VkID0gdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSA9IGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHx8IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgcmFuZ2UudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCB0byA9IHJhbmdlLnRvIC0gb2Zmc2V0LCBmcm9tID0gdG8gLSByZXBsYWNlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byAtIHJhbmdlLmZyb20gIT0gc2l6ZSB8fCB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSAhPSByZXBsYWNlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgc2FtZSBub2RlIHdvcmsgd2l0aG91dCBhYm9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgJiYgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZUNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoeyBmcm9tLCB0bywgaW5zZXJ0OiBjaGFuZ2UuaW5zZXJ0IH0pLCBzZWxPZmYgPSByYW5nZS50byAtIHNlbC50bztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiAhbWFpblNlbCA/IHJhbmdlLm1hcChyYW5nZUNoYW5nZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1c2VyRXZlbnQgPSBcImlucHV0LnR5cGVcIjtcbiAgICAgICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcbiAgICAgICAgbGV0IHNjcm9sbEludG9WaWV3ID0gZmFsc2UsIHVzZXJFdmVudCA9IFwic2VsZWN0XCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVzZXJFdmVudCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luID0gdmlldy53aW4pO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDaGVjayA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSBzZXRUaW1lb3V0KHRoaXMubGlzdGVuRm9yU2Nyb2xsLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgKGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApICE9IHRoaXMuaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gIXRoaXMuaW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcgIT0gdGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5TY3JvbGxIYW5kbGVycyh0aGlzLnZpZXcsIGUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uUHJpbnQoKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB1cGRhdGVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FwSW50ZXJzZWN0aW9uICYmIChnYXBzLmxlbmd0aCAhPSB0aGlzLmdhcHMubGVuZ3RoIHx8IHRoaXMuZ2Fwcy5zb21lKChnLCBpKSA9PiBnICE9IGdhcHNbaV0pKSkge1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24ub2JzZXJ2ZShnYXApO1xuICAgICAgICAgICAgdGhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZG9tIDogIWhhc1NlbGVjdGlvbih2aWV3LmRvbSwgc2VsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaWdub3JlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIXdhc0NoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcbiAgICAgICAgLy8gc2VsZWN0aW9uICgjNjQ1KS5cbiAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUpICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgIH1cbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgdmlldy5yb290Lm5vZGVUeXBlID09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJlxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldykgfHwgZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgYnJvd3NlciBoYXMsIG9uIGZvY3VzLCBtb3ZlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgY29udGVudCBlbGVtZW50LiBSZXNldCBpdCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAgICBpZiAobG9jYWwgJiYgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIGF0RWxlbWVudFN0YXJ0KHRoaXMuZG9tLCByYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAobG9jYWwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KG51bGwsIDAsIG51bGwsIDApO1xuICAgIH1cbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwLCBjaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiBpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLnNjcm9sbFRhcmdldHNbaV0gPT0gZG9tKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQucHVzaChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5hc3NpZ25lZFNsb3QgfHwgZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcbiAgICAvLyBkb2Vzbid0IHJlbGlhYmx5IGZpcmUgcmVndWxhciBrZXkgZXZlbnRzLCBidXQgYWxzbyBvZnRlblxuICAgIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxuICAgIC8vIG9yIG90aGVyIGtpbmRzIG9mIGNvcnJ1cHRpb24uIFRoaXMgaGFjayBtYWtlcyB0aGUgZWRpdG9yIGJhY2sgb2ZmXG4gICAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcbiAgICAvLyB0aGVtIG9yLCBpZiB0aGF0IGhhcyBubyBlZmZlY3QsIGRpc3BhdGNoZXMgdGhlIGdpdmVuIGtleS5cbiAgICBkZWxheUFuZHJvaWRLZXkoa2V5LCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICBsZXQgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZsdXNoKCkgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwcm9jZXNzUmVjb3JkcygpIHtcbiAgICAgICAgbGV0IHJlY29yZHMgPSB0aGlzLnF1ZXVlO1xuICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKG11dCk7XG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVhZE11dGF0aW9uKHJlY29yZCk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID09IC0xKSB7XG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihyYW5nZS5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHR5cGVPdmVyIH07XG4gICAgfVxuICAgIHJlYWRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvLCB0eXBlT3ZlciB9ID0gdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICBsZXQgbmV3U2VsID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy5zZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiAhbmV3U2VsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChmcm9tID4gLTEpXG4gICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgRE9NQ2hhbmdlKHRoaXMudmlldywgZnJvbSwgdG8sIHR5cGVPdmVyKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXRcdTIwMTR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZFxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChyZWMudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjVmlldyB8fCBjVmlldy5pZ25vcmVNdXRhdGlvbihyZWMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNWaWV3Lm1hcmtEaXJ0eShyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIik7XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIilcbiAgICAgICAgICAgIGNWaWV3LmRpcnR5IHw9IDQgLyogRGlydHkuQXR0cnMgKi87XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRCZWZvcmUgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5wcmV2aW91c1NpYmxpbmcgfHwgcmVjLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKGNWaWV3LCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjaGlsZEJlZm9yZSA/IGNWaWV3LnBvc0FmdGVyKGNoaWxkQmVmb3JlKSA6IGNWaWV3LnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGNoaWxkQWZ0ZXIgPyBjVmlldy5wb3NCZWZvcmUoY2hpbGRBZnRlcikgOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNWaWV3LnBvc0F0U3RhcnQsIHRvOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IHJlYy50YXJnZXQubm9kZVZhbHVlID09IHJlYy5vbGRWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgKF9hID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLnJlc2l6ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcmVudENoZWNrKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnICgjNDE0KVxuZnVuY3Rpb24gc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjEpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl0XHUyMDE0dXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgdmlldy5kb20ub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3JOb2RlID0gZm91bmQuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IGZvdW5kLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJBbmNob3IgPSB2aWV3LmRvY1ZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1ckFuY2hvci5ub2RlLCBjdXJBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUgXHUyMTkyIFVwZGF0aW5nIFx1MjFDNiBJZGxlICh1bmNoZWNrZWQpIFx1MjE5MiBNZWFzdXJpbmcgXHUyMTkyIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdTIxOTEgICAgICBcdTIxOTNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHdhbnQgdG8gZWl0aGVyIHByb3ZpZGUgYSBgcGFyZW50YFxuICAgIG9wdGlvbiwgb3IgcHV0IGB2aWV3LmRvbWAgaW50byB5b3VyIGRvY3VtZW50IGFmdGVyIGNyZWF0aW5nIGFcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IC0xMDAwMHB4XCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoID0gY29uZmlnLmRpc3BhdGNoIHx8ICgodHIpID0+IHRoaXMudXBkYXRlKFt0cl0pKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChjb25maWcucm9vdCB8fCBnZXRSb290KGNvbmZpZy5wYXJlbnQpIHx8IGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKGNvbmZpZy5zdGF0ZSB8fCBFZGl0b3JTdGF0ZS5jcmVhdGUoY29uZmlnKSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMuc3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KVxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcbiAgICBvbmUgY2hhbmdlIGhhcyBiZWVuIG1hZGUgaW4gdGhlIGN1cnJlbnQgY29tcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgaW4gY29tcG9zaW5nIHN0YXRlLiBOb3RlXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICAgIGxvdCwgc2luY2UganVzdCBwdXR0aW5nIHRoZSBjdXJzb3Igb24gYSB3b3JkIHN0YXJ0cyBhXG4gICAgY29tcG9zaXRpb24gdGhlcmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaXRpb25TdGFydGVkKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxuICAgIGRpc3BhdGNoKC4uLmlucHV0KSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKGlucHV0Lmxlbmd0aCA9PSAxICYmIGlucHV0WzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gPyBpbnB1dFswXVxuICAgICAgICAgICAgOiB0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxuICAgIHVwZGF0ZSB0aGUgdmlzaWJsZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBzdGF0ZVxuICAgIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbnMsIGFuZCBub3RpZnkgdmlldyBwbHVnaW5zIG9mIHRoZVxuICAgIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQsIHdoaWNoIHVzZXMgdGhpc1xuICAgIGFzIGEgcHJpbWl0aXZlLlxuICAgICovXG4gICAgdXBkYXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnVwZGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBsZXQgcmVkcmF3biA9IGZhbHNlLCBhdHRyc0NoYW5nZWQgPSBmYWxzZSwgdXBkYXRlO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBzdGF0ZSB3aXRoIGEgdHJhbnNhY3Rpb24gdGhhdCBkb2Vzbid0IHN0YXJ0IGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIHN0YXRlID0gdHIuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgRE9NIGNoYW5nZSwgZWFnZXJseSByZWFkIGl0IGFuZCB0cnkgdG9cbiAgICAgICAgLy8gYXBwbHkgaXQgYWZ0ZXIgdGhlIGdpdmVuIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgbGV0IHBlbmRpbmdLZXkgPSB0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5LCBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAocGVuZGluZ0tleSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICBkb21DaGFuZ2UgPSB0aGlzLm9ic2VydmVyLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJ5IHRvIGFwcGx5IERPTSBjaGFuZ2VzIGlmIHRoZSB0cmFuc2FjdGlvbnMgZGlkbid0XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIGRvYyBvciBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZG9tQ2hhbmdlICYmICF0aGlzLnN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpIHx8ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcGhyYXNlcyBjaGFuZ2UsIHJlZHJhdyB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0Lm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbWFpbiB9ID0gdHIuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBuZXcgU2Nyb2xsVGFyZ2V0KG1haW4uZW1wdHkgPyBtYWluIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihtYWluLmhlYWQsIG1haW4uaGVhZCA+IG1haW4uYW5jaG9yID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIGF0dHJzQ2hhbmdlZCA9IHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24ocmVkcmF3biwgdHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJzZWxlY3QucG9pbnRlclwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodGhlbWUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGVtZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICBpZiAocmVkcmF3biB8fCBhdHRyc0NoYW5nZWQgfHwgc2Nyb2xsVGFyZ2V0IHx8IHRoaXMudmlld1N0YXRlLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgfHwgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgICAgIGlmIChkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICghYXBwbHlET01DaGFuZ2UodGhpcywgZG9tQ2hhbmdlKSAmJiBwZW5kaW5nS2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1N0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWRGb2N1cylcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5zKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldlNwZWNzID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodmlld1BsdWdpbiksIHNwZWNzID0gdXBkYXRlLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5tdXN0VXBkYXRlICE9IHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLCB0aGlzLnBsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcC5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW2ldLnVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IDA7IC8vIFByZXZlbnQgcmVxdWVzdE1lYXN1cmUgY2FsbHMgZnJvbSBzY2hlZHVsaW5nIGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgIGlmIChmbHVzaClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgIGxldCB7IHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xuICAgICAgICBsZXQgcmVmSGVpZ2h0ID0gc2Nyb2xsVG9wID4gc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0IC0gNCA/IHNjcm9sbEhlaWdodCA6IHNjcm9sbFRvcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBvbGRWaWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlZkJsb2NrID0gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQocmVmSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMudmlld1N0YXRlLm1lYXN1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggJiYgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID4gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiVmlld3BvcnQgZmFpbGVkIHRvIHN0YWJpbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBtZWFzdXJlIHJlcXVlc3RzIGluIHRoaXMgY3ljbGUgd2hlbiB0aGUgdmlld3BvcnQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIG1lYXN1cmluZ10gPSBbbWVhc3VyaW5nLCB0aGlzLm1lYXN1cmVSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmVkID0gbWVhc3VyaW5nLm1hcChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnJlYWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYWRNZWFzdXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHRoaXMuc3RhdGUsIFtdKSwgcmVkcmF3biA9IGZhbHNlLCBzY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRbaV0gIT0gQmFkTWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS53cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS53cml0ZShtZWFzdXJlZFtpXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChyZWZCbG9jay5mcm9tKS50b3AgLSByZWZCbG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDEgfHwgZGlmZiA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxET00uc2Nyb2xsVG9wICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gb2xkVmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IG9sZFZpZXdwb3J0LnRvICYmXG4gICAgICAgICAgICAgICAgICAgICFzY3JvbGxlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogXCJub1wiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgICAgICAgIHN0eWxlOiBgJHticm93c2VyLnRhYlNpemV9OiAke3RoaXMuc3RhdGUudGFiU2l6ZX1gLFxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IFwidHJ1ZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgY29udGVudEF0dHJzW1wiYXJpYS1yZWFkb25seVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICBhdHRyc0Zyb21GYWNldCh0aGlzLCBjb250ZW50QXR0cmlidXRlcywgY29udGVudEF0dHJzKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbnRlbnQgPSB1cGRhdGVBdHRycyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY29udGVudEF0dHJzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRFZGl0b3IgPSB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5lZGl0b3JBdHRycywgZWRpdG9yQXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRDb250ZW50IHx8IGNoYW5nZWRFZGl0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0gZWRpdG9yQXR0cnM7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgc2hvd0Fubm91bmNlbWVudHModHJzKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRycylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoRWRpdG9yVmlldy5hbm5vdW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZURPTS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmFubm91bmNlRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudFN0eWxlcygpIHtcbiAgICAgICAgdGhpcy5zdHlsZU1vZHVsZXMgPSB0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKTtcbiAgICAgICAgU3R5bGVNb2R1bGUubW91bnQodGhpcy5yb290LCB0aGlzLnN0eWxlTW9kdWxlcy5jb25jYXQoYmFzZVRoZW1lJDEpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrcywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKVx1MjAxNGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKVxuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgIC8vIG9yIGNsb3NpbmcsIHdoaWNoIGxlYWRzIHVzIHRvIGlnbm9yZSBzZWxlY3Rpb24gY2hhbmdlcyBmcm9tIHRoZVxuICAgICAgICAvLyBjb250ZXh0IG1lbnUgYmVjYXVzZSBpdCBsb29rcyBsaWtlIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZC5cbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxuICAgICAgICByZXR1cm4gKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKSB8fCBicm93c2VyLnNhZmFyaSAmJiAoKF9hID0gdGhpcy5pbnB1dFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmXG4gICAgICAgICAgICB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cbiAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChyb290Lm5vZGVUeXBlID09IDkgPyByb290IDogcm9vdC5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFuIHVwIHRoaXMgZWRpdG9yIHZpZXcsIHJlbW92aW5nIGl0cyBlbGVtZW50IGZyb20gdGhlXG4gICAgZG9jdW1lbnQsIHVucmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMsIGFuZCBub3RpZnlpbmdcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgICBjYWxsaW5nIHRoaXMuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcbiAgICBbYWRkZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRvIGEgdHJhbnNhY3Rpb24gdG9cbiAgICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBzY3JvbGxJbnRvVmlldyhwb3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldCh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIgPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcykgOiBwb3MsIG9wdGlvbnMueSwgb3B0aW9ucy54LCBvcHRpb25zLnlNYXJnaW4sIG9wdGlvbnMueE1hcmdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSlcdTIwMTR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVkXHUyMDE0bmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudFx1MjAxNGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXNcdTIwMTRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5Vc2VkIHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXRvbXMgYXMgZmFyIGFzXG5jdXJzb3IgbW90aW9uIGlzIGNvbmNlcm5lZC4gVGhpcyBjYXVzZXMgbWV0aG9kcyBsaWtlXG5bYG1vdmVCeUNoYXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlDaGFyKSBhbmRcbltgbW92ZVZlcnRpY2FsbHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgKGFuZCB0aGVcbmNvbW1hbmRzIGJ1aWx0IG9uIHRvcCBvZiB0aGVtKSB0byBza2lwIGFjcm9zcyBzdWNoIHJlZ2lvbnMgd2hlblxuYSBzZWxlY3Rpb24gZW5kcG9pbnQgd291bGQgZW50ZXIgdGhlbS4gVGhpcyBkb2VzIF9ub3RfIHByZXZlbnRcbmRpcmVjdCBwcm9ncmFtbWF0aWMgW3NlbGVjdGlvblxudXBkYXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBmcm9tIG1vdmluZyBpbnRvIHN1Y2hcbnJlZ2lvbnMuXG4qL1xuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMgPSBhdG9taWNSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkub3JkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJzRnJvbUZhY2V0KHZpZXcsIGZhY2V0LCBiYXNlKSB7XG4gICAgZm9yIChsZXQgc291cmNlcyA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpLCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1tpXSwgdmFsdWUgPSB0eXBlb2Ygc291cmNlID09IFwiZnVuY3Rpb25cIiA/IHNvdXJjZSh2aWV3KSA6IHNvdXJjZTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgY29tYmluZUF0dHJzKHZhbHVlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGJyb3dzZXIubWFjID8gXCJtYWNcIiA6IGJyb3dzZXIud2luZG93cyA/IFwid2luXCIgOiBicm93c2VyLmxpbnV4ID8gXCJsaW51eFwiIDogXCJrZXlcIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSwgcGxhdGZvcm0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm0gPT0gXCJtYWNcIilcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmNvbnN0IGhhbmRsZUtleUV2ZW50cyA9IC8qQF9fUFVSRV9fKi9QcmVjLmRlZmF1bHQoLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XG4gICAgfVxufSkpO1xuLyoqXG5GYWNldCB1c2VkIGZvciByZWdpc3RlcmluZyBrZXltYXBzLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXBzIHRvIGFuIGVkaXRvci4gVGhlaXIgcHJpb3JpdGllc1xuZGV0ZXJtaW5lIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIHNwZWNpZmllZCBlYXJseSBvciB3aXRoIGhpZ2hcbnByaW9yaXR5IGdldCBjaGVja2VkIGZpcnN0KS4gV2hlbiBhIGhhbmRsZXIgaGFzIHJldHVybmVkIGB0cnVlYFxuZm9yIGEgZ2l2ZW4ga2V5LCBubyBmdXJ0aGVyIGhhbmRsZXJzIGFyZSBjYWxsZWQuXG4qL1xuY29uc3Qga2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGVuYWJsZXM6IGhhbmRsZUtleUV2ZW50cyB9KTtcbmNvbnN0IEtleW1hcHMgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFRoaXMgaXMgaGlkZGVuIGJlaGluZCBhbiBpbmRpcmVjdGlvbiwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY29tcHV0ZWRcbi8vIGJ5IHRoZSBmYWNldCwgdG8ga2VlcCBpbnRlcm5hbCB0eXBlcyBvdXQgb2YgdGhlIGZhY2V0J3MgdHlwZS5cbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xuICAgIGxldCBiaW5kaW5ncyA9IHN0YXRlLmZhY2V0KGtleW1hcCk7XG4gICAgbGV0IG1hcCA9IEtleW1hcHMuZ2V0KGJpbmRpbmdzKTtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgS2V5bWFwcy5zZXQoYmluZGluZ3MsIG1hcCA9IGJ1aWxkS2V5bWFwKGJpbmRpbmdzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKSkpO1xuICAgIHJldHVybiBtYXA7XG59XG4vKipcblJ1biB0aGUga2V5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gc2NvcGUuIFRoZSBldmVudFxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKGIuYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgICAgICBpZiAoYi5zaGlmdClcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGZhbGx0aHJvdWdoID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChmYWxsdGhyb3VnaCA9IG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICAgICAgZmFsbHRocm91Z2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGxldCBzY29wZU9iaiA9IG1hcFtzY29wZV0sIGJhc2VOYW1lLCBzaGlmdE5hbWU7XG4gICAgaWYgKHNjb3BlT2JqKSB7XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc0NoYXIgJiYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGx0aHJvdWdoO1xufVxuXG5jb25zdCBDYW5IaWRlUHJpbWFyeSA9ICFicm93c2VyLmlvczsgLy8gRklYTUUgdGVzdCBJRVxuY29uc3Qgc2VsZWN0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogMTIwMCxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IChhLCBiKSA9PiBNYXRoLm1pbihhLCBiKSxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogKGEsIGIpID0+IGEgfHwgYlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWRlcyB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzZWxlY3Rpb24gYW5kXG5jdXJzb3IsIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggYSBiYWNrZ3JvdW5kIGJlaGluZCB0aGUgdGV4dFxuKHdpdGggdGhlIGBjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kYCBjbGFzcyksIGFuZCB0aGVcbmN1cnNvcnMgd2l0aCBlbGVtZW50cyBvdmVybGFpZCBvdmVyIHRoZSBjb2RlICh1c2luZ1xuYGNtLWN1cnNvci1wcmltYXJ5YCBhbmQgYGNtLWN1cnNvci1zZWNvbmRhcnlgKS5cblxuVGhpcyBhbGxvd3MgdGhlIGVkaXRvciB0byBkaXNwbGF5IHNlY29uZGFyeSBzZWxlY3Rpb24gcmFuZ2VzLCBhbmRcbnRlbmRzIHRvIHByb2R1Y2UgYSB0eXBlIG9mIHNlbGVjdGlvbiBtb3JlIGluIGxpbmUgd2l0aCB0aGF0IHVzZXJzXG5leHBlY3QgaW4gYSB0ZXh0IGVkaXRvciAodGhlIG5hdGl2ZSBzZWxlY3Rpb24gc3R5bGluZyB3aWxsIG9mdGVuXG5sZWF2ZSBnYXBzIGJldHdlZW4gbGluZXMgYW5kIHdvbid0IGZpbGwgdGhlIGhvcml6b250YWwgc3BhY2UgYWZ0ZXJcbmEgbGluZSB3aGVuIHRoZSBzZWxlY3Rpb24gY29udGludWVzIHBhc3QgaXQpLlxuXG5JdCBkb2VzIGhhdmUgYSBwZXJmb3JtYW5jZSBjb3N0LCBpbiB0aGF0IGl0IHJlcXVpcmVzIGFuIGV4dHJhIERPTVxubGF5b3V0IGN5Y2xlIGZvciBtYW55IHVwZGF0ZXMgKHRoZSBzZWxlY3Rpb24gaXMgZHJhd24gYmFzZWQgb24gRE9NXG5sYXlvdXQgaW5mb3JtYXRpb24gdGhhdCdzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGxheWluZyBvdXQgdGhlXG5jb250ZW50KS5cbiovXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGRyYXdTZWxlY3Rpb25QbHVnaW4sXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG5jbGFzcyBQaWVjZSB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID49IDApXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG59XG5jb25zdCBkcmF3U2VsZWN0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucmFuZ2VQaWVjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJzb3JzID0gW107XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkUG9zLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXdTZWwuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIuY2xhc3NOYW1lID0gXCJjbS1zZWxlY3Rpb25MYXllclwiO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllciA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLmNsYXNzTmFtZSA9IFwiY20tY3Vyc29yTGF5ZXJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgdGhpcy5zZXRCbGlua1JhdGUoKTtcbiAgICB9XG4gICAgc2V0QmxpbmtSYXRlKCkge1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mQ2hhbmdlZCA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuc3R5bGUuYW5pbWF0aW9uTmFtZSA9IHRoaXMuY3Vyc29yTGF5ZXIuc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBpZiAoY29uZkNoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLnNldEJsaW5rUmF0ZSgpO1xuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHJhbmdlUGllY2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBtZWFzdXJlUmFuZ2UodGhpcy52aWV3LCByKSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgICAgIGxldCBjdXJzb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IHByaW0gPSByID09IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgaWYgKHIuZW1wdHkgPyAhcHJpbSB8fCBDYW5IaWRlUHJpbWFyeSA6IGNvbmYuZHJhd1JhbmdlQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gbWVhc3VyZUN1cnNvcih0aGlzLnZpZXcsIHIsIHByaW0pO1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29ycy5wdXNoKHBpZWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZVBpZWNlcywgY3Vyc29ycyB9O1xuICAgIH1cbiAgICBkcmF3U2VsKHsgcmFuZ2VQaWVjZXMsIGN1cnNvcnMgfSkge1xuICAgICAgICBpZiAocmFuZ2VQaWVjZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VQaWVjZXMubGVuZ3RoIHx8IHJhbmdlUGllY2VzLnNvbWUoKHAsIGkpID0+ICFwLmVxKHRoaXMucmFuZ2VQaWVjZXNbaV0pKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHJhbmdlUGllY2VzKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIuYXBwZW5kQ2hpbGQocC5kcmF3KCkpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZVBpZWNlcyA9IHJhbmdlUGllY2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJzb3JzLmxlbmd0aCAhPSB0aGlzLmN1cnNvcnMubGVuZ3RoIHx8IGN1cnNvcnMuc29tZSgoYywgaSkgPT4gIWMuZXEodGhpcy5jdXJzb3JzW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGRDdXJzb3JzID0gdGhpcy5jdXJzb3JMYXllci5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChvbGRDdXJzb3JzLmxlbmd0aCAhPT0gY3Vyc29ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckxheWVyLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY3Vyc29ycylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JMYXllci5hcHBlbmRDaGlsZChjLmRyYXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JzLmZvckVhY2goKGMsIGlkeCkgPT4gYy5hZGp1c3Qob2xkQ3Vyc29yc1tpZHhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnNvcnMgPSBjdXJzb3JzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIucmVtb3ZlKCk7XG4gICAgfVxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCImOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KVxuICAgIHRoZW1lU3BlY1tcIi5jbS1saW5lXCJdLmNhcmV0Q29sb3IgPSBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIjtcbmNvbnN0IGhpZGVOYXRpdmVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkTGluZSh2aWV3LCBwb3MsIGluc2lkZSkge1xuICAgIGxldCByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICByZXR1cm4geyBmcm9tOiBNYXRoLm1heChpbnNpZGUuZnJvbSwgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlLCB0cnVlKS5mcm9tKSxcbiAgICAgICAgdG86IE1hdGgubWluKGluc2lkZS50bywgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUsIHRydWUpLmZyb20pLFxuICAgICAgICB0eXBlOiBCbG9ja1R5cGUuVGV4dCB9O1xufVxuZnVuY3Rpb24gYmxvY2tBdCh2aWV3LCBwb3MpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKVxuICAgICAgICBmb3IgKGxldCBsIG9mIGxpbmUudHlwZSkge1xuICAgICAgICAgICAgaWYgKGwudG8gPiBwb3MgfHwgbC50byA9PSBwb3MgJiYgKGwudG8gPT0gbGluZS50byB8fCBsLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBtZWFzdXJlUmFuZ2UodmlldywgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UudG8gPD0gdmlldy52aWV3cG9ydC5mcm9tIHx8IHJhbmdlLmZyb20gPj0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBmcm9tID0gTWF0aC5tYXgocmFuZ2UuZnJvbSwgdmlldy52aWV3cG9ydC5mcm9tKSwgdG8gPSBNYXRoLm1pbihyYW5nZS50bywgdmlldy52aWV3cG9ydC50byk7XG4gICAgbGV0IGx0ciA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIGxldCBsaW5lU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGxldCBsZWZ0U2lkZSA9IGNvbnRlbnRSZWN0LmxlZnQgKyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ0xlZnQpICsgTWF0aC5taW4oMCwgcGFyc2VJbnQobGluZVN0eWxlLnRleHRJbmRlbnQpKTtcbiAgICBsZXQgcmlnaHRTaWRlID0gY29udGVudFJlY3QucmlnaHQgLSBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICBsZXQgc3RhcnRCbG9jayA9IGJsb2NrQXQodmlldywgZnJvbSksIGVuZEJsb2NrID0gYmxvY2tBdCh2aWV3LCB0byk7XG4gICAgbGV0IHZpc3VhbFN0YXJ0ID0gc3RhcnRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gc3RhcnRCbG9jayA6IG51bGw7XG4gICAgbGV0IHZpc3VhbEVuZCA9IGVuZEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBlbmRCbG9jayA6IG51bGw7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIGlmICh2aXN1YWxTdGFydClcbiAgICAgICAgICAgIHZpc3VhbFN0YXJ0ID0gd3JhcHBlZExpbmUodmlldywgZnJvbSwgdmlzdWFsU3RhcnQpO1xuICAgICAgICBpZiAodmlzdWFsRW5kKVxuICAgICAgICAgICAgdmlzdWFsRW5kID0gd3JhcHBlZExpbmUodmlldywgdG8sIHZpc3VhbEVuZCk7XG4gICAgfVxuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSkge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtIDEpXG4gICAgICAgICAgICBiZXR3ZWVuLnB1c2gocGllY2UobGVmdFNpZGUsIHRvcC5ib3R0b20sIHJpZ2h0U2lkZSwgYm90dG9tLnRvcCkpO1xuICAgICAgICBlbHNlIGlmICh0b3AuYm90dG9tIDwgYm90dG9tLnRvcCAmJiB2aWV3LmVsZW1lbnRBdEhlaWdodCgodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMikudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIHRvcC5ib3R0b20gPSBib3R0b20udG9wID0gKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDI7XG4gICAgICAgIHJldHVybiBwaWVjZXModG9wKS5jb25jYXQoYmV0d2VlbikuY29uY2F0KHBpZWNlcyhib3R0b20pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2UobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGllY2UobGVmdCAtIGJhc2UubGVmdCwgdG9wIC0gYmFzZS50b3AgLSAwLjAxIC8qIEMuRXBzaWxvbiAqLywgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3AgKyAwLjAxIC8qIEMuRXBzaWxvbiAqLywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZXMoeyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9KSB7XG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Jpem9udGFsLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UoaG9yaXpvbnRhbFtpXSwgdG9wLCBob3Jpem9udGFsW2kgKyAxXSwgYm90dG9tKSk7XG4gICAgICAgIHJldHVybiBwaWVjZXM7XG4gICAgfVxuICAgIC8vIEdldHMgcGFzc2VkIGZyb20vdG8gaW4gbGluZS1sb2NhbCBwb3NpdGlvbnNcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xuICAgICAgICBsZXQgdG9wID0gMWU5LCBib3R0b20gPSAtMWU5LCBob3Jpem9udGFsID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNwYW4oZnJvbSwgZnJvbU9wZW4sIHRvLCB0b09wZW4sIGRpcikge1xuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb24gdGhlIHByb3BlciBzaWRlIG9mIGJsb2NrIHdpZGdldHMsIHNpbmNlXG4gICAgICAgICAgICAvLyBub3JtYWxpemluZyB0aGUgc2lkZSB0aGVyZSwgdGhvdWdoIGFwcHJvcHJpYXRlIGZvciBtb3N0XG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cbiAgICAgICAgICAgIGxldCBmcm9tQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhmcm9tLCAoZnJvbSA9PSBsaW5lLnRvID8gLTIgOiAyKSk7XG4gICAgICAgICAgICBsZXQgdG9Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHRvLCAodG8gPT0gbGluZS5mcm9tID8gMiA6IC0yKSk7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gbWVhc3VyZUN1cnNvcih2aWV3LCBjdXJzb3IsIHByaW1hcnkpIHtcbiAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhjdXJzb3IuaGVhZCwgY3Vyc29yLmFzc29jIHx8IDEpO1xuICAgIGlmICghcG9zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgcmV0dXJuIG5ldyBQaWVjZShwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCAtMSwgcG9zLmJvdHRvbSAtIHBvcy50b3AsIHByaW1hcnkgPyBcImNtLWN1cnNvciBjbS1jdXJzb3ItcHJpbWFyeVwiIDogXCJjbS1jdXJzb3IgY20tY3Vyc29yLXNlY29uZGFyeVwiKTtcbn1cblxuY29uc3Qgc2V0RHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChwb3MsIG1hcHBpbmcpIHsgcmV0dXJuIHBvcyA9PSBudWxsID8gbnVsbCA6IG1hcHBpbmcubWFwUG9zKHBvcyk7IH1cbn0pO1xuY29uc3QgZHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUocG9zLCB0cikge1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICBwb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyhwb3MpO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHBvcywgZSkgPT4gZS5pcyhzZXREcm9wQ3Vyc29yUG9zKSA/IGUudmFsdWUgOiBwb3MsIHBvcyk7XG4gICAgfVxufSk7XG5jb25zdCBkcmF3RHJvcEN1cnNvciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkUG9zLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXdDdXJzb3IuYmluZCh0aGlzKSB9O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGN1cnNvclBvcyA9IHVwZGF0ZS5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3Vyc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc05hbWUgPSBcImNtLWRyb3BDdXJzb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBjdXJzb3JQb3MgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBsZXQgcmVjdCA9IHBvcyAhPSBudWxsICYmIHRoaXMudmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG91dGVyLmxlZnQgKyB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQsXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gb3V0ZXIudG9wICsgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd0N1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gcG9zLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBcIi0xMDAwMDBweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcilcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBzZXREcm9wUG9zKHBvcykge1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IHBvcylcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldERyb3BDdXJzb3JQb3Mub2YocG9zKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gPSBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBTcGVjaWFsQ2hhcldpZGdldChjb25mLCBjb2RlKSB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeTogY29uZi5yZXBsYWNlVGFicyA/IHVuZGVmaW5lZCA6IC9bXl0vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpICE9IGNvbmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcihjb25mKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IudXBkYXRlRGVjbyh1cGRhdGUsIHRoaXMuZGVjb3JhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSkpO1xufVxuY29uc3QgRGVmYXVsdFBsYWNlaG9sZGVyID0gXCJcXHUyMDIyXCI7XG4vLyBBc3NpZ25zIHBsYWNlaG9sZGVyIGNoYXJhY3RlcnMgZnJvbSB0aGUgQ29udHJvbCBQaWN0dXJlcyBibG9jayB0b1xuLy8gQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBwbGFjZWhvbGRlciQxKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PSAzMilcbiAgICAgICAgcmV0dXJuIERlZmF1bHRQbGFjZWhvbGRlcjtcbiAgICBpZiAoY29kZSA9PSAxMClcbiAgICAgICAgcmV0dXJuIFwiXFx1MjQyNFwiO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDkyMTYgKyBjb2RlKTtcbn1cbmNsYXNzIFNwZWNpYWxDaGFyV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuY29kZSA9PSB0aGlzLmNvZGU7IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGxldCBwaCA9IHBsYWNlaG9sZGVyJDEodGhpcy5jb2RlKTtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LnN0YXRlLnBocmFzZShcIkNvbnRyb2wgY2hhcmFjdGVyXCIpICsgXCIgXCIgKyAoTmFtZXNbdGhpcy5jb2RlXSB8fCBcIjB4XCIgKyB0aGlzLmNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMub3B0aW9ucy5yZW5kZXIgJiYgdGhpcy5vcHRpb25zLnJlbmRlcih0aGlzLmNvZGUsIGRlc2MsIHBoKTtcbiAgICAgICAgaWYgKGN1c3RvbSlcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBwaDtcbiAgICAgICAgc3Bhbi50aXRsZSA9IGRlc2M7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBkZXNjKTtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNwZWNpYWxDaGFyXCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5jbGFzcyBUYWJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci53aWR0aCA9PSB0aGlzLndpZHRoOyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIlxcdFwiO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tdGFiXCI7XG4gICAgICAgIHNwYW4uc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG5jb25zdCBwbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IDEwMDA7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBcInBhZGRpbmctYm90dG9tOiAxMDAwcHhcIiB9O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHVwZGF0ZTtcbiAgICAgICAgbGV0IGhlaWdodCA9IHZpZXcudmlld1N0YXRlLmVkaXRvckhlaWdodCAtIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgLSAwLjU7XG4gICAgICAgIGlmIChoZWlnaHQgIT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IGBwYWRkaW5nLWJvdHRvbTogJHtoZWlnaHR9cHhgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBtYWtlcyBzdXJlIHRoZSBjb250ZW50IGhhcyBhIGJvdHRvbVxubWFyZ2luIGVxdWl2YWxlbnQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBtaW51cyBvbmUgbGluZVxuaGVpZ2h0LCBzbyB0aGF0IGV2ZXJ5IGxpbmUgaW4gdGhlIGRvY3VtZW50IGNhbiBiZSBzY3JvbGxlZCB0byB0aGVcbnRvcCBvZiB0aGUgZWRpdG9yLlxuXG5UaGlzIGlzIG9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsYWJsZSwgYW5kIHNob3VsZFxubm90IGJlIGVuYWJsZWQgaW4gZWRpdG9ycyB0aGF0IHRha2UgdGhlIHNpemUgb2YgdGhlaXIgY29udGVudC5cbiovXG5mdW5jdGlvbiBzY3JvbGxQYXN0RW5kKCkge1xuICAgIHJldHVybiBbcGx1Z2luLCBjb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRycykgfHwgbnVsbDsgfSldO1xufVxuXG4vKipcbk1hcmsgbGluZXMgdGhhdCBoYXZlIGEgY3Vyc29yIG9uIHRoZW0gd2l0aCB0aGUgYFwiY20tYWN0aXZlTGluZVwiYFxuRE9NIGNsYXNzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVIaWdobGlnaHRlcjtcbn1cbmNvbnN0IGxpbmVEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubGluZSh7IGNsYXNzOiBcImNtLWFjdGl2ZUxpbmVcIiB9KTtcbmNvbnN0IGFjdGl2ZUxpbmVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgbGFzdExpbmVTdGFydCA9IC0xLCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBsYXN0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKGxpbmVEZWNvLnJhbmdlKGxpbmUuZnJvbSkpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcblxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgd3JhcC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6IHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJwbGFjZWhvbGRlciBcIiArIHRoaXMuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLyoqXG5FeHRlbnNpb24gdGhhdCBlbmFibGVzIGEgcGxhY2Vob2xkZXJcdTIwMTRhIHBpZWNlIG9mIGV4YW1wbGUgY29udGVudFxudG8gc2hvdyB3aGVuIHRoZSBlZGl0b3IgaXMgZW1wdHkuXG4qL1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIoY29udGVudCkge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gRGVjb3JhdGlvbi5zZXQoW0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgUGxhY2Vob2xkZXIoY29udGVudCksIHNpZGU6IDEgfSkucmFuZ2UoMCldKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gZmluZENvbHVtbihsaW5lLnRleHQsIGVuZENvbCwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0LCBsaW5lLmZyb20gKyBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gYWJzb2x1dGVDb2x1bW4odmlldywgeCkge1xuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgcmV0dXJuIHJlZiA/IE1hdGgucm91bmQoTWF0aC5hYnMoKHJlZi5sZWZ0IC0geCkgLyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkpIDogLTE7XG59XG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KG9mZnNldCksIG9mZiA9IG9mZnNldCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcbiAgICAgICAgOiBvZmYgPT0gbGluZS5sZW5ndGggPyBhYnNvbHV0ZUNvbHVtbih2aWV3LCBldmVudC5jbGllbnRYKVxuICAgICAgICAgICAgOiBjb3VudENvbHVtbihsaW5lLnRleHQsIHZpZXcuc3RhdGUudGFiU2l6ZSwgb2Zmc2V0IC0gbGluZS5mcm9tKTtcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xpbmUgPSB1cGRhdGUuc3RhdGUuZG9jLmxpbmVBdChuZXdTdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7IGxpbmU6IG5ld0xpbmUubnVtYmVyLCBjb2w6IHN0YXJ0LmNvbCwgb2ZmOiBNYXRoLm1pbihzdGFydC5vZmYsIG5ld0xpbmUubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGdldFBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWN1cilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gcmVjdGFuZ2xlRm9yKHZpZXcuc3RhdGUsIHN0YXJ0LCBjdXIpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuY29uY2F0KHN0YXJ0U2VsLnJhbmdlcykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuZGVmYXVsdCwgaXQgd2lsbCByZWFjdCB0byBsZWZ0IG1vdXNlIGRyYWcgd2l0aCB0aGUgQWx0IGtleSBoZWxkXG5kb3duLiBXaGVuIHN1Y2ggYSBzZWxlY3Rpb24gb2NjdXJzLCB0aGUgdGV4dCB3aXRoaW4gdGhlIHJlY3RhbmdsZVxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbltyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG4qL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBmaWx0ZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RmlsdGVyKSB8fCAoZSA9PiBlLmFsdEtleSAmJiBlLmJ1dHRvbiA9PSAwKTtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlLm9mKCh2aWV3LCBldmVudCkgPT4gZmlsdGVyKGV2ZW50KSA/IHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSA6IG51bGwpO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgICBBbHQ6IFsxOCwgZSA9PiBlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+IGUuY3RybEtleV0sXG4gICAgU2hpZnQ6IFsxNiwgZSA9PiBlLnNoaWZ0S2V5XSxcbiAgICBNZXRhOiBbOTEsIGUgPT4gZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKGNyZWF0ZVRvb2x0aXBWaWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGlzLmZhY2V0KTtcbiAgICAgICAgbGV0IHRvb2x0aXBzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICBpZiAodC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlwID0gdG9vbHRpcHNbaV0sIGtub3duID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMudG9vbHRpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyLmNyZWF0ZSA9PSB0aXAuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBrbm93biA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwVmlldyh0aXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgeyB3aW4gfSA9IHZpZXc7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCkpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIGlmICh0b29sdGlwLmFycm93ICYmICF0b29sdGlwVmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwID4gLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IGVkaXRvciA9IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50ID8gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBlZGl0b3IsXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgZWRpdG9yLCBzcGFjZSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCBwb3MuYm90dG9tIDw9IE1hdGgubWF4KGVkaXRvci50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKGVkaXRvci5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heChlZGl0b3IubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4oZWRpdG9yLnJpZ2h0LCBzcGFjZS5yaWdodCkgKyAuMSkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFycm93ID0gdG9vbHRpcC5hcnJvdyA/IHRWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0Vmlldy5vZmZzZXQgfHwgbm9PZmZzZXQsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnQgPyAobHRyID8gc3BhY2UubGVmdCA6IHNwYWNlLnJpZ2h0IC0gc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGx0ciA/IE1hdGgubWluKHBvcy5sZWZ0IC0gKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgKyBvZmZzZXQueCwgc3BhY2UucmlnaHQgLSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSAhIXRvb2x0aXAuYWJvdmU7XG4gICAgICAgICAgICBpZiAoIXRvb2x0aXAuc3RyaWN0U2lkZSAmJiAoYWJvdmVcbiAgICAgICAgICAgICAgICA/IHBvcy50b3AgLSAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSArIG9mZnNldC55ID4gc3BhY2UuYm90dG9tKSAmJlxuICAgICAgICAgICAgICAgIGFib3ZlID09IChzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tID4gcG9zLnRvcCAtIHNwYWNlLnRvcCkpXG4gICAgICAgICAgICAgICAgYWJvdmUgPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgdG9wID0gYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA6IHBvcy5ib3R0b20gKyBhcnJvd0hlaWdodCArIG9mZnNldC55O1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBvdGhlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlZnQgPCByaWdodCAmJiByLnJpZ2h0ID4gbGVmdCAmJiByLnRvcCA8IHRvcCArIGhlaWdodCAmJiByLmJvdHRvbSA+IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGFib3ZlID8gci50b3AgLSBoZWlnaHQgLSAyIC0gYXJyb3dIZWlnaHQgOiByLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSAodG9wIC0gbWVhc3VyZWQucGFyZW50LnRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KVxuICAgICAgICAgICAgICAgIGFycm93LnN0eWxlLmxlZnQgPSBgJHtwb3MubGVmdCArIChsdHIgPyBvZmZzZXQueCA6IC1vZmZzZXQueCkgLSAobGVmdCArIDE0IC8qIEFycm93Lk9mZnNldCAqLyAtIDcgLyogQXJyb3cuU2l6ZSAqLyl9cHhgO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgc2Nyb2xsKCkgeyB0aGlzLm1heWJlTWVhc3VyZSgpOyB9XG4gICAgfVxufSk7XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICB6SW5kZXg6IDEwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBoZWlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIFwiJjpiZWZvcmUsICY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xuICAgICAgICAgICAgYm90dG9tOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYmVsb3cgJlwiOiB7XG4gICAgICAgICAgICB0b3A6IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICB0b3A6IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgbm9PZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbi8qKlxuRmFjZXQgdG8gd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBhZGQgYSB2YWx1ZSB0byBzaG93IGEgdG9vbHRpcC5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IFt0b29sdGlwUGx1Z2luLCBiYXNlVGhlbWVdXG59KTtcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBIb3ZlclRvb2x0aXBIb3N0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVIb3N0ZWRWaWV3KHQpKTtcbiAgICB9XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXApIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChob3N0ZWRWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQgJiYgaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIGhvc3RlZFZpZXc7XG4gICAgfVxuICAgIG1vdW50KHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcucG9zaXRpb25lZChzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgfVxufVxuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcEhvc3QgPSAvKkBfX1BVUkVfXyovc2hvd1Rvb2x0aXAuY29tcHV0ZShbc2hvd0hvdmVyVG9vbHRpcF0sIHN0YXRlID0+IHtcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5maWx0ZXIodCA9PiB0KTtcbiAgICBpZiAodG9vbHRpcHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IE1hdGgubWluKC4uLnRvb2x0aXBzLm1hcCh0ID0+IHQucG9zKSksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoLi4udG9vbHRpcHMuZmlsdGVyKHQgPT4gdC5lbmQgIT0gbnVsbCkubWFwKHQgPT4gdC5lbmQpKSxcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcbiAgICAgICAgYWJvdmU6IHRvb2x0aXBzWzBdLmFib3ZlLFxuICAgICAgICBhcnJvdzogdG9vbHRpcHMuc29tZSh0ID0+IHQuYXJyb3cpLFxuICAgIH07XG59KTtcbmNsYXNzIEhvdmVyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWUgPSBob3ZlclRpbWU7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaG92ZXJlZCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RNb3ZlLnRpbWU7XG4gICAgICAgIGlmIChob3ZlcmVkIDwgdGhpcy5ob3ZlclRpbWUpXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSAtIGhvdmVyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SG92ZXIoKTtcbiAgICB9XG4gICAgc3RhcnRIb3ZlcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICBsZXQgeyBsYXN0TW92ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGxhc3RNb3ZlLnRhcmdldCkgPyB0aGlzLnZpZXcucG9zQXRDb29yZHMobGFzdE1vdmUpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zQ29vcmRzID0gdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3NDb29yZHMgPT0gbnVsbCB8fCBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiaWRpID0gdGhpcy52aWV3LmJpZGlTcGFucyh0aGlzLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IERpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodGhpcy52aWV3LCBwb3MsIChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKHJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRoaXMubGFzdE1vdmUudGFyZ2V0KSB8fCB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gdG9vbHRpcCB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IHRvb2x0aXAgPT09IG51bGwgfHwgdG9vbHRpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbHRpcC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCA2IC8qIEhvdmVyLk1heERpc3QgKi8pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICFpc0luVG9vbHRpcChlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKGVsdCkge1xuICAgIGZvciAobGV0IGN1ciA9IGVsdDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IGZyb21ET00gPSB2aWV3LmRvbUF0UG9zKGZyb20pLCB0b0RPTSA9IHZpZXcuZG9tQXRQb3ModG8pO1xuICAgIHJhbmdlLnNldEVuZCh0b0RPTS5ub2RlLCB0b0RPTS5vZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KGZyb21ET00ubm9kZSwgZnJvbURPTS5vZmZzZXQpO1xuICAgIGxldCByZWN0cyA9IHJhbmdlLmdldENsaWVudFJlY3RzKCk7XG4gICAgcmFuZ2UuZGV0YWNoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWF4KHJlY3QudG9wIC0geSwgeSAtIHJlY3QuYm90dG9tLCByZWN0LmxlZnQgLSB4LCB4IC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChkaXN0IDw9IG1hcmdpbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcblNldCB1cCBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXG5vdmVyIHJhbmdlcyBvZiB0ZXh0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhvdmVyc1xub3ZlciB0aGUgZG9jdW1lbnQgdGV4dC4gSXQgc2hvdWxkLCBpZiB0aGVyZSBpcyBhIHRvb2x0aXBcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCwgcmV0dXJuIHRoZSB0b29sdGlwIGRlc2NyaXB0aW9uXG4oZWl0aGVyIGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSkuIFRoZSBgc2lkZWAgYXJndW1lbnQgaW5kaWNhdGVzXG5vbiB3aGljaCBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGUgcG9pbnRlciBpc1x1MjAxNGl0IHdpbGwgYmUgLTEgaWYgdGhlXG5wb2ludGVyIGlzIGJlZm9yZSB0aGUgcG9zaXRpb24sIDEgaWYgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuXG5Ob3RlIHRoYXQgYWxsIGhvdmVyIHRvb2x0aXBzIGFyZSBob3N0ZWQgd2l0aGluIGEgc2luZ2xlIHRvb2x0aXBcbmNvbnRhaW5lciBlbGVtZW50LiBUaGlzIGFsbG93cyBtdWx0aXBsZSB0b29sdGlwcyBvdmVyIHRoZSBzYW1lXG5yYW5nZSB0byBiZSBcIm1lcmdlZFwiIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG4qL1xuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHNldEhvdmVyID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4gICAgbGV0IGhvdmVyU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAob3B0aW9ucy5oaWRlT25DaGFuZ2UgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZU9uICYmIG9wdGlvbnMuaGlkZU9uKHRyLCB2YWx1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3UG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUucG9zLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvcHkucG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5lbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29weS5lbmQgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5lbmQpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd0hvdmVyVG9vbHRpcC5mcm9tKGYpXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaG92ZXJTdGF0ZSxcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3Zlciwgb3B0aW9ucy5ob3ZlclRpbWUgfHwgMzAwIC8qIEhvdmVyLlRpbWUgKi8pKSxcbiAgICAgICAgc2hvd0hvdmVyVG9vbHRpcEhvc3RcbiAgICBdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSB0b29sdGlwIHZpZXcgZm9yIGEgZ2l2ZW4gdG9vbHRpcCwgaWYgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXAodmlldywgdG9vbHRpcCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAoIXBsdWdpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kID0gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuaW5kZXhPZih0b29sdGlwKTtcbiAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tmb3VuZF07XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiBhbnkgaG92ZXIgdG9vbHRpcHMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gaGFzSG92ZXJUb29sdGlwcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5zb21lKHggPT4geCk7XG59XG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gZWZmZWN0IHRoYXQgY2xvc2VzIGFsbCBob3ZlciB0b29sdGlwcy5cbiovXG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcHMgPSAvKkBfX1BVUkVfXyovY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3Qub2YobnVsbCk7XG4vKipcblRlbGwgdGhlIHRvb2x0aXAgZXh0ZW5zaW9uIHRvIHJlY29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGFjdGl2ZVxudG9vbHRpcHMuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIChzdWNoIGFzIGFcbnJlLXBvc2l0aW9uaW5nIG9yIENTUyBjaGFuZ2UgYWZmZWN0aW5nIHRoZSBlZGl0b3IpIHRoYXQgY291bGRcbmludmFsaWRhdGUgdGhlIGV4aXN0aW5nIHRvb2x0aXAgcG9zaXRpb25zLlxuKi9cbmZ1bmN0aW9uIHJlcG9zaXRpb25Ub29sdGlwcyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBjb25maWcpKV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICB9XG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMuZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIGxldCBsaW5lQ2xhc3NlcyA9IFJhbmdlU2V0Lml0ZXIodGhpcy52aWV3LnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHRoaXMudmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgbGV0IGNsYXNzU2V0ID0gW107XG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIGxpbmUudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGxpbmUudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGxpbmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNsYXNzU2V0ID0gW107XG4gICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCB0ZXh0LCBjbGFzc1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XG4gICAgfVxuICAgIHVwZGF0ZUd1dHRlcnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5oZWlnaHRDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICFSYW5nZVNldC5lcSh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlci51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ3V0dGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29uZiBvZiBjdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobmV3IFNpbmdsZUd1dHRlclZpZXcodGhpcy52aWV3LCBjb25mKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1dHRlcnNba25vd25dLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBnLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVycy5pbmRleE9mKGcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIGd1dHRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJzID0gZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5ndXR0ZXJzLmxlbmd0aCA9PSAwIHx8ICF2YWx1ZS5maXhlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyB7IGxlZnQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9IDogeyByaWdodDogdmFsdWUuZG9tLm9mZnNldFdpZHRoIH07XG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cbmZ1bmN0aW9uIGFkdmFuY2VDdXJzb3IoY3Vyc29yLCBjb2xsZWN0LCBwb3MpIHtcbiAgICB3aGlsZSAoY3Vyc29yLnZhbHVlICYmIGN1cnNvci5mcm9tIDw9IHBvcykge1xuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5sb2NhbE1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBSYW5nZVNldC5pdGVyKGd1dHRlci5tYXJrZXJzLCB2aWV3cG9ydC5mcm9tKTtcbiAgICB9XG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxNYXJrZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIHRoaXMubG9jYWxNYXJrZXJzLCBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gZXh0cmFNYXJrZXJzLmxlbmd0aCA/IHRoaXMubG9jYWxNYXJrZXJzLmNvbmNhdChleHRyYU1hcmtlcnMpIDogdGhpcy5sb2NhbE1hcmtlcnM7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBhYm92ZSA9IGxpbmUudG9wIC0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGxpbmUuaGVpZ2h0LCBhYm92ZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50cy5wdXNoKG5ld0VsdCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLmFwcGVuZENoaWxkKG5ld0VsdC5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzW3RoaXMuaV0udXBkYXRlKHZpZXcsIGxpbmUuaGVpZ2h0LCBhYm92ZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlaWdodCA9IGxpbmUuYm90dG9tO1xuICAgICAgICB0aGlzLmkrKztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KGV2ZW50LmNsaWVudFkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMuYWJvdmUgIT0gYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5tYXJnaW5Ub3AgPSAodGhpcy5hYm92ZSA9IGFib3ZlKSA/IGFib3ZlICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgaWYgKCFzYW1lTWFya2Vycyh0aGlzLm1hcmtlcnMsIG1hcmtlcnMpKVxuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpO1xuICAgIH1cbiAgICBzZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGNscyA9IFwiY20tZ3V0dGVyRWxlbWVudFwiLCBkb21Qb3MgPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBpTmV3ID0gMCwgaU9sZCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IHNraXBUbyA9IGlPbGQsIG1hcmtlciA9IGlOZXcgPCBtYXJrZXJzLmxlbmd0aCA/IG1hcmtlcnNbaU5ldysrXSA6IG51bGwsIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG1hcmtlci5lbGVtZW50Q2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIiArIGM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlPbGQ7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcnNbaV0uY29tcGFyZShtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVG8gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2tpcFRvID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpT2xkIDwgc2tpcFRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLm1hcmtlcnNbaU9sZCsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC50b0RPTSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmRlc3Ryb3koZG9tUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50b0RPTSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLnRvRE9NKHZpZXcpLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgaU9sZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRNYXJrZXJzKG51bGwsIFtdKTsgLy8gRmlyc3QgYXJndW1lbnQgbm90IHVzZWQgdW5sZXNzIGNyZWF0aW5nIG1hcmtlcnNcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VycyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uY29tcGFyZShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuRmFjZXQgdXNlZCB0byBwcm92aWRlIG1hcmtlcnMgdG8gdGhlIGxpbmUgbnVtYmVyIGd1dHRlci5cbiovXG5jb25zdCBsaW5lTnVtYmVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGxpbmVOdW1iZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIHsgZm9ybWF0TnVtYmVyOiBTdHJpbmcsIGRvbUV2ZW50SGFuZGxlcnM6IHt9IH0sIHtcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnMoYSwgYikge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBldmVudCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSByZXN1bHRbZXZlbnRdLCBhZGQgPSBiW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50XSA9IGV4aXN0cyA/ICh2aWV3LCBsaW5lLCBldmVudCkgPT4gZXhpc3RzKHZpZXcsIGxpbmUsIGV2ZW50KSB8fCBhZGQodmlldywgbGluZSwgZXZlbnQpIDogYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNsYXNzIE51bWJlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IobnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5udW1iZXIgPT0gb3RoZXIubnVtYmVyOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm51bWJlcik7IH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2aWV3LCBudW1iZXIpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5mb3JtYXROdW1iZXIobnVtYmVyLCB2aWV3LnN0YXRlKTtcbn1cbmNvbnN0IGxpbmVOdW1iZXJHdXR0ZXIgPSAvKkBfX1BVUkVfXyovYWN0aXZlR3V0dGVycy5jb21wdXRlKFtsaW5lTnVtYmVyQ29uZmlnXSwgc3RhdGUgPT4gKHtcbiAgICBjbGFzczogXCJjbS1saW5lTnVtYmVyc1wiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykgeyByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyTWFya2Vycyk7IH0sXG4gICAgbGluZU1hcmtlcih2aWV3LCBsaW5lLCBvdGhlcnMpIHtcbiAgICAgICAgaWYgKG90aGVycy5zb21lKG0gPT4gbS50b0RPTSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIHZpZXcuc3RhdGUuZG9jLmxpbmVBdChsaW5lLmZyb20pLm51bWJlcikpO1xuICAgIH0sXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVyc1xufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3MgPSBcImNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjtcbiAgICB9XG59O1xuY29uc3QgYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL2d1dHRlckxpbmVDbGFzcy5jb21wdXRlKFtcInNlbGVjdGlvblwiXSwgc3RhdGUgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZVBvcyA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gbGluZVBvcztcbiAgICAgICAgICAgIG1hcmtzLnB1c2goYWN0aXZlTGluZUd1dHRlck1hcmtlci5yYW5nZShsaW5lUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtzKTtcbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tYWN0aXZlTGluZUd1dHRlcmAgY2xhc3MgdG9cbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcbmxpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXI7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFZpZXdQbHVnaW4sIFZpZXdVcGRhdGUsIFdpZGdldFR5cGUsIF9fdGVzdCwgY2xvc2VIb3ZlclRvb2x0aXBzLCBjcm9zc2hhaXJDdXJzb3IsIGRyYXdTZWxlY3Rpb24sIGRyb3BDdXJzb3IsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBob3ZlclRvb2x0aXAsIGtleW1hcCwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iLCAiLy8gRklYTUUgcHJvZmlsZSBhZGRpbmcgYSBwZXItVHJlZSBUcmVlTm9kZSBjYWNoZSwgdmFsaWRhdGluZyBpdCBieVxuLy8gcGFyZW50IHBvaW50ZXJcbi8vLyBUaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlLlxuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8vLyBFYWNoIFtub2RlIHR5cGVdKCNjb21tb24uTm9kZVR5cGUpIG9yIFtpbmRpdmlkdWFsIHRyZWVdKCNjb21tb24uVHJlZSlcbi8vLyBjYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG4vLy8gY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLy8vIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLnBlck5vZGUgPSAhIWNvbmZpZy5wZXJOb2RlO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gY29uZmlnLmRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIC8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5QYXJzZXJDb25maWcucHJvcHMpIHRvIGNvbXB1dGVcbiAgICAvLy8gcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIC8vLyBpZiB0aGUgbm9kZSB0eXBlIGRvZXNuJ3QgZ2V0IHRoaXMgcHJvcCwgYW5kIHRoZSBwcm9wJ3MgdmFsdWUgaWZcbiAgICAvLy8gaXQgZG9lcy5cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuLy8vIGF0dGFjaGVkIHRvIGNsb3NpbmcgZGVsaW1pdGVycywgaG9sZGluZyBhbiBhcnJheSBvZiBub2RlIG5hbWVzXG4vLy8gb2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuTm9kZVByb3Aub3BlbmVkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxuLy8vIHR5cGVzIHRoYXQgcmVwcmVzZW50IGFuIGV4cHJlc3Npb24gY291bGQgYmUgdGFnZ2VkIHdpdGggYW5cbi8vLyBgXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbk5vZGVQcm9wLmdyb3VwID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxuLy8vIHRoYXQgdGhlIG5vZGUgd2FzIHBhcnNlZCBpbiwgaWYgYW55LiBVc2VkIHRvIGxpbWl0IHJldXNlIG9mXG4vLy8gY29udGV4dHVhbCBub2Rlcy5cbk5vZGVQcm9wLmNvbnRleHRIYXNoID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG4vLy8gbG9va2VkIGFoZWFkIGZvciBhbnkgb2YgdGhlIHRva2VucyBpbnNpZGUgdGhlIG5vZGUuIChUaGUgTFJcbi8vLyBwYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3Jcbi8vLyBlZmZpY2llbmN5IHJlYXNvbnMuKVxuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGlzIHBlci1ub2RlIHByb3AgaXMgdXNlZCB0byByZXBsYWNlIGEgZ2l2ZW4gbm9kZSwgb3IgcGFydCBvZiBhXG4vLy8gbm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuLy8vIGRpZmZlcmVudCBsYW5ndWFnZXMgaW4gbWl4ZWQtbGFuZ3VhZ2UgcGFyc2Vycy5cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIEEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG4vLy8gcmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgaW5uZXIgdHJlZS5cbiAgICB0cmVlLCBcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgLy8vIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgLy8vIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIC8vLyBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIC8vLyBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgb3ZlcmxheSwgXG4gICAgLy8vIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLy8vIERlZmluZSBhIG5vZGUgdHlwZS5cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG4vLy8gW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCNjb21tb24uVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxuLy8vIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8vLyBPcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbi8vLyBvcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbnZhciBJdGVyTW9kZTtcbihmdW5jdGlvbiAoSXRlck1vZGUpIHtcbiAgICAvLy8gV2hlbiBlbmFibGVkLCBpdGVyYXRpb24gd2lsbCBvbmx5IHZpc2l0IFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgLy8vIFtgVHJlZUJ1ZmZlcmBdKCNjb21tb24uVHJlZUJ1ZmZlcilzLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRXhjbHVkZUJ1ZmZlcnNcIl0gPSAxXSA9IFwiRXhjbHVkZUJ1ZmZlcnNcIjtcbiAgICAvLy8gRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICAvLy8gdGhlIG5vZGVzIHRoYXQgd3JhcCByZXBlYXRlZCBncmFtbWFyIGNvbnN0cnVjdHMgaW50byBhIGJhbGFuY2VkXG4gICAgLy8vIHRyZWUpLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLy8vIEJ5IGRlZmF1bHQsIHJlZ3VsYXIgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgbm9kZXNcbiAgICAvLy8gcmVwbGFjZSB0aGVpciBiYXNlIG5vZGUgaW4gaXRlcmF0aW9uLiBFbmFibGUgdGhpcyB0byBpZ25vcmUgdGhlbVxuICAgIC8vLyBpbnN0ZWFkLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlTW91bnRzXCJdID0gNF0gPSBcIklnbm9yZU1vdW50c1wiO1xuICAgIC8vLyBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgaW5cbiAgICAvLy8gW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgLy8vIGxpYnJhcnkgdG8gbm90IGVudGVyIG1vdW50ZWQgb3ZlcmxheXMgaWYgb25lIGNvdmVycyB0aGUgZ2l2ZW5cbiAgICAvLy8gcG9zaXRpb24uXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8vLyBBIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2Vcbi8vLyB0cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG4vLy8gY29udmVuaWVudCB3YXkuXG4vLy9cbi8vLyBTeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbi8vLyBvYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG4vLy8gbm9kZXMsIHRoZSByZXByZXNlbnRhdGlvbiBpcyBtYWRlIGEgbG90IG1vcmUgbWVtb3J5LWVmZmljaWVudC5cbi8vL1xuLy8vIEhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbi8vLyByZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG4vLy8gdXNlIHRoZSBbYFRyZWVDdXJzb3JgXSgjY29tbW9uLlRyZWVDdXJzb3IpIG9yXG4vLy8gW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbi8vLyBhIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xuLy8vIG1vdmUgYXJvdW5kIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBTZWUgYWxzbyBbYFRyZWUuYnVpbGRgXSgjY29tbW9uLlRyZWVeYnVpbGQpLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgdHlwZSwgXG4gICAgLy8vIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgIGNoaWxkcmVuLCBcbiAgICAvLy8gVGhlIHBvc2l0aW9ucyAob2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhpcyB0cmVlKSBvZlxuICAgIC8vLyB0aGUgY2hpbGRyZW4uXG4gICAgcG9zaXRpb25zLCBcbiAgICAvLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRyZWVcbiAgICBsZW5ndGgsIFxuICAgIC8vLyBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgIHByb3BzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWx1ZV0gb2YgcHJvcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc1t0eXBlb2YgcHJvcCA9PSBcIm51bWJlclwiID8gcHJvcCA6IHByb3AuaWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IHRoaXMucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb3NpdGlvbmVkIGF0IHRoZSB0b3Agb2ZcbiAgICAvLy8gdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgLy8vIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgIGN1cnNvcihtb2RlID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCBtb2RlKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIC8vLyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIC8vLyBbYG1vdmVUb2BdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pLlxuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLy8gSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICAvLy8gZnJvbSBib3RoIHNpZGVzLlxuICAgIC8vL1xuICAgIC8vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIC8vLyBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIC8vLyBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpIGluc3RlYWQuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKHNwZWMubW9kZSB8fCAwKSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmICFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMpO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIC8vLyBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgIHByb3AocHJvcCkge1xuICAgICAgICByZXR1cm4gIXByb3AucGVyTm9kZSA/IHRoaXMudHlwZS5wcm9wKHByb3ApIDogdGhpcy5wcm9wcyA/IHRoaXMucHJvcHNbcHJvcC5pZF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICAvLy8gZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIC8vLyBjb25zdHJ1Y3Rvci5cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICAvLy8gd2hpY2ggbWF5IGhhdmUgY2hpbGRyZW4gZ3JvdXBlZCBpbnRvIHN1YnRyZWVzIHdpdGggdHlwZVxuICAgIC8vLyBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdCkuXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgY29weSA9IG5ldyBVaW50MTZBcnJheShlbmRJIC0gc3RhcnRJKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSwgaiA9IDA7IGkgPCBlbmRJOykge1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBzdGFydEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIHRvIC0gZnJvbSwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBBdE9yQmVmb3JlICovOiByZXR1cm4gdG8gPj0gcG9zICYmIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgMCAvKiBBcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBBZnRlciAqLzogcmV0dXJuIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDQgLyogRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKG5vZGUsIHBvcykge1xuICAgIGxldCBzY2FuID0gbm9kZS5jaGlsZEJlZm9yZShwb3MpO1xuICAgIHdoaWxlIChzY2FuKSB7XG4gICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0LnByZXZTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NhbiA9IGxhc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlLCBmcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fdHJlZSA9IF90cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3RyZWUudG9TdHJpbmcoKTsgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7IHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hOb2RlQ29udGV4dChub2RlLCBjb250ZXh0LCBpID0gY29udGV4dC5sZW5ndGggLSAxKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGUucGFyZW50OyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGFmdGVyIDwgKHRoaXMuX3BhcmVudCA/IGJ1ZmZlci5idWZmZXJbdGhpcy5fcGFyZW50LmluZGV4ICsgM10gOiBidWZmZXIuYnVmZmVyLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKDEpO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoLTEpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHsgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcywgY29udGV4dCk7IH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG1vZGUgPSAwKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgY2hpbGQgYXJvdW5kIGBwb3NgLiBJZiBzaWRlIGlzIC0xIHRoZVxuICAgIC8vLyBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICAvLy8gd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIC8vLyBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0cmVlcyB1bmxlc3MgYG92ZXJsYXlzYCBpc1xuICAgIC8vLyBzZXQgdG8gZmFsc2UuXG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gdGhpcy5tb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgbW9kZSkpO1xuICAgICAgICByZXR1cm4gbW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzID8gZmFsc2UgOiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIC8vLyBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgLy8vIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICAvLy8gc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh0XHUyMDE0YSBzZXF1ZW5jZVxuICAgIC8vLyBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICAvLy8gYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBSZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLykgeyAvLyBDb250ZXh0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBMb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLykge1xuICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8vLyBQcm92aWRlcyBhIHdheSB0byBhc3NvY2lhdGUgdmFsdWVzIHdpdGggcGllY2VzIG9mIHRyZWVzLiBBcyBsb25nXG4vLy8gYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxuLy8vIHJldHJpZXZlZCBmcm9tIGFuIHVwZGF0ZWQgdHJlZS5cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZS5cbiAgICBzZXQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQobm9kZS50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlID8gdGhpcy5nZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleClcbiAgICAgICAgICAgIDogbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlID8gdGhpcy5tYXAuZ2V0KG5vZGUudHJlZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLyBTZXQgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHMgdG8uXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmUgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHNcbiAgICAvLy8gdG8uXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8vLyBUcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG4vLy8gcGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG4vLy8gdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXMgdXNlZFxuLy8vIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkIGluIG5ld1xuLy8vIHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvXG4vLy8gdXBkYXRlIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgLy8vIENvbnN0cnVjdCBhIHRyZWUgZnJhZ21lbnQuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlXG4gICAgLy8vIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIC8vLyBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgaW5zdGVhZCBvZlxuICAgIC8vLyBjYWxsaW5nIHRoaXMgZGlyZWN0bHkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICAvLy8gVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICAvLy8gdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgIGZyb20sIFxuICAgIC8vLyBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgdG8sIFxuICAgIC8vLyBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgdHJlZSwgXG4gICAgLy8vIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIC8vLyB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIC8vLyBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgLy8vIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gKG9wZW5TdGFydCA/IDEgLyogU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBFbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgLy8vIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgLy8vIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcbiAgICAvLy8gZnVsbC1kb2N1bWVudCBwYXJzZSwgb3IgdGhlIHN0YXJ0IG9mIGEgY2hhbmdlLlxuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogRW5kICovKSA+IDA7IH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgLy8vIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICAvLy8gdHJ1ZS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgZmFsc2UsIHBhcnRpYWwpXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIC8vLyBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgLy8vIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLy8gQSBzdXBlcmNsYXNzIHRoYXQgcGFyc2VycyBzaG91bGQgZXh0ZW5kLlxuY2xhc3MgUGFyc2VyIHtcbiAgICAvLy8gU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICAgIC8vLyBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICAvLy8gbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gICAgLy8vXG4gICAgLy8vIEJ5IGRlZmF1bHQsIHRoZSBlbnRpcmUgaW5wdXQgaXMgcGFyc2VkLiBZb3UgY2FuIHBhc3MgYHJhbmdlc2AsXG4gICAgLy8vIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIC8vLyByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XG4gICAgLy8vIGNhc2Ugd2lsbCBzdGFydCBhdCBgcmFuZ2VzWzBdLmZyb21gLlxuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvLy8gUnVuIGEgZnVsbCBwYXJzZSwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gdGhpcy5zdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgY2h1bmsoZnJvbSkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSk7IH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgdG8pOyB9XG59XG5cbi8vLyBDcmVhdGUgYSBwYXJzZSB3cmFwcGVyIHRoYXQsIGFmdGVyIHRoZSBpbm5lciBwYXJzZSBjb21wbGV0ZXMsXG4vLy8gc2NhbnMgaXRzIHRyZWUgZm9yIG1peGVkIGxhbmd1YWdlIHJlZ2lvbnMgd2l0aCB0aGUgYG5lc3RgXG4vLy8gZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbi8vLyBhbmQgdGhlbiBbbW91bnRzXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRoZWlyIHJlc3VsdHMgb250byB0aGVcbi8vLyB0cmVlLlxuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XG4gICAgcmV0dXJuIChwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSA9PiBuZXcgTWl4ZWRQYXJzZShwYXJzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbn1cbmNsYXNzIElubmVyUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyc2UsIG92ZXJsYXksIHRhcmdldCwgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHByZWRpY2F0ZSwgbW91bnRzLCBpbmRleCwgc3RhcnQsIHRhcmdldCwgcHJldikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMubW91bnRzID0gbW91bnRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIH1cbn1cbmNvbnN0IHN0b3BwZWRJbm5lciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG5jbGFzcyBNaXhlZFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZXN0ID0gbmVzdDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xuICAgICAgICB0aGlzLmJhc2VUcmVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VUcmVlID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5uZXIgb2YgdGhpcy5pbm5lcilcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRyZWUocmVzdWx0LnR5cGUsIHJlc3VsdC5jaGlsZHJlbiwgcmVzdWx0LnBvc2l0aW9ucywgcmVzdWx0Lmxlbmd0aCwgcmVzdWx0LnByb3BWYWx1ZXMuY29uY2F0KFtbc3RvcHBlZElubmVyLCB0aGlzLnN0b3BwZWRBdF1dKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMuaW5uZXJbdGhpcy5pbm5lckRvbmVdLCBkb25lID0gaW5uZXIucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb21ld2hhdCBkb2RneSBidXQgc3VwZXIgaGVscGZ1bCBoYWNrIHdoZXJlIHdlXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcbiAgICAgICAgICAgIC8vIHByZXN1bWFibHkgbm90IGFsaWFzZWQgYW55d2hlcmUgZWxzZSkgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFib3V0IHRoZSBpbm5lciBwYXJzZS5cbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcbiAgICAgICAgICAgIHByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdID0gbmV3IE1vdW50ZWRUcmVlKGRvbmUsIGlubmVyLm92ZXJsYXksIGlubmVyLnBhcnNlcik7XG4gICAgICAgICAgICBpbm5lci50YXJnZXQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5uZXJbaV0ucmFuZ2VzWzBdLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgfHwgY3Vyc29yLmZyb20gPCB0aGlzLnN0b3BwZWRBdDspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIEZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iLCAiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vLy8gSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG4vLy8gVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG4vLy8gdHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG4vLy8gYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuLy8vXG4vLy8gQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbi8vLyBhYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuLy8vIFt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG4vLy8gdHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuLy8vIGhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG4vLy8gdmFyaW91cyBsYW5ndWFnZXMpLlxuLy8vXG4vLy8gSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG4vLy8gaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbi8vLyB0aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuLy8vIGJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbi8vLyBmcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG5jbGFzcyBUYWcge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIC8vLyB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgIHNldCwgXG4gICAgLy8vIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICAvLy8gbW9kaWZpZWQgQGludGVybmFsXG4gICAgYmFzZSwgXG4gICAgLy8vIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICAvLy8gc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kXG4gICAgLy8vIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIC8vLyB0aGlzIHRhZyB3aWxsIHRyeSB0byBmYWxsIGJhY2sgdG8gdGhlIHBhcmVudCB0YWcgKG9yIGdyYW5kcGFyZW50XG4gICAgLy8vIHRhZywgZXRjKS5cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICAvLy8gd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIC8vLyBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgLy8vID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIC8vLyBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICAvLy9cbiAgICAvLy8gV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIC8vLyBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICAvLy8gZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgLy8vIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKCkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxuLy8vIHZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3Jcbi8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuLy8vXG4vLy8gVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbi8vLyB0YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG4vLy9cbi8vLyBOb2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuLy8vIFN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG4vLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG4vLy8gY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxuLy8vIG90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuLy8vIGJ1dCBvbmx5IGEgc2luZ2xlIGxldmVsXHUyMDE0d2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxuLy8vIHRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG4vLy9cbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxuLy8vIHRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG4vLy8gbWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbi8vLyB1c2VkKS5cbi8vL1xuLy8vIFdoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG4vLy8gZ2l2ZW4gc3R5bGUuXG4vLy9cbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxuLy8vIG11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cbi8vL1xuLy8vIEZvciBleGFtcGxlOlxuLy8vXG4vLy8gYGBgamF2YXNjcmlwdFxuLy8vIHBhcnNlci53aXRoUHJvcHMoXG4vLy8gICBzdHlsZVRhZ3Moe1xuLy8vICAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4vLy8gICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4vLy8gICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbi8vLyAgICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4vLy8gICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4vLy8gICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4vLy8gICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4vLy8gICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbi8vLyAgIH0pXG4vLy8gKVxuLy8vIGBgYFxuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE5vcm1hbCAqLywgcmVzdCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ID09IFwiLi4uXCIgJiYgcG9zID4gMCAmJiBwb3MgKyAzID09IHBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMSAvKiBJbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE9wYXF1ZSAqLzsgfVxuICAgIGdldCBpbmhlcml0KCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDEgLyogSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE5vcm1hbCAqLywgbnVsbCk7XG4vLy8gRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG4vLy8gdGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxuLy8vIHRha2UgcHJlY2VkZW5jZS5cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vLyBIaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG4vLy8gW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLy8vIEFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbi8vLyBvZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbi8vLyBgY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxucHV0U3R5bGUsIFxuLy8vIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuZnJvbSA9IDAsIFxuLy8vIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG5jbGFzcyBIaWdobGlnaHRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlcnMgPSBoaWdobGlnaHRlcnM7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuY2xhc3MgPSBcIlwiO1xuICAgIH1cbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgICAgICB0aGlzLmNsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKHRvKSB7XG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuc3Bhbih0aGlzLmF0LCB0bywgdGhpcy5jbGFzcyk7XG4gICAgfVxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZnJvbTogc3RhcnQsIHRvOiBlbmQgfSA9IGN1cnNvcjtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZS5pc1RvcClcbiAgICAgICAgICAgIGhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUodHlwZSkpO1xuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XG4gICAgICAgIGxldCBydWxlID0gZ2V0U3R5bGVUYWdzKGN1cnNvcikgfHwgUnVsZS5lbXB0eTtcbiAgICAgICAgbGV0IHRhZ0NscyA9IGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCBydWxlLnRhZ3MpO1xuICAgICAgICBpZiAodGFnQ2xzKSB7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XG4gICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKGN1cnNvci5mcm9tLCBjbHMpO1xuICAgICAgICBpZiAocnVsZS5vcGFxdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtb3VudGVkID0gY3Vyc29yLnRyZWUgJiYgY3Vyc29yLnRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBjdXJzb3Iubm9kZS5lbnRlcihtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIGxldCBpbm5lckhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobW91bnRlZC50cmVlLnR5cGUpKTtcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGkgPCBtb3VudGVkLm92ZXJsYXkubGVuZ3RoID8gbW91bnRlZC5vdmVybGF5W2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKSwgcmFuZ2VUbyA9IE1hdGgubWluKHRvLCBuZXh0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VGcm9tIDwgcmFuZ2VUbyAmJiBoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgcmFuZ2VGcm9tLCByYW5nZVRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgaW5oZXJpdGVkQ2xhc3MsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4ocG9zLCBjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZClcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8vIE1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG4vLy8gdGhlcmUncyBhIG1hdGNoLCByZXR1cm4gaXRzIHNldCBvZiB0YWdzLCBhbmQgd2hldGhlciBpdCBpc1xuLy8vIG9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG5mdW5jdGlvbiBnZXRTdHlsZVRhZ3Mobm9kZSkge1xuICAgIGxldCBydWxlID0gbm9kZS50eXBlLnByb3AocnVsZU5vZGVQcm9wKTtcbiAgICB3aGlsZSAocnVsZSAmJiBydWxlLmNvbnRleHQgJiYgIW5vZGUubWF0Y2hDb250ZXh0KHJ1bGUuY29udGV4dCkpXG4gICAgICAgIHJ1bGUgPSBydWxlLm5leHQ7XG4gICAgcmV0dXJuIHJ1bGUgfHwgbnVsbDtcbn1cbmNvbnN0IHQgPSBUYWcuZGVmaW5lO1xuY29uc3QgY29tbWVudCA9IHQoKSwgbmFtZSA9IHQoKSwgdHlwZU5hbWUgPSB0KG5hbWUpLCBwcm9wZXJ0eU5hbWUgPSB0KG5hbWUpLCBsaXRlcmFsID0gdCgpLCBzdHJpbmcgPSB0KGxpdGVyYWwpLCBudW1iZXIgPSB0KGxpdGVyYWwpLCBjb250ZW50ID0gdCgpLCBoZWFkaW5nID0gdChjb250ZW50KSwga2V5d29yZCA9IHQoKSwgb3BlcmF0b3IgPSB0KCksIHB1bmN0dWF0aW9uID0gdCgpLCBicmFja2V0ID0gdChwdW5jdHVhdGlvbiksIG1ldGEgPSB0KCk7XG4vLy8gVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuLy8vXG4vLy8gVGhpcyBjb2xsZWN0aW9uIGlzIGhlYXZpbHkgYmlhc2VkIHRvd2FyZHMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLFxuLy8vIGFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG4vLy8gY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xuLy8vIHdyaXRlIHRoZW1lcyBmb3IuIFNvIHRyeSB0byBtYWtlIGRvIHdpdGggdGhpcyBzZXQuIElmIGFsbCBlbHNlXG4vLy8gZmFpbHMsIFtvcGVuIGFuXG4vLy8gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG4vLy8gbmV3IHRhZywgb3IgW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSBhIGxvY2FsIGN1c3RvbSB0YWcgZm9yXG4vLy8geW91ciB1c2UgY2FzZS5cbi8vL1xuLy8vIE5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG4vLy8gdGFnIHBvc3NpYmxlIHRvIGFuIGVsZW1lbnRcdTIwMTRpZiB5b3VyIGdyYW1tYXIgY2FuJ3QgZWFzaWx5XG4vLy8gZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbi8vLyBpdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG4vLy8gXG4vLy8gRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xuLy8vIHRoZSBwYXJlbnQuXG5jb25zdCB0YWdzID0ge1xuICAgIC8vLyBBIGNvbW1lbnQuXG4gICAgY29tbWVudCxcbiAgICAvLy8gQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLy8vIEEgYmxvY2sgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLy8vIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGRvY0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLy8vIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgbmFtZSxcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgICAvLy8gQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvLy8gQSBwcm9wZXJ0eSBvciBmaWVsZCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8vLyBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgIGF0dHJpYnV0ZU5hbWU6IHQocHJvcGVydHlOYW1lKSxcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgbGFiZWwgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgbmFtZXNwYWNlOiB0KG5hbWUpLFxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSBsaXRlcmFsIHZhbHVlLlxuICAgIGxpdGVyYWwsXG4gICAgLy8vIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgc3RyaW5nLFxuICAgIC8vLyBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLy8vIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLy8vIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICBhdHRyaWJ1dGVWYWx1ZTogdChzdHJpbmcpLFxuICAgIC8vLyBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIG51bWJlcixcbiAgICAvLy8gQW4gaW50ZWdlciBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvLy8gQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgIGZsb2F0OiB0KG51bWJlciksXG4gICAgLy8vIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLy8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvLy8gQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICAvLy8gYmFja3NsYXNoIGVzY2FwZSBpbiBhIHN0cmluZy5cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBjb2xvcjogdChsaXRlcmFsKSxcbiAgICAvLy8gQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgbGFuZ3VhZ2Uga2V5d29yZC5cbiAgICBrZXl3b3JkLFxuICAgIC8vLyBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIC8vLyBvYmplY3QuXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgbnVsbDogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IHJlcHJlc2VudHMgYSB1bml0LlxuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICBtb2RpZmllcjogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgY29udHJvbC1mbG93IHJlbGF0ZWQgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgZGVmaW5pdGlvbktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgLy8vIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICBtb2R1bGVLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBbiBvcGVyYXRvci5cbiAgICBvcGVyYXRvcixcbiAgICAvLy8gQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVyZWZlcmVuY2VzIHNvbWV0aGluZy5cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8vLyBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICAvLy8gdGhpbmdzLlxuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLy8vIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgIGJyYWNrZXQsXG4gICAgLy8vIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgLy8vIHRva2VucykuXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8vLyBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICAvLy8gdG9rZW5zKS5cbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8vLyBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBwYXJlbjogdChicmFja2V0KSxcbiAgICAvLy8gQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIC8vLyBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxuICAgIC8vLyBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgIGNvbnRlbnQsXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgICBoZWFkaW5nLFxuICAgIC8vLyBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICAvLy8gbW9ub3NwYWNlLlxuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgLy8vIHN0eWxlLlxuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLy8vIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgIGluc2VydGVkOiB0KCksXG4gICAgLy8vIERlbGV0ZWQgdGV4dC5cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLy8vIENoYW5nZWQgdGV4dC5cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLy8vIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLy8vIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgbWV0YSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICAvLy8gZG9jdW1lbnQuXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8vLyBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgLy8vIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8vLyBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIC8vLyBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgLy8vIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIC8vLyB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vLyBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIC8vLyBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgLy8vIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgLy8vIGFzIGEgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICAvLy8gdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgLy8vIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIC8vLyBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICAvLy8gZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIC8vLyBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICAvLy8gY29tZSB1cCBhIGxvdC5cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8vLyBUaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xuLy8vIHRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG4vLy9cbi8vLyBUaGUgZm9sbG93aW5nIHRhZ3MgYXJlIG1hcHBlZCB0byB0aGVpciBuYW1lIHByZWZpeGVkIHdpdGggYFwidG9rLVwiYFxuLy8vIChmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG4vLy9cbi8vLyAqIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuLy8vICogW2BoZWFkaW5nYF0oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4vLy8gKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuLy8vICogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuLy8vICogW2BrZXl3b3JkYF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4vLy8gKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbi8vLyAqIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuLy8vICogW2B1cmxgXSgjaGlnaGxpZ2h0LnRhZ3MudXJsKVxuLy8vICogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuLy8vICogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbi8vLyAqIFtgZGVsZXRlZGBdKCNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuLy8vICogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4vLy8gKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4vLy8gKiBbYG51bWJlcmBdKCNoaWdobGlnaHQudGFncy5udW1iZXIpXG4vLy8gKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuLy8vICogW2BuYW1lc3BhY2VgXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuLy8vICogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuLy8vICogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuLy8vICogW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuLy8vICogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbi8vLyAqIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuLy8vICogW2BtZXRhYF0oI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4vLy8gKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuLy8vICogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG4vLy9cbi8vLyBJbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxuLy8vXG4vLy8gKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuLy8vICAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4vLy8gICBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYChzdHJpbmcpYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbi8vLyAgIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbi8vLyAqIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZTJcImBcbi8vLyAqIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuLy8vICogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4vLy8gKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbi8vLyAgIHRvIGBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cImBcbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiIsICJpbXBvcnQgeyBOb2RlUHJvcCwgSXRlck1vZGUsIFRyZWUsIFRyZWVGcmFnbWVudCwgUGFyc2VyLCBOb2RlVHlwZSwgTm9kZVNldCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGd1dHRlciwgR3V0dGVyTWFya2VyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyB0YWdzLCB0YWdIaWdobGlnaHRlciwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5cbnZhciBfYTtcbi8qKlxuTm9kZSBwcm9wIHN0b3JlZCBpbiBhIHBhcnNlcidzIHRvcCBzeW50YXggbm9kZSB0byBwcm92aWRlIHRoZVxuZmFjZXQgdGhhdCBzdG9yZXMgbGFuZ3VhZ2Utc3BlY2lmaWMgZGF0YSBmb3IgdGhhdCBsYW5ndWFnZS5cbiovXG5jb25zdCBsYW5ndWFnZURhdGFQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZmFjZXQgKHRvIGJlIGFkZGVkIHRvIHRoZSB0b3Agc3ludGF4XG5ub2RlKHMpIGZvciBhIGxhbmd1YWdlIHZpYVxuW2BsYW5ndWFnZURhdGFQcm9wYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSksIHRoYXQgd2lsbCBiZVxudXNlZCB0byBhc3NvY2lhdGUgbGFuZ3VhZ2UgZGF0YSB3aXRoIHRoZSBsYW5ndWFnZS4gWW91XG5wcm9iYWJseSBvbmx5IG5lZWQgdGhpcyB3aGVuIHN1YmNsYXNzaW5nXG5bYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkuXG4qL1xuZnVuY3Rpb24gZGVmaW5lTGFuZ3VhZ2VGYWNldChiYXNlRGF0YSkge1xuICAgIHJldHVybiBGYWNldC5kZWZpbmUoe1xuICAgICAgICBjb21iaW5lOiBiYXNlRGF0YSA/IHZhbHVlcyA9PiB2YWx1ZXMuY29uY2F0KGJhc2VEYXRhKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xufVxuLyoqXG5BIGxhbmd1YWdlIG9iamVjdCBtYW5hZ2VzIHBhcnNpbmcgYW5kIHBlci1sYW5ndWFnZVxuW21ldGFkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS4gUGFyc2UgZGF0YSBpc1xubWFuYWdlZCBhcyBhIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldCkgdHJlZS4gVGhlIGNsYXNzXG5jYW4gYmUgdXNlZCBkaXJlY3RseSwgdmlhIHRoZSBbYExSTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxSTGFuZ3VhZ2UpXG5zdWJjbGFzcyBmb3IgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0LykgTFIgcGFyc2Vycywgb3JcbnZpYSB0aGUgW2BTdHJlYW1MYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtTGFuZ3VhZ2UpIHN1YmNsYXNzXG5mb3Igc3RyZWFtIHBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIGxhbmd1YWdlIG9iamVjdC4gSWYgeW91IG5lZWQgdG8gaW52b2tlIHRoaXNcbiAgICBkaXJlY3RseSwgZmlyc3QgZGVmaW5lIGEgZGF0YSBmYWNldCB3aXRoXG4gICAgW2BkZWZpbmVMYW5ndWFnZUZhY2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZpbmVMYW5ndWFnZUZhY2V0KSwgYW5kIHRoZW5cbiAgICBjb25maWd1cmUgeW91ciBwYXJzZXIgdG8gW2F0dGFjaF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSBpdFxuICAgIHRvIHRoZSBsYW5ndWFnZSdzIG91dGVyIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIFtsYW5ndWFnZSBkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBmYWNldFxuICAgIHVzZWQgZm9yIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBkYXRhLCBwYXJzZXIsIGV4dHJhRXh0ZW5zaW9ucyA9IFtdLCBcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIG5hbWUuXG4gICAgKi9cbiAgICBuYW1lID0gXCJcIikge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gZGVmaW5lIEVkaXRvclN0YXRlLnRyZWUgYXMgYSBkZWJ1Z2dpbmcgaGVscGVyLFxuICAgICAgICAvLyB3aXRob3V0IHRoZSBFZGl0b3JTdGF0ZSBwYWNrYWdlIGFjdHVhbGx5IGtub3dpbmcgYWJvdXRcbiAgICAgICAgLy8gbGFuZ3VhZ2VzIGFuZCBsZXplciB0cmVlcy5cbiAgICAgICAgaWYgKCFFZGl0b3JTdGF0ZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJ0cmVlXCIpKVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkaXRvclN0YXRlLnByb3RvdHlwZSwgXCJ0cmVlXCIsIHsgZ2V0KCkgeyByZXR1cm4gc3ludGF4VHJlZSh0aGlzKTsgfSB9KTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW1xuICAgICAgICAgICAgbGFuZ3VhZ2Uub2YodGhpcyksXG4gICAgICAgICAgICBFZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEub2YoKHN0YXRlLCBwb3MsIHNpZGUpID0+IHN0YXRlLmZhY2V0KGxhbmd1YWdlRGF0YUZhY2V0QXQoc3RhdGUsIHBvcywgc2lkZSkpKVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGxhbmd1YWdlRGF0YUZhY2V0QXQoc3RhdGUsIHBvcywgc2lkZSkge1xuICAgIGxldCB0b3BMYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgIGlmICghdG9wTGFuZylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZhY2V0ID0gdG9wTGFuZy5kYXRhO1xuICAgIGlmICh0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgZmFjZXQgPSBub2RlLnR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSB8fCBmYWNldDtcbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0O1xufVxuLyoqXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcbltMUiBwYXJzZXJzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xyLkxSUGFyc2VyKVxucGFyc2Vycy5cbiovXG5jbGFzcyBMUkxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHBhcnNlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIGxhbmd1YWdlIGZyb20gYSBwYXJzZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHNwZWMubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKGRhdGEsIHNwZWMucGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxuICAgICAgICB9KSwgc3BlYy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICAgIHZlcnNpb24gb2YgaXRzIHBhcnNlciBhbmQgb3B0aW9uYWxseSBhIG5ldyBuYW1lLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpLCBuYW1lIHx8IHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdGhpcy5wYXJzZXIuaGFzV3JhcHBlcnMoKTsgfVxufVxuLyoqXG5HZXQgdGhlIHN5bnRheCB0cmVlIGZvciBhIHN0YXRlLCB3aGljaCBpcyB0aGUgY3VycmVudCAocG9zc2libHlcbmluY29tcGxldGUpIHBhcnNlIHRyZWUgb2YgdGhlIGFjdGl2ZVxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cbmxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIHJldHVybiAhcGFyc2UgPyBudWxsIDogcGFyc2UuaXNEb25lKHVwdG8pIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbn1cbi8qKlxuUXVlcmllcyB3aGV0aGVyIHRoZXJlIGlzIGEgZnVsbCBzeW50YXggdHJlZSBhdmFpbGFibGUgdXAgdG8gdGhlXG5naXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gSWYgdGhlcmUgaXNuJ3QsIHRoZSBiYWNrZ3JvdW5kIHBhcnNlXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxudGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHRoYXRcdTIwMTR0aGUgcGFyc2VyIHdpbGwgW3N0b3BcbndvcmtpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4UGFyc2VyUnVubmluZykgd2hlbiBpdCBoYXMgc3BlbnQgYVxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxuQWx3YXlzIHJldHVybnMgZmFsc2UgaWYgbm8gbGFuZ3VhZ2UgaGFzIGJlZW4gZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0LmlzRG9uZSh1cHRvKSkgfHwgZmFsc2U7XG59XG4vKipcbk1vdmUgcGFyc2luZyBmb3J3YXJkLCBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igc3RhdGUgYWZ0ZXJ3YXJkcyB0b1xucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcbm1pbGxpc2Vjb25kcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJzZXIgbWFuYWdlZCBnZXQgdG8gdGhlIGdpdmVuXG5wb3NpdGlvbiBpbiB0aGF0IHRpbWUuXG4qL1xuZnVuY3Rpb24gZm9yY2VQYXJzaW5nKHZpZXcsIHVwdG8gPSB2aWV3LnZpZXdwb3J0LnRvLCB0aW1lb3V0ID0gMTAwKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBlbnN1cmVTeW50YXhUcmVlKHZpZXcuc3RhdGUsIHVwdG8sIHRpbWVvdXQpO1xuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe30pO1xuICAgIHJldHVybiAhIXN1Y2Nlc3M7XG59XG4vKipcblRlbGxzIHlvdSB3aGV0aGVyIHRoZSBsYW5ndWFnZSBwYXJzZXIgaXMgcGxhbm5pbmcgdG8gZG8gbW9yZVxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcbnN0b3BwZWQgcnVubmluZywgZWl0aGVyIGJlY2F1c2UgaXQgcGFyc2VkIHRoZSBlbnRpcmUgZG9jdW1lbnQsXG5iZWNhdXNlIGl0IHNwZW50IHRvbyBtdWNoIHRpbWUgYW5kIHdhcyBjdXQgb2ZmLCBvciBiZWNhdXNlIHRoZXJlXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhQYXJzZXJSdW5uaW5nKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwYXJzZVdvcmtlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1dvcmtpbmcoKSkgfHwgZmFsc2U7XG59XG4vLyBMZXplci1zdHlsZSBJbnB1dCBvYmplY3QgZm9yIGEgVGV4dCBkb2N1bWVudC5cbmNsYXNzIERvY0lucHV0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIGxlbmd0aCA9IGRvYy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcoKTtcbiAgICB9XG4gICAgaXNXb3JraW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy53b3JraW5nIHx8IHRoaXMud29ya1NjaGVkdWxlZCA+IDApO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS4gVXNlZFxuYnkgYExhbmd1YWdlYCBvYmplY3QncyBgZXh0ZW5zaW9uYCBwcm9wZXJ0eSAoc28geW91IGRvbid0IG5lZWQgdG9cbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcbmN1cnJlbnQgbGFuZ3VhZ2Ugb24gYSBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBsYW5ndWFnZSA9PiBbXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxuICAgICAgICBwYXJzZVdvcmtlcixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCBmb3Igb3ZlcnJpZGluZyB0aGUgdW5pdCBieSB3aGljaCBpbmRlbnRhdGlvbiBoYXBwZW5zLlxuU2hvdWxkIGJlIGEgc3RyaW5nIGNvbnNpc3RpbmcgZWl0aGVyIGVudGlyZWx5IG9mIHNwYWNlcyBvclxuZW50aXJlbHkgb2YgdGFicy4gV2hlbiBub3Qgc2V0LCB0aGlzIGRlZmF1bHRzIHRvIDIgc3BhY2VzLlxuKi9cbmNvbnN0IGluZGVudFVuaXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXCIgIFwiO1xuICAgICAgICBpZiAoIS9eKD86ICt8XFx0KykkLy50ZXN0KHZhbHVlc1swXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm4gdGhlIF9jb2x1bW4gd2lkdGhfIG9mIGFuIGluZGVudCB1bml0IGluIHRoZSBzdGF0ZS5cbkRldGVybWluZWQgYnkgdGhlIFtgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdClcbmZhY2V0LCBhbmQgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSB3aGVuIHRoYXRcbmNvbnRhaW5zIHRhYnMuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50VW5pdChzdGF0ZSkge1xuICAgIGxldCB1bml0ID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgcmV0dXJuIHVuaXQuY2hhckNvZGVBdCgwKSA9PSA5ID8gc3RhdGUudGFiU2l6ZSAqIHVuaXQubGVuZ3RoIDogdW5pdC5sZW5ndGg7XG59XG4vKipcbkNyZWF0ZSBhbiBpbmRlbnRhdGlvbiBzdHJpbmcgdGhhdCBjb3ZlcnMgY29sdW1ucyAwIHRvIGBjb2xzYC5cbldpbGwgdXNlIHRhYnMgZm9yIGFzIG11Y2ggb2YgdGhlIGNvbHVtbnMgYXMgcG9zc2libGUgd2hlbiB0aGVcbltgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgZmFjZXQgY29udGFpbnNcbnRhYnMuXG4qL1xuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0YXRlLCBjb2xzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCIsIHRzID0gc3RhdGUudGFiU2l6ZTtcbiAgICBpZiAoc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkuY2hhckNvZGVBdCgwKSA9PSA5KVxuICAgICAgICB3aGlsZSAoY29scyA+PSB0cykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBjb2xzIC09IHRzO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUgPyBzeW50YXhJbmRlbnRhdGlvbihjb250ZXh0LCB0cmVlLCBwb3MpIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGEgY2hhbmdlIHNldCB0aGF0IGF1dG8taW5kZW50cyBhbGwgbGluZXMgdG91Y2hlZCBieSB0aGVcbmdpdmVuIGRvY3VtZW50IHJhbmdlLlxuKi9cbmZ1bmN0aW9uIGluZGVudFJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IG92ZXJyaWRlSW5kZW50YXRpb246IHN0YXJ0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdXBkYXRlZFtzdGFydF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xOyB9IH0pO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0pIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbn1cbi8qKlxuSW5kZW50YXRpb24gY29udGV4dHMgYXJlIHVzZWQgd2hlbiBjYWxsaW5nIFtpbmRlbnRhdGlvblxuc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkuIFRoZXkgcHJvdmlkZSBoZWxwZXIgdXRpbGl0aWVzXG51c2VmdWwgaW4gaW5kZW50YXRpb24gbG9naWMsIGFuZCBjYW4gc2VsZWN0aXZlbHkgb3ZlcnJpZGUgdGhlXG5pbmRlbnRhdGlvbiByZXBvcnRlZCBmb3Igc29tZSBsaW5lcy5cbiovXG5jbGFzcyBJbmRlbnRDb250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5kZW50IGNvbnRleHQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51bml0ID0gZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgdGFraW5nXG4gICAgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGludG8gYWNjb3VudC4gSWYgdGhlcmUgaXMgc3VjaCBhIGJyZWFrIGF0IGBwb3NgLCB0aGUgYGJpYXNgXG4gICAgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGxpbmUgYmVmb3JlIG9yXG4gICAgYWZ0ZXIgdGhlIGJyZWFrIGlzIHVzZWQuXG4gICAgKi9cbiAgICBsaW5lQXQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgeyBzaW11bGF0ZUJyZWFrLCBzaW11bGF0ZURvdWJsZUJyZWFrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChzaW11bGF0ZUJyZWFrICE9IG51bGwgJiYgc2ltdWxhdGVCcmVhayA+PSBsaW5lLmZyb20gJiYgc2ltdWxhdGVCcmVhayA8PSBsaW5lLnRvKSB7XG4gICAgICAgICAgICBpZiAoc2ltdWxhdGVEb3VibGVCcmVhayAmJiBzaW11bGF0ZUJyZWFrID09IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBcIlwiLCBmcm9tOiBwb3MgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJpYXMgPCAwID8gc2ltdWxhdGVCcmVhayA8IHBvcyA6IHNpbXVsYXRlQnJlYWsgPD0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZShzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogc2ltdWxhdGVCcmVhayB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZSgwLCBzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogbGluZS5mcm9tIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgcG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAgICAqL1xuICAgIHRleHRBZnRlclBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBwb3MgPT0gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UocG9zIC0gZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHBvcyArIDEwMCAtIGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb2x1bW4ocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCBwb3MgLSBmcm9tKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24gPyB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbihmcm9tKSA6IC0xO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBvdmVycmlkZSAtIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gcG9zaXRpb24gKHRha2luZyB0YWJzIGludG8gYWNjb3VudCkgb2YgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGNvdW50Q29sdW1uKGxpbmUsIHBvcyA9IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbHVtbihsaW5lLCB0aGlzLnN0YXRlLnRhYlNpemUsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgKi9cbiAgICBsaW5lSW5kZW50KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb247XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGZyb20pO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlbiA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBmb3IgdGhpcyBjb250ZXh0LCBpZiBhbnkuXG4gICAgKi9cbiAgICBnZXQgc2ltdWxhdGVkQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuQSBzeW50YXggdHJlZSBub2RlIHByb3AgdXNlZCB0byBhc3NvY2lhdGUgaW5kZW50YXRpb24gc3RyYXRlZ2llc1xud2l0aCBub2RlIHR5cGVzLiBTdWNoIGEgc3RyYXRlZ3kgaXMgYSBmdW5jdGlvbiBmcm9tIGFuIGluZGVudGF0aW9uXG5jb250ZXh0IHRvIGEgY29sdW1uIG51bWJlciAoc2VlIGFsc29cbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSBvciBudWxsLCB3aGVyZSBudWxsXG5pbmRpY2F0ZXMgdGhhdCBubyBkZWZpbml0aXZlIGluZGVudGF0aW9uIGNhbiBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLy8gQ29tcHV0ZSB0aGUgaW5kZW50YXRpb24gZm9yIGEgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGUgc3ludGF4IHRyZWUuXG5mdW5jdGlvbiBzeW50YXhJbmRlbnRhdGlvbihjeCwgYXN0LCBwb3MpIHtcbiAgICByZXR1cm4gaW5kZW50RnJvbShhc3QucmVzb2x2ZUlubmVyKHBvcykuZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSwgcG9zLCBjeCk7XG59XG5mdW5jdGlvbiBpZ25vcmVDbG9zZWQoY3gpIHtcbiAgICByZXR1cm4gY3gucG9zID09IGN4Lm9wdGlvbnMuc2ltdWxhdGVCcmVhayAmJiBjeC5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWs7XG59XG5mdW5jdGlvbiBpbmRlbnRTdHJhdGVneSh0cmVlKSB7XG4gICAgbGV0IHN0cmF0ZWd5ID0gdHJlZS50eXBlLnByb3AoaW5kZW50Tm9kZVByb3ApO1xuICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIGxldCBmaXJzdCA9IHRyZWUuZmlyc3RDaGlsZCwgY2xvc2U7XG4gICAgaWYgKGZpcnN0ICYmIChjbG9zZSA9IGZpcnN0LnR5cGUucHJvcChOb2RlUHJvcC5jbG9zZWRCeSkpKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQsIGNsb3NlZCA9IGxhc3QgJiYgY2xvc2UuaW5kZXhPZihsYXN0Lm5hbWUpID4gLTE7XG4gICAgICAgIHJldHVybiBjeCA9PiBkZWxpbWl0ZWRTdHJhdGVneShjeCwgdHJ1ZSwgMSwgdW5kZWZpbmVkLCBjbG9zZWQgJiYgIWlnbm9yZUNsb3NlZChjeCkgPyBsYXN0LmZyb20gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgPT0gbnVsbCA/IHRvcEluZGVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbmRlbnRGcm9tKG5vZGUsIHBvcywgYmFzZSkge1xuICAgIGZvciAoOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3kobm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoYmFzZSwgcG9zLCBub2RlKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICAgIGFwcGxpZXMuXG4gICAgKi9cbiAgICBub2RlKSB7XG4gICAgICAgIHN1cGVyKGJhc2Uuc3RhdGUsIGJhc2Uub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMubm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gdGhpcy5ub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgdGhpcy5ub2RlKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoYXRCcmVhay5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5kZW50KGxpbmUuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIGxvb2tpbmcgZm9yIGluZGVudGF0aW9ucyBpbiB0aGUgbm9kZSdzIHBhcmVudCBub2RlcyxcbiAgICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cbiAgICAqL1xuICAgIGNvbnRpbnVlKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IGluZGVudEZyb20ocGFyZW50LCB0aGlzLnBvcywgdGhpcy5iYXNlKSA6IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIoZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGN1ciA9IGlubmVyOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIChjdXIudG8gPCB0cmVlLmxlbmd0aCAtIDUwIHx8IHRyZWUubGVuZ3RoID09IHN0YXRlLmRvYy5sZW5ndGggfHwgIWlzVW5maW5pc2hlZChjdXIpKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcChjdXIsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcbiAgICBsZXQgY2ggPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gY2ggJiYgY2gudG8gPT0gbm9kZS50byAmJiBjaC50eXBlLmlzRXJyb3I7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5mdW5jdGlvbiBtYXBSYW5nZShyYW5nZSwgbWFwcGluZykge1xuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcbiAgICByZXR1cm4gZnJvbSA+PSB0byA/IHVuZGVmaW5lZCA6IHsgZnJvbSwgdG8gfTtcbn1cbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gZm9sZCB0aGVcbmdpdmVuIHJhbmdlLiAoWW91IHByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIGluIGV4Y2VwdGlvbmFsXG5jaXJjdW1zdGFuY2VzXHUyMDE0dXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxuW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpIGFuZCB0aGUgW2ZvbGRcbmd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKSBjcmVhdGUgdGhlIHRyYW5zYWN0aW9ucy4pXG4qL1xuY29uc3QgZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy5saW5lQmxvY2tBdChoZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHRoYXQgc3RvcmVzIHRoZSBmb2xkZWQgcmFuZ2VzIChhcyBhIFtkZWNvcmF0aW9uXG5zZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSkuIENhbiBiZSBwYXNzZWQgdG9cbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxuW2Bmcm9tSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHRvIHNlcmlhbGl6ZSB0aGUgZm9sZFxuc3RhdGUuXG4qL1xuY29uc3QgZm9sZFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSlcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbZm9sZFdpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgZmlsdGVyOiAoZnJvbSwgdG8pID0+IGUudmFsdWUuZnJvbSAhPSBmcm9tIHx8IGUudmFsdWUudG8gIT0gdG8sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGUudmFsdWUuZnJvbSwgZmlsdGVyVG86IGUudmFsdWUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgZm9sZGVkIHJhbmdlcyB0aGF0IGNvdmVyIHRoZSBzZWxlY3Rpb24gaGVhZFxuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgb25TZWxlY3Rpb24gPSBmYWxzZSwgeyBoZWFkIH0gPSB0ci5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGZvbGRlZC5iZXR3ZWVuKGhlYWQsIGhlYWQsIChhLCBiKSA9PiB7IGlmIChhIDwgaGVhZCAmJiBiID4gaGVhZClcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbiA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUbzogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAoYSwgYikgPT4gYiA8PSBoZWFkIHx8IGEgPj0gaGVhZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2xkZWQ7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKSxcbiAgICB0b0pTT04oZm9sZGVkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvbGRlZC5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG4gICAgZnJvbUpTT04odmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggJSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuLyoqXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXG5pbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8IFJhbmdlU2V0LmVtcHR5O1xufVxuZnVuY3Rpb24gZmluZEZvbGQoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5mcm9tID4gZnJvbSlcbiAgICAgICAgICAgIGZvdW5kID0geyBmcm9tLCB0byB9O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIGZyb20sIChhLCBiKSA9PiB7IGlmIChhID09IGZyb20gJiYgYiA9PSB0bylcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgPyBvdGhlciA6IG90aGVyLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoY29kZUZvbGRpbmcoKSkpO1xufVxuLyoqXG5Gb2xkIHRoZSBsaW5lcyB0aGF0IGFyZSBzZWxlY3RlZCwgaWYgcG9zc2libGUuXG4qL1xuY29uc3QgZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgW2ZvbGRFZmZlY3Qub2YocmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UpXSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5VbmZvbGQgZm9sZGVkIHJhbmdlcyBvbiBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCB1bmZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID4gMDtcbn07XG5mdW5jdGlvbiBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UsIGZvbGQgPSB0cnVlKSB7XG4gICAgbGV0IGxpbmVGcm9tID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKS5udW1iZXI7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldy5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXcuc3RhdGUucGhyYXNlKFwidG9cIil9ICR7bGluZVRvfS5gKTtcbn1cbi8qKlxuRm9sZCBhbGwgdG9wLWxldmVsIGZvbGRhYmxlIHJhbmdlcy4gTm90ZSB0aGF0LCBpbiBtb3N0IGNhc2VzLFxuZm9sZGluZyBpbmZvcm1hdGlvbiB3aWxsIGRlcGVuZCBvbiB0aGUgW3N5bnRheFxudHJlZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKSwgYW5kIGZvbGRpbmcgZXZlcnl0aGluZyBtYXkgbm90IHdvcmtcbnJlbGlhYmx5IHdoZW4gdGhlIGRvY3VtZW50IGhhc24ndCBiZWVuIGZ1bGx5IHBhcnNlZCAoZWl0aGVyXG5iZWNhdXNlIHRoZSBlZGl0b3Igc3RhdGUgd2FzIG9ubHkganVzdCBpbml0aWFsaXplZCwgb3IgYmVjYXVzZSB0aGVcbmRvY3VtZW50IGlzIHNvIGJpZyB0aGF0IHRoZSBwYXJzZXIgZGVjaWRlZCBub3QgdG8gcGFyc2UgaXRcbmVudGlyZWx5KS5cbiovXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKSwgcmFuZ2UgPSBmb2xkYWJsZShzdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgICAgcG9zID0gKHJhbmdlID8gdmlldy5saW5lQmxvY2tBdChyYW5nZS50bykgOiBsaW5lKS50byArIDE7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuVW5mb2xkIGFsbCBmb2xkZWQgY29kZS5cbiovXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZpZWxkLmJldHdlZW4oMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZih7IGZyb20sIHRvIH0pKTsgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5EZWZhdWx0IGZvbGQtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxuIC0gQ3RybC1TaGlmdC1dIChDbWQtQWx0LV0gb24gbWFjT1MpOiBbYHVuZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZENvZGUpLlxuIC0gQ3RybC1BbHQtWzogW2Bmb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQWxsKS5cbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxuKi9cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwbGFjZWhvbGRlclRleHQ6IFwiXHUyMDI2XCJcbn07XG5jb25zdCBmb2xkQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCBkZWZhdWx0Q29uZmlnKTsgfVxufSk7XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIGNvZGUgZm9sZGluZy5cbiovXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2ZvbGRTdGF0ZSwgYmFzZVRoZW1lJDFdO1xuICAgIGlmIChjb25maWcpXG4gICAgICAgIHJlc3VsdC5wdXNoKGZvbGRDb25maWcub2YoY29uZmlnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGZvbGRXaWRnZXQgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2spO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZS5waHJhc2UoXCJmb2xkZWQgY29kZVwiKSk7XG4gICAgICAgICAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gb25jbGljaztcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgfSB9KTtcbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCJcdTIzMDRcIixcbiAgICBjbG9zZWRUZXh0OiBcIlx1MjAzQVwiLFxuICAgIG1hcmtlckRPTTogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBmb2xkaW5nQ2hhbmdlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBGb2xkTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb2xkR3V0dGVyRGVmYXVsdHMpLCBjb25maWcpO1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHN5bnRheFRyZWUodXBkYXRlLnN0YXJ0U3RhdGUpICE9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSB8fFxuICAgICAgICAgICAgICAgIGZ1bGxDb25maWcuZm9sZGluZ0NoYW5nZWQodXBkYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgeyBkb21FdmVudEhhbmRsZXJzIH0gPSBmdWxsQ29uZmlnO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIGd1dHRlcih7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1mb2xkR3V0dGVyXCIsXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgICAgICAgICBpbml0aWFsU3BhY2VyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkb21FdmVudEhhbmRsZXJzKSwgeyBjbGljazogKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21FdmVudEhhbmRsZXJzLmNsaWNrICYmIGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sodmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBmb2xkRWZmZWN0Lm9mKHJhbmdlKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IH0pXG4gICAgICAgIH0pLFxuICAgICAgICBjb2RlRm9sZGluZygpXG4gICAgXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2VlZVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiLjJlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAxcHhcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkR3V0dGVyIHNwYW5cIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9XG59KTtcblxuLyoqXG5BIGhpZ2hsaWdodCBzdHlsZSBhc3NvY2lhdGVzIENTUyBzdHlsZXMgd2l0aCBoaWdsaWdodGluZ1xuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykuXG4qL1xuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0YWcgc3R5bGVzIHVzZWQgdG8gY3JlYXRlIHRoaXMgaGlnaGxpZ2h0IHN0eWxlLlxuICAgICovXG4gICAgc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGwgPSB0eXBlb2Ygb3B0aW9ucy5hbGwgPT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYWxsIDogb3B0aW9ucy5hbGwgPyBkZWYob3B0aW9ucy5hbGwpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY29wZU9wdCA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZU9wdCBpbnN0YW5jZW9mIExhbmd1YWdlID8gKHR5cGUpID0+IHR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSBzY29wZU9wdC5kYXRhXG4gICAgICAgICAgICA6IHNjb3BlT3B0ID8gKHR5cGUpID0+IHR5cGUgPT0gc2NvcGVPcHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcbiAgICAgICAgICAgIHRhZzogc3R5bGUudGFnLFxuICAgICAgICAgICAgY2xhc3M6IHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgICAgYWxsLFxuICAgICAgICB9KS5zdHlsZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy50aGVtZVR5cGUgPSBvcHRpb25zLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXG4gICAgYGNsYXNzYCBwcm9wZXJ0eSBwcm92aWRpbmcgYSBzdGF0aWMgQ1NTIGNsYXNzIChmb3IgaGlnaGxpZ2h0ZXJcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbn1cbmNvbnN0IGhpZ2hsaWdodGVyRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmYWxsYmFja0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBbdmFsdWVzWzBdXSA6IG51bGw7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKSB7XG4gICAgbGV0IG1haW4gPSBzdGF0ZS5mYWNldChoaWdobGlnaHRlckZhY2V0KTtcbiAgICByZXR1cm4gbWFpbi5sZW5ndGggPyBtYWluIDogc3RhdGUuZmFjZXQoZmFsbGJhY2tIaWdobGlnaHRlcik7XG59XG4vKipcbldyYXAgYSBoaWdobGlnaHRlciBpbiBhbiBlZGl0b3IgZXh0ZW5zaW9uIHRoYXQgdXNlcyBpdCB0byBhcHBseVxuc3ludGF4IGhpZ2hsaWdodGluZyB0byB0aGUgZWRpdG9yIGNvbnRlbnQuXG5cbldoZW4gbXVsdGlwbGUgKG5vbi1mYWxsYmFjaykgc3R5bGVzIGFyZSBwcm92aWRlZCwgdGhlIHN0eWxpbmdcbmFwcGxpZWQgaXMgdGhlIHVuaW9uIG9mIHRoZSBjbGFzc2VzIHRoZXkgZW1pdC5cbiovXG5mdW5jdGlvbiBzeW50YXhIaWdobGlnaHRpbmcoaGlnaGxpZ2h0ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW3RyZWVIaWdobGlnaHRlcl0sIHRoZW1lVHlwZTtcbiAgICBpZiAoaGlnaGxpZ2h0ZXIgaW5zdGFuY2VvZiBIaWdobGlnaHRTdHlsZSkge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0ZXIubW9kdWxlKVxuICAgICAgICAgICAgZXh0LnB1c2goRWRpdG9yVmlldy5zdHlsZU1vZHVsZS5vZihoaWdobGlnaHRlci5tb2R1bGUpKTtcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrKVxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgZWxzZSBpZiAodGhlbWVUeXBlKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0LmNvbXB1dGVOKFtFZGl0b3JWaWV3LmRhcmtUaGVtZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mYWNldChFZGl0b3JWaWV3LmRhcmtUaGVtZSkgPT0gKHRoZW1lVHlwZSA9PSBcImRhcmtcIikgPyBbaGlnaGxpZ2h0ZXJdIDogW107XG4gICAgICAgIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuLyoqXG5SZXR1cm5zIHRoZSBDU1MgY2xhc3NlcyAoaWYgYW55KSB0aGF0IHRoZSBoaWdobGlnaHRlcnMgYWN0aXZlIGluXG50aGUgc3RhdGUgd291bGQgYXNzaWduIHRvIHRoZSBnaXZlbiBzdHlsZVxuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykgYW5kXG4ob3B0aW9uYWwpIGxhbmd1YWdlXG5bc2NvcGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSGlnaGxpZ2h0U3R5bGVeZGVmaW5lXm9wdGlvbnMuc2NvcGUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodGluZ0ZvcihzdGF0ZSwgdGFncywgc2NvcGUpIHtcbiAgICBsZXQgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKTtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoaGlnaGxpZ2h0ZXJzKVxuICAgICAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXIuc2NvcGUgfHwgc2NvcGUgJiYgaGlnaGxpZ2h0ZXIuc2NvcGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNscyA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgY2xzIDogY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFRyZWVIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLm1hcmtDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRlcnModmlldy5zdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gaGlnaGxpZ2h0ZXJzICE9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlY28odmlldywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJzIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5jb25zdCB0cmVlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoKC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG4vKipcbkEgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGUgKHdvcmtzIHdlbGwgd2l0aCBsaWdodCB0aGVtZXMpLlxuKi9cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM3YTc1N2FcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLFxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LFxuICAgICAgICBjb2xvcjogXCIjOTQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMzI4YzgyNTJcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNYXRjaChtYXRjaCkge1xuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgIGxldCBtYXJrID0gbWF0Y2gubWF0Y2hlZCA/IG1hdGNoaW5nTWFyayA6IG5vbm1hdGNoaW5nTWFyaztcbiAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICBpZiAobWF0Y2guZW5kKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guZW5kLmZyb20sIG1hdGNoLmVuZC50bykpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1N0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBEZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxufSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdVbmlxdWUgPSBbXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXG4gICAgYmFzZVRoZW1lXG5dO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBicmFja2V0IG1hdGNoaW5nLiBXaGVuZXZlciB0aGVcbmN1cnNvciBpcyBuZXh0IHRvIGEgYnJhY2tldCwgdGhhdCBicmFja2V0IGFuZCB0aGUgb25lIGl0IG1hdGNoZXNcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuaGlnaGxpZ2h0aW5nIHN0eWxlIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhpcy5cbiovXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIG1hdGNoZXMsIGJyYWNrZXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogdG9rZW4uZnJvbSwgdG86IHRva2VuLnRvIH07XG4gICAgbGV0IGRlcHRoID0gMCwgY3Vyc29yID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmN1cnNvcigpO1xuICAgIGlmIChjdXJzb3IgJiYgKGRpciA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUodG9rZW4uZnJvbSkgOiBjdXJzb3IuY2hpbGRBZnRlcih0b2tlbi50bykpKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCA/IGN1cnNvci50byA8PSB0b2tlbi5mcm9tIDogY3Vyc29yLmZyb20gPj0gdG9rZW4udG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCAmJiBtYXRjaGluZy5pbmRleE9mKGN1cnNvci50eXBlLm5hbWUpID4gLTEgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIGVuZDogeyBmcm9tOiBjdXJzb3IuZnJvbSwgdG86IGN1cnNvci50byB9LCBtYXRjaGVkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIGRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIC1kaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBjdXJzb3IuZnJvbSA9PSBjdXJzb3IudG8gPyB1bmRlZmluZWQgOiB7IGZyb206IGN1cnNvci5mcm9tLCB0bzogY3Vyc29yLnRvIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtpbmRlbnRTZXJ2aWNlLm9mKChjeCwgcG9zKSA9PiB0aGlzLmdldEluZGVudChjeCwgcG9zKSldLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICBnZXRJbmRlbnQoY3gsIHBvcykge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY3guc3RhdGUpLCBhdCA9IHRyZWUucmVzb2x2ZShwb3MpO1xuICAgICAgICB3aGlsZSAoYXQgJiYgYXQudHlwZSAhPSB0aGlzLnRvcE5vZGUpXG4gICAgICAgICAgICBhdCA9IGF0LnBhcmVudDtcbiAgICAgICAgaWYgKCFhdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3RhcnQgPSBmaW5kU3RhdGUodGhpcywgdHJlZSwgMCwgYXQuZnJvbSwgcG9zKSwgc3RhdGVQb3MsIHN0YXRlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IHN0YXJ0LnBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoY3gudW5pdCk7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAtIHN0YXRlUG9zID4gMTAwMDAgLyogQy5NYXhJbmRlbnRTY2FuRGlzdCAqLylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoc3RhdGVQb3MgPCBwb3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gY3guc3RhdGUuZG9jLmxpbmVBdChzdGF0ZVBvcyksIGVuZCA9IE1hdGgubWluKHBvcywgbGluZS50byk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB0ZXh0IH0gPSBjeC5saW5lQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyh0ZXh0KVsxXSwgY3gpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5mdW5jdGlvbiBmaW5kU3RhdGUobGFuZywgdHJlZSwgb2ZmLCBzdGFydFBvcywgYmVmb3JlKSB7XG4gICAgbGV0IHN0YXRlID0gb2ZmID49IHN0YXJ0UG9zICYmIG9mZiArIHRyZWUubGVuZ3RoIDw9IGJlZm9yZSAmJiB0cmVlLnByb3AobGFuZy5zdGF0ZUFmdGVyKTtcbiAgICBpZiAoc3RhdGUpXG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUoc3RhdGUpLCBwb3M6IG9mZiArIHRyZWUubGVuZ3RoIH07XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgcG9zID0gb2ZmICsgdHJlZS5wb3NpdGlvbnNbaV07XG4gICAgICAgIGxldCBmb3VuZCA9IGNoaWxkIGluc3RhbmNlb2YgVHJlZSAmJiBwb3MgPCBiZWZvcmUgJiYgZmluZFN0YXRlKGxhbmcsIGNoaWxkLCBwb3MsIHN0YXJ0UG9zLCBiZWZvcmUpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3V0VHJlZShsYW5nLCB0cmVlLCBmcm9tLCB0bywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSAmJiBmcm9tIDw9IDAgJiYgdG8gPj0gdHJlZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIGlmICghaW5zaWRlICYmIHRyZWUudHlwZSA9PSBsYW5nLnRvcE5vZGUpXG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHBvcyA9IHRyZWUucG9zaXRpb25zW2ldLCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIGlubmVyO1xuICAgICAgICBpZiAocG9zIDwgdG8gJiYgY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICBpZiAoIShpbm5lciA9IGN1dFRyZWUobGFuZywgY2hpbGQsIGZyb20gLSBwb3MsIHRvIC0gcG9zLCBpbnNpZGUpKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiAhaW5zaWRlID8gaW5uZXJcbiAgICAgICAgICAgICAgICA6IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIHN0YXJ0UG9zLCBlZGl0b3JTdGF0ZSkge1xuICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBmcm9tID0gZi5mcm9tICsgKGYub3BlblN0YXJ0ID8gMjUgOiAwKSwgdG8gPSBmLnRvIC0gKGYub3BlbkVuZCA/IDI1IDogMCk7XG4gICAgICAgIGxldCBmb3VuZCA9IGZyb20gPD0gc3RhcnRQb3MgJiYgdG8gPiBzdGFydFBvcyAmJiBmaW5kU3RhdGUobGFuZywgZi50cmVlLCAwIC0gZi5vZmZzZXQsIHN0YXJ0UG9zLCB0byksIHRyZWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyk7XG4gICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjb250ZXh0LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxuICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zID49IHBhcnNlRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBwYXJzZUVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5saW5lQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChlb2wgPiAtMSlcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgKyBjaHVuay5sZW5ndGggPD0gdGhpcy50byA/IGNodW5rIDogY2h1bmsuc2xpY2UoMCwgdGhpcy50byAtIHBvcyk7XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMucGFyc2VkUG9zLCBsaW5lID0gdGhpcy5saW5lQWZ0ZXIoZnJvbSksIGVuZCA9IGZyb20gKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7Oykge1xuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xuICAgICAgICAgICAgaWYgKHJhbmdlRW5kID49IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0ID0gdGhpcy5yYW5nZXNbaW5kZXhdLmZyb207XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVBZnRlcihyYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XG4gICAgICAgICAgICBlbmQgPSByYW5nZVN0YXJ0ICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xuICAgIH1cbiAgICBza2lwR2Fwc1RvKHBvcywgb2Zmc2V0LCBzaWRlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvLCBvZmZQb3MgPSBwb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2lkZSA+IDAgPyBlbmQgPiBvZmZQb3MgOiBlbmQgPj0gb2ZmUG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdLmZyb207XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvIDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXgrKztcbiAgICB9XG4gICAgZW1pdFRva2VuKGlkLCBmcm9tLCB0bywgc2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8oZnJvbSwgb2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGxlbjAgPSB0aGlzLmNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyh0bywgb2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2h1bmsubGVuZ3RoIC0gbGVuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rLnB1c2goaWQsIGZyb20sIHRvLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgcGFyc2VMaW5lKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgZW5kIH0gPSB0aGlzLm5leHRMaW5lKCksIG9mZnNldCA9IDAsIHsgc3RyZWFtUGFyc2VyIH0gPSB0aGlzLmxhbmc7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHRoaXMuc3RhdGUsIHN0cmVhbS5pbmRlbnRVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZW1pdFRva2VuKHRoaXMubGFuZy50b2tlblRhYmxlLnJlc29sdmUodG9rZW4pLCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5zdGFydCwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0ucG9zLCA0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gZW5kO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIEMuQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLCB0cmVlLnBvc2l0aW9ucywgdHJlZS5sZW5ndGgsIFtbdGhpcy5sYW5nLnN0YXRlQWZ0ZXIsIHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHRoaXMuc3RhdGUpXV0pO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBwYXJzZXIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTtcbn1cbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB0eXBlQXJyYXkgPSBbTm9kZVR5cGUubm9uZV07XG5jb25zdCBub2RlU2V0ID0gLypAX19QVVJFX18qL25ldyBOb2RlU2V0KHR5cGVBcnJheSk7XG5jb25zdCB3YXJuZWQgPSBbXTtcbmNvbnN0IGRlZmF1bHRUYWJsZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gLypAX19QVVJFX18qL2NyZWF0ZVRva2VuVHlwZShub1Rva2VucywgbmFtZSk7XG5jbGFzcyBUb2tlblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xuICAgICAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG4gICAgICAgIHRoaXMudGFibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRUYWJsZSk7XG4gICAgfVxuICAgIHJlc29sdmUodGFnKSB7XG4gICAgICAgIHJldHVybiAhdGFnID8gMCA6IHRoaXMudGFibGVbdGFnXSB8fCAodGhpcy50YWJsZVt0YWddID0gY3JlYXRlVG9rZW5UeXBlKHRoaXMuZXh0cmEsIHRhZykpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRUb2tlblRhYmxlID0gLypAX19QVVJFX18qL25ldyBUb2tlblRhYmxlKG5vVG9rZW5zKTtcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xuICAgIGlmICh3YXJuZWQuaW5kZXhPZihwYXJ0KSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmVkLnB1c2gocGFydCk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcnQgb2YgdGFnU3RyLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBVbmtub3duIGhpZ2hsaWdodGluZyB0YWcgJHtwYXJ0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghdGFnKVxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWUodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IG5hbWUgPSB0YWdTdHIucmVwbGFjZSgvIC9nLCBcIl9cIiksIHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZyB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgeyBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYnJhY2tldE1hdGNoaW5nLCBjb2RlRm9sZGluZywgY29udGludWVkSW5kZW50LCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIGRlbGltaXRlZEluZGVudCwgZW5zdXJlU3ludGF4VHJlZSwgZmxhdEluZGVudCwgZm9sZEFsbCwgZm9sZENvZGUsIGZvbGRFZmZlY3QsIGZvbGRHdXR0ZXIsIGZvbGRJbnNpZGUsIGZvbGRLZXltYXAsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRTdGF0ZSwgZm9sZGFibGUsIGZvbGRlZFJhbmdlcywgZm9yY2VQYXJzaW5nLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaGlnaGxpZ2h0aW5nRm9yLCBpbmRlbnROb2RlUHJvcCwgaW5kZW50T25JbnB1dCwgaW5kZW50UmFuZ2UsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIG1hdGNoQnJhY2tldHMsIHN5bnRheEhpZ2hsaWdodGluZywgc3ludGF4UGFyc2VyUnVubmluZywgc3ludGF4VHJlZSwgc3ludGF4VHJlZUF2YWlsYWJsZSwgdW5mb2xkQWxsLCB1bmZvbGRDb2RlLCB1bmZvbGRFZmZlY3QgfTtcbiIsICJpbXBvcnQgeyBBbm5vdGF0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgRWRpdG9yU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiwgQ2hhbmdlU2V0LCBDaGFuZ2VEZXNjLCBTdGF0ZUVmZmVjdCwgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4sIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSW5kZW50Q29udGV4dCwgZ2V0SW5kZW50YXRpb24sIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgZ2V0SW5kZW50VW5pdCwgbWF0Y2hCcmFja2V0cywgc3ludGF4VHJlZSB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIHVzZSBsaW5lIGNvbW1lbnRzXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQ29tbWVudCA9IHRhcmdldCA9PiB7XG4gICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUpO1xuICAgIHJldHVybiBjb25maWcubGluZSA/IHRvZ2dsZUxpbmVDb21tZW50KHRhcmdldCkgOiBjb25maWcuYmxvY2sgPyB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUodGFyZ2V0KSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGNvbW1hbmQoZiwgb3B0aW9uKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gZihvcHRpb24sIHN0YXRlKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHRyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuVGhlIGxpbmUgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVMaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG5UaGUgYmxvY2sgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja1VuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBsaW5lcyBhcm91bmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nXG5ibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUgPSAvKkBfX1BVUkVfXyovY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSB7XG4gICAgbGV0IGRhdGEgPSBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNvbW1lbnRUb2tlbnNcIiwgcG9zKTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XG59XG5jb25zdCBTZWFyY2hNYXJnaW4gPSA1MDtcbi8qKlxuRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYmxvY2stY29tbWVudGVkIGluIHRoZSBnaXZlblxuc3RhdGUuXG4qL1xuZnVuY3Rpb24gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgeyBvcGVuLCBjbG9zZSB9LCBmcm9tLCB0bykge1xuICAgIGxldCB0ZXh0QmVmb3JlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSAtIFNlYXJjaE1hcmdpbiwgZnJvbSk7XG4gICAgbGV0IHRleHRBZnRlciA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIFNlYXJjaE1hcmdpbik7XG4gICAgbGV0IHNwYWNlQmVmb3JlID0gL1xccyokLy5leGVjKHRleHRCZWZvcmUpWzBdLmxlbmd0aCwgc3BhY2VBZnRlciA9IC9eXFxzKi8uZXhlYyh0ZXh0QWZ0ZXIpWzBdLmxlbmd0aDtcbiAgICBsZXQgYmVmb3JlT2ZmID0gdGV4dEJlZm9yZS5sZW5ndGggLSBzcGFjZUJlZm9yZTtcbiAgICBpZiAodGV4dEJlZm9yZS5zbGljZShiZWZvcmVPZmYgLSBvcGVuLmxlbmd0aCwgYmVmb3JlT2ZmKSA9PSBvcGVuICYmXG4gICAgICAgIHRleHRBZnRlci5zbGljZShzcGFjZUFmdGVyLCBzcGFjZUFmdGVyICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSAtIHNwYWNlQmVmb3JlLCBtYXJnaW46IHNwYWNlQmVmb3JlICYmIDEgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gKyBzcGFjZUFmdGVyLCBtYXJnaW46IHNwYWNlQWZ0ZXIgJiYgMSB9IH07XG4gICAgfVxuICAgIGxldCBzdGFydFRleHQsIGVuZFRleHQ7XG4gICAgaWYgKHRvIC0gZnJvbSA8PSAyICogU2VhcmNoTWFyZ2luKSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgU2VhcmNoTWFyZ2luKTtcbiAgICAgICAgZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHRvIC0gU2VhcmNoTWFyZ2luLCB0byk7XG4gICAgfVxuICAgIGxldCBzdGFydFNwYWNlID0gL15cXHMqLy5leGVjKHN0YXJ0VGV4dClbMF0ubGVuZ3RoLCBlbmRTcGFjZSA9IC9cXHMqJC8uZXhlYyhlbmRUZXh0KVswXS5sZW5ndGg7XG4gICAgbGV0IGVuZE9mZiA9IGVuZFRleHQubGVuZ3RoIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0VGV4dC5zbGljZShzdGFydFNwYWNlLCBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpID09IG9wZW4gJiZcbiAgICAgICAgZW5kVGV4dC5zbGljZShlbmRPZmYsIGVuZE9mZiArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gKyBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KHN0YXJ0VGV4dC5jaGFyQXQoc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSkgPyAxIDogMCB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChlbmRUZXh0LmNoYXJBdChlbmRPZmYgLSAxKSkgPyAxIDogMCB9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lUmFuZ2VzKHN0YXRlKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XG4gICAgICAgIGxldCB0b0xpbmUgPSByLnRvIDw9IGZyb21MaW5lLnRvID8gZnJvbUxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHIudG8pO1xuICAgICAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XS50byA+IGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICByYW5nZXNbbGFzdF0udG8gPSB0b0xpbmUudG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogZnJvbUxpbmUuZnJvbSwgdG86IHRvTGluZS50byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGJsb2NrIGNvbW1lbnRzIGluXG4vLyBsYW5ndWFnZXMgdGhhdCBzdXBwb3J0IHRoZW0uXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCB0b2tlbnMgPSByYW5nZXMubWFwKHIgPT4gZ2V0Q29uZmlnKHN0YXRlLCByLmZyb20pLmJsb2NrKTtcbiAgICBpZiAoIXRva2Vucy5ldmVyeShjID0+IGMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29tbWVudHMgPSByYW5nZXMubWFwKChyLCBpKSA9PiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiAhY29tbWVudHMuZXZlcnkoYyA9PiBjKSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xuICAgICAgICAgICAgfSkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbW1lbnQ7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV0sIHsgb3BlbiwgY2xvc2UgfSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogb3Blbi5wb3MgLSB0b2tlbi5vcGVuLmxlbmd0aCwgdG86IG9wZW4ucG9zICsgb3Blbi5tYXJnaW4gfSwgeyBmcm9tOiBjbG9zZS5wb3MgLSBjbG9zZS5tYXJnaW4sIHRvOiBjbG9zZS5wb3MgKyB0b2tlbi5jbG9zZS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBsaW5lIGNvbW1lbnRzLlxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IGxpbmVzLmxlbmd0aCwgbWluSW5kZW50ID0gMWU5O1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIHBvcykubGluZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGluZGVudCA9PSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IGxpbmUudGV4dC5zbGljZShpbmRlbnQsIGluZGVudCArIHRva2VuLmxlbmd0aCkgPT0gdG9rZW4gPyBpbmRlbnQgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgbGluZSwgY29tbWVudCwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRlbnQgPCBsaW5lc1tpXS5saW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gc3RhcnRJICsgMSlcbiAgICAgICAgICAgIGxpbmVzW3N0YXJ0SV0uc2luZ2xlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPCAwICYmICghbC5lbXB0eSB8fCBsLnNpbmdsZSkpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCAhZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgY29tbWVudCwgdG9rZW4gfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGxpbmUuZnJvbSArIGNvbW1lbnQsIHRvID0gZnJvbSArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZnJvbUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gYW5ub3RhdGlvbiB0aGF0IHdpbGwgcHJldmVudCB0aGF0IHRyYW5zYWN0aW9uIGZyb21cbmJlaW5nIGNvbWJpbmVkIHdpdGggb3RoZXIgdHJhbnNhY3Rpb25zIGluIHRoZSB1bmRvIGhpc3RvcnkuIEdpdmVuXG5gXCJiZWZvcmVcImAsIGl0J2xsIHByZXZlbnQgbWVyZ2luZyB3aXRoIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gV2l0aFxuYFwiYWZ0ZXJcImAsIHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zIHdvbid0IGJlIGNvbWJpbmVkIHdpdGggdGhpc1xub25lLiBXaXRoIGBcImZ1bGxcImAsIHRoZSB0cmFuc2FjdGlvbiBpcyBpc29sYXRlZCBvbiBib3RoIHNpZGVzLlxuKi9cbmNvbnN0IGlzb2xhdGVIaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRoaXMgZmFjZXQgcHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQsIGdpdmVuIGFcbnRyYW5zYWN0aW9uLCBwcm92aWRlIGEgc2V0IG9mIGVmZmVjdHMgdGhhdCB0aGUgaGlzdG9yeSBzaG91bGRcbnN0b3JlIHdoZW4gaW52ZXJ0aW5nIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuaW50ZWdyYXRlIHNvbWUga2luZHMgb2YgZWZmZWN0cyBpbiB0aGUgaGlzdG9yeSwgc28gdGhhdCB0aGV5IGNhblxuYmUgdW5kb25lIChhbmQgcmVkb25lIGFnYWluKS5cbiovXG5jb25zdCBpbnZlcnRlZEVmZmVjdHMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiAxMDAsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDBcbiAgICAgICAgfSwgeyBtaW5EZXB0aDogTWF0aC5tYXgsIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZXMpIHtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChfLCB0bykgPT4gZW5kID0gdG8pO1xuICAgIHJldHVybiBlbmQ7XG59XG5jb25zdCBoaXN0b3J5RmllbGRfID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChoaXN0b3J5Q29uZmlnKTtcbiAgICAgICAgbGV0IGZyb21IaXN0ID0gdHIuYW5ub3RhdGlvbihmcm9tSGlzdG9yeSk7XG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRyLmRvY0NoYW5nZWQgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNoYW5nZUVuZCh0ci5jaGFuZ2VzKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbiksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBvdGhlciA9IHVwZGF0ZUJyYW5jaChvdGhlciwgb3RoZXIubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG90aGVyID0gYWRkU2VsZWN0aW9uKG90aGVyLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gZnJvbUhpc3QucmVzdCA6IG90aGVyLCBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gb3RoZXIgOiBmcm9tSGlzdC5yZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvbGF0ZSA9IHRyLmFubm90YXRpb24oaXNvbGF0ZUhpc3RvcnkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYmVmb3JlXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgaWYgKHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gIXRyLmNoYW5nZXMuZW1wdHkgPyBzdGF0ZS5hZGRNYXBwaW5nKHRyLmNoYW5nZXMuZGVzYykgOiBzdGF0ZTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXksIGNvbmZpZy5taW5EZXB0aCk7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkU2VsZWN0aW9uKHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9KU09OKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlLmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSksIHVuZG9uZTogdmFsdWUudW5kb25lLm1hcChlID0+IGUudG9KU09OKCkpIH07XG4gICAgfSxcbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGpzb24uZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSwganNvbi51bmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTikpO1xuICAgIH1cbn0pO1xuLyoqXG5DcmVhdGUgYSBoaXN0b3J5IGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBoaXN0b3J5RmllbGRfLFxuICAgICAgICBoaXN0b3J5Q29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIEVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICBiZWZvcmVpbnB1dChlLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB1c2VkIHRvIHN0b3JlIHRoZSBoaXN0b3J5IGRhdGEuIFNob3VsZCBwcm9iYWJseVxub25seSBiZSB1c2VkIHdoZW4geW91IHdhbnQgdG9cbltzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBvclxuW2Rlc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSBzdGF0ZSBvYmplY3RzIGluIGEgd2F5XG50aGF0IHByZXNlcnZlcyBoaXN0b3J5LlxuKi9cbmNvbnN0IGhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZF87XG5mdW5jdGlvbiBjbWQoc2lkZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh7IHN0YXRlLCBkaXNwYXRjaCB9KSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmIHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaGlzdG9yeVN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gaGlzdG9yeVN0YXRlLnBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5VbmRvIGEgc2luZ2xlIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwXG53YXMgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHVuZG8gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCBmYWxzZSk7XG4vKipcblVuZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCB1bmRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgdHJ1ZSk7XG4vKipcblJlZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCByZWRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCB0cnVlKTtcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGxldCBoaXN0U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gaGlzdFN0YXRlLmRvbmUgOiBoaXN0U3RhdGUudW5kb25lO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcbiAgICB9O1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgdW5kb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDAgLyogQnJhbmNoTmFtZS5Eb25lICovKTtcbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHJlZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovKTtcbi8vIEhpc3RvcnkgZXZlbnRzIHN0b3JlIGdyb3VwcyBvZiBjaGFuZ2VzIG9yIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlXG4vLyB1bmRvbmUvcmVkb25lIHRvZ2V0aGVyLlxuY2xhc3MgSGlzdEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgY2hhbmdlcyBpbiB0aGlzIGV2ZW50LiBOb3JtYWwgZXZlbnRzIGhvbGQgYXQgbGVhc3Qgb25lXG4gICAgLy8gY2hhbmdlIG9yIGVmZmVjdC4gQnV0IGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gc3RvcmUgc2VsZWN0aW9uXG4gICAgLy8gZXZlbnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlLCBpbiB3aGljaCBjYXNlIGEgc3BlY2lhbCB0eXBlIG9mXG4gICAgLy8gaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGljaCBkb2Vzbid0IGhvbGQgYW55IGNoYW5nZXMsIHdpdGhcbiAgICAvLyBjaGFuZ2VzID09IHN0YXJ0U2VsZWN0aW9uID09IHVuZGVmaW5lZFxuICAgIGNoYW5nZXMsIFxuICAgIC8vIFRoZSBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG4gICAgZWZmZWN0cywgXG4gICAgLy8gQWNjdW11bGF0ZWQgbWFwcGluZyAoZnJvbSBhZGRUb0hpc3Rvcnk9PWZhbHNlKSB0aGF0IHNob3VsZCBiZVxuICAgIC8vIGFwcGxpZWQgdG8gZXZlbnRzIGJlbG93IHRoaXMgb25lLlxuICAgIG1hcHBlZCwgXG4gICAgLy8gVGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhpcyBldmVudFxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcbiAgICAvLyBTdG9yZXMgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgdGhpcyBldmVudCwgdG8gYmUgdXNlZCBmb3JcbiAgICAvLyBzZWxlY3Rpb24gdW5kby9yZWRvLlxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdGlvbiA9IHN0YXJ0U2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNBZnRlciA9IHNlbGVjdGlvbnNBZnRlcjtcbiAgICB9XG4gICAgc2V0U2VsQWZ0ZXIoYWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodGhpcy5jaGFuZ2VzLCB0aGlzLmVmZmVjdHMsIHRoaXMubWFwcGVkLCB0aGlzLnN0YXJ0U2VsZWN0aW9uLCBhZnRlcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiAoX2EgPSB0aGlzLmNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSxcbiAgICAgICAgICAgIG1hcHBlZDogKF9iID0gdGhpcy5tYXBwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSxcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXG4gICAgICAgICAgICBzZWxlY3Rpb25zQWZ0ZXI6IHRoaXMuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMudG9KU09OKCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KGpzb24uY2hhbmdlcyAmJiBDaGFuZ2VTZXQuZnJvbUpTT04oanNvbi5jaGFuZ2VzKSwgW10sIGpzb24ubWFwcGVkICYmIENoYW5nZURlc2MuZnJvbUpTT04oanNvbi5tYXBwZWQpLCBqc29uLnN0YXJ0U2VsZWN0aW9uICYmIEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnN0YXJ0U2VsZWN0aW9uKSwganNvbi5zZWxlY3Rpb25zQWZ0ZXIubWFwKEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTikpO1xuICAgIH1cbiAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIGBhZGRUb0hpc3RvcnlgIGFuZCBzdWNoLCBpdCBhc3N1bWVzIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBpdGVtLiBSZXR1cm5zIG51bGwgd2hlblxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IG5vbmU7XG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnZlcnQodHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aCAmJiB0ci5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRyLmNoYW5nZXMuaW52ZXJ0KHRyLnN0YXJ0U3RhdGUuZG9jKSwgZWZmZWN0cywgdW5kZWZpbmVkLCBzZWxlY3Rpb24gfHwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIG5vbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodW5kZWZpbmVkLCBub25lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2VsZWN0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQnJhbmNoKGJyYW5jaCwgdG8sIG1heExlbiwgbmV3RXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB0byArIDEgPiBtYXhMZW4gKyAyMCA/IHRvIC0gbWF4TGVuIC0gMSA6IDA7XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xuICAgIG5ld0JyYW5jaC5wdXNoKG5ld0V2ZW50KTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuZnVuY3Rpb24gaXNBZGphY2VudChhLCBiKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBpc0FkamFjZW50ID0gZmFsc2U7XG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xuICAgIGIuaXRlckNoYW5nZWRSYW5nZXMoKF9mLCBfdCwgZiwgdCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgaWYgKHQgPj0gZnJvbSAmJiBmIDw9IHRvKVxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWRqYWNlbnQ7XG59XG5mdW5jdGlvbiBlcVNlbGVjdGlvblNoYXBlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yYW5nZXMubGVuZ3RoID09IGIucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGNvbmMoYSwgYikge1xuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xuZnVuY3Rpb24gYWRkU2VsZWN0aW9uKGJyYW5jaCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzZWxzID0gbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5zbGljZShNYXRoLm1heCgwLCBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIE1heFNlbGVjdGlvbnNQZXJFdmVudCkpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGggJiYgc2Vsc1tzZWxzLmxlbmd0aCAtIDFdLmVxKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICBzZWxzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUJyYW5jaChicmFuY2gsIGJyYW5jaC5sZW5ndGggLSAxLCAxZTksIGxhc3RFdmVudC5zZXRTZWxBZnRlcihzZWxzKSk7XG4gICAgfVxufVxuLy8gQXNzdW1lcyB0aGUgdG9wIGl0ZW0gaGFzIG9uZSBvciBtb3JlIHNlbGVjdGlvbkFmdGVyIHZhbHVlc1xuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xuICAgIGxldCBsYXN0ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKCk7XG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXG4vLyBhd2F5IGFsbCB0aGUgY2hhbmdlcyBhbmQgZWZmZWN0cyBpbiB0aGF0IGl0ZW0sIGRyb3AgaXQgYW5kXG4vLyBwcm9wYWdhdGUgdGhlIG1hcHBpbmcgdG8gdGhlIG5leHQgaXRlbS5cbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbWFwRXZlbnQoYnJhbmNoW2xlbmd0aCAtIDFdLCBtYXBwaW5nLCBzZWxlY3Rpb25zKTtcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJyYW5jaC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aCAtIDFdID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEcm9wIHRoaXMgZXZlbnQsIHNpbmNlIHRoZXJlJ3Mgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGxlZnRcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gW0hpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyldIDogbm9uZTtcbn1cbmZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXBwaW5nLCBleHRyYVNlbGVjdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IGNvbmMoZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCA/IGV2ZW50LnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSkgOiBub25lLCBleHRyYVNlbGVjdGlvbnMpO1xuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxuICAgIGlmICghZXZlbnQuY2hhbmdlcylcbiAgICAgICAgcmV0dXJuIEhpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xuICAgIGxldCBmdWxsTWFwcGluZyA9IGV2ZW50Lm1hcHBlZCA/IGV2ZW50Lm1hcHBlZC5jb21wb3NlRGVzYyhiZWZvcmUpIDogYmVmb3JlO1xuICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KG1hcHBlZENoYW5nZXMsIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbWFwcGluZyksIGZ1bGxNYXBwaW5nLCBldmVudC5zdGFydFNlbGVjdGlvbi5tYXAoYmVmb3JlKSwgc2VsZWN0aW9ucyk7XG59XG5jb25zdCBqb2luYWJsZVVzZXJFdmVudCA9IC9eKGlucHV0XFwudHlwZXxkZWxldGUpKCR8XFwuKS87XG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldlVzZXJFdmVudCA9IHByZXZVc2VyRXZlbnQ7XG4gICAgfVxuICAgIGlzb2xhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUaW1lID8gbmV3IEhpc3RvcnlTdGF0ZSh0aGlzLmRvbmUsIHRoaXMudW5kb25lKSA6IHRoaXM7XG4gICAgfVxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSwgbWF4TGVuKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgbWF4TGVuLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIG1heExlbiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gdGhpcy5kb25lIDogdGhpcy51bmRvbmU7XG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnNlbGVjdGlvbnNBZnRlcltldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCkgfSksXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJzZWxlY3QudW5kb1wiIDogXCJzZWxlY3QucmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXZlbnQuY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN0ID0gYWRkTWFwcGluZ1RvQnJhbmNoKHJlc3QsIGV2ZW50Lm1hcHBlZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBldmVudC5jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc3RhcnRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0IH0pLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xuICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb25BdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IERpcmVjdGlvbi5MVFI7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JHcm91cFJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIHJldHVybiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgbGV0IGNhdCA9IENoYXJDYXRlZ29yeS5TcGFjZSwgcG9zID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZSwgc2F3VXBwZXIgPSBmYWxzZSwgc2F3TG93ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0ZXAgPSAobmV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyBuZXh0Lmxlbmd0aCA6IC1uZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICAgICAgaWYgKGNhdCAhPSBuZXh0Q2F0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC50b0xvd2VyQ2FzZSgpID09IG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzYXdMb3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNhd0xvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXdVcHBlciAmJiBmb3J3YXJkICYmIGNhdGVnb3JpemUoYWhlYWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhaGVhZC50b0xvd2VyQ2FzZSgpID09IGFoZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzYXdVcHBlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHN0ZXAoc3RhcnQpO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBub2RlLCBicmFja2V0UHJvcCkge1xuICAgIGlmIChub2RlLnR5cGUucHJvcChicmFja2V0UHJvcCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBsZW4gPSBub2RlLnRvIC0gbm9kZS5mcm9tO1xuICAgIHJldHVybiBsZW4gJiYgKGxlbiA+IDIgfHwgL1teXFxzLC47Ol0vLnRlc3Qoc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBub2RlLnRvKSkpIHx8IG5vZGUuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIG1vdmVCeVN5bnRheChzdGF0ZSwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHN0YXJ0LmhlYWQpO1xuICAgIGxldCBicmFja2V0UHJvcCA9IGZvcndhcmQgPyBOb2RlUHJvcC5jbG9zZWRCeSA6IE5vZGVQcm9wLm9wZW5lZEJ5O1xuICAgIC8vIFNjYW4gZm9yd2FyZCB0aHJvdWdoIGNoaWxkIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSdzIGFuIGludGVyZXN0aW5nXG4gICAgLy8gbm9kZSBhaGVhZC5cbiAgICBmb3IgKGxldCBhdCA9IHN0YXJ0LmhlYWQ7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IGZvcndhcmQgPyBwb3MuY2hpbGRBZnRlcihhdCkgOiBwb3MuY2hpbGRCZWZvcmUoYXQpO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbmV4dCwgYnJhY2tldFByb3ApKVxuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXQgPSBmb3J3YXJkID8gbmV4dC50byA6IG5leHQuZnJvbTtcbiAgICB9XG4gICAgbGV0IGJyYWNrZXQgPSBwb3MudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSwgbWF0Y2gsIG5ld1BvcztcbiAgICBpZiAoYnJhY2tldCAmJiAobWF0Y2ggPSBmb3J3YXJkID8gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLmZyb20sIDEpIDogbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLnRvLCAtMSkpICYmIG1hdGNoLm1hdGNoZWQpXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBtYXRjaC5lbmQudG8gOiBtYXRjaC5lbmQuZnJvbTtcbiAgICBlbHNlXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBwb3MudG8gOiBwb3MuZnJvbTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBjdXJzb3JCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIGxldCBtb3ZlZCA9IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICByZXR1cm4gbW92ZWQuaGVhZCAhPSByYW5nZS5oZWFkID8gbW92ZWQgOiB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBjdXJzb3JMaW5lVXAgPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVEb3duID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBwYWdlSGVpZ2h0KHZpZXcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgTWF0aC5taW4odmlldy5kb20uY2xpZW50SGVpZ2h0LCBpbm5lckhlaWdodCkgLSA1KTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZUhlaWdodCh2aWV3KSkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0UG9zID0gdmlldy5jb29yZHNBdFBvcyhzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFJlY3QudG9wICYmIHN0YXJ0UG9zLmJvdHRvbSA8IHNjcm9sbFJlY3QuYm90dG9tICYmXG4gICAgICAgIHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFJlY3QudG9wIDw9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodClcbiAgICAgICAgZWZmZWN0ID0gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24ubWFpbi5oZWFkLCB7IHk6IFwic3RhcnRcIiwgeU1hcmdpbjogc3RhcnRQb3MudG9wIC0gc2Nyb2xsUmVjdC50b3AgfSk7XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbiksIHsgZWZmZWN0czogZWZmZWN0IH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgdXAuXG4qL1xuY29uc3QgY3Vyc29yUGFnZVVwID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBjdXJzb3JQYWdlRG93biA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHN0YXJ0LmhlYWQpLCBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkKTtcbiAgICBpZiAobW92ZWQuaGVhZCA9PSBzdGFydC5oZWFkICYmIG1vdmVkLmhlYWQgIT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcbiAgICAgICAgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgZmFsc2UpO1xuICAgIGlmICghZm9yd2FyZCAmJiBtb3ZlZC5oZWFkID09IGxpbmUuZnJvbSAmJiBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWModmlldy5zdGF0ZS5zbGljZURvYyhsaW5lLmZyb20sIE1hdGgubWluKGxpbmUuZnJvbSArIDEwMCwgbGluZS50bykpKVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChzcGFjZSAmJiBzdGFydC5oZWFkICE9IGxpbmUuZnJvbSArIHNwYWNlKVxuICAgICAgICAgICAgbW92ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUuZnJvbSArIHNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVkO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgbGluZSB3cmFwIHBvaW50LCBvciB0byB0aGUgZW5kIG9mXG50aGUgbGluZSBpZiB0aGVyZSBpc24ndCBvbmUgbGVmdCBvbiB0aGlzIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHByZXZpb3VzIGxpbmUgd3JhcCBwb2ludCwgb3IgZmFpbGluZyB0aGF0IHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBsaW5lIGlzIGluZGVudGVkLCBhbmQgdGhlIGN1cnNvclxuaXNuJ3QgYWxyZWFkeSBhdCB0aGUgZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiwgdGhpcyB3aWxsIG1vdmUgdG8gdGhlXG5lbmQgb2YgdGhlIGluZGVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVTdGFydCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSwgMSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lRW5kID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bywgLTEpKTtcbmZ1bmN0aW9uIHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZXh0ZW5kKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2UsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgLTEpXG4gICAgICAgICAgICB8fCBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAxKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxKSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEpKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZyB8fCAhbWF0Y2hpbmcuZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGxldCBoZWFkID0gbWF0Y2hpbmcuc3RhcnQuZnJvbSA9PSByYW5nZS5oZWFkID8gbWF0Y2hpbmcuZW5kLnRvIDogbWF0Y2hpbmcuZW5kLmZyb207XG4gICAgICAgIHJldHVybiBleHRlbmQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCk7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIGl0IGlzIGN1cnJlbnRseVxub24sIGlmIGFueS5cbiovXG5jb25zdCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgdGhlIHNlbGVjdGlvblxuaGVhZCBpcyBjdXJyZW50bHkgb24sIGlmIGFueS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGV4dGVuZFNlbCh2aWV3LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHZpZXcuc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBoZWFkID0gaG93KHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQuaGVhZCwgaGVhZC5nb2FsQ29sdW1uKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VIZWlnaHQodmlldykpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHJhbmdlLmhlYWQsIDEpO1xuICAgICAgICB3aGlsZSAoISgoY29udGV4dC5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBjb250ZXh0LnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgKGNvbnRleHQudG8gPiByYW5nZS50byAmJiBjb250ZXh0LmZyb20gPD0gcmFuZ2UuZnJvbSkgfHxcbiAgICAgICAgICAgICEoKF9hID0gY29udGV4dC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShjb250ZXh0LnRvLCBjb250ZXh0LmZyb20pO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW2N1ci5tYWluXSk7XG4gICAgZWxzZSBpZiAoIWN1ci5tYWluLmVtcHR5KVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcbiAgICBpZiAodGFyZ2V0LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KGZyb20pO1xuICAgICAgICAgICAgaWYgKHRvd2FyZHMgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc2tpcEF0b21pYyh0YXJnZXQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCBwb3MgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmICghZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXG4gICAgICAgICEvW14gXFx0XS8udGVzdChiZWZvcmUgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKSkpIHtcbiAgICAgICAgaWYgKGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0gPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oYmVmb3JlLCBzdGF0ZS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGdldEluZGVudFVuaXQoc3RhdGUpIHx8IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3AgJiYgYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxIC0gaV0gPT0gXCIgXCI7IGkrKylcbiAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICB0YXJnZXRQb3MgPSBwb3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PSBwb3MgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyXG5iZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgc3RhcnQgPT4ge1xuICAgIGxldCBwb3MgPSBzdGFydCwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgZm9yIChsZXQgY2F0ID0gbnVsbDs7KSB7XG4gICAgICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSBzdGFydClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykudG87XG4gICAgcmV0dXJuIHBvcyA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCBwb3MgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChwb3MpLmZyb207XG4gICAgcmV0dXJuIHBvcyA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHBvcyAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcbiAtIEN0cmwtYSAoQ21kLWEgb24gbWFjT1MpOiBbYHNlbGVjdEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0QWxsKVxuIC0gQmFja3NwYWNlOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVTdGFydCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlVG9MaW5lU3RhcnQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDb21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuKi9cbmNvbnN0IGRlZmF1bHRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfVxuXS5jb25jYXQoc3RhbmRhcmRLZXltYXApO1xuLyoqXG5BIGJpbmRpbmcgdGhhdCBiaW5kcyBUYWIgdG8gW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSBhbmRcblNoaWZ0LVRhYiB0byBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XG5cbmV4cG9ydCB7IGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckxlZnQsIGN1cnNvckNoYXJSaWdodCwgY3Vyc29yRG9jRW5kLCBjdXJzb3JEb2NTdGFydCwgY3Vyc29yR3JvdXBCYWNrd2FyZCwgY3Vyc29yR3JvdXBGb3J3YXJkLCBjdXJzb3JHcm91cExlZnQsIGN1cnNvckdyb3VwUmlnaHQsIGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgY3Vyc29yTGluZURvd24sIGN1cnNvckxpbmVFbmQsIGN1cnNvckxpbmVTdGFydCwgY3Vyc29yTGluZVVwLCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQsIGN1cnNvclBhZ2VEb3duLCBjdXJzb3JQYWdlVXAsIGN1cnNvclN1YndvcmRCYWNrd2FyZCwgY3Vyc29yU3Vid29yZEZvcndhcmQsIGN1cnNvclN5bnRheExlZnQsIGN1cnNvclN5bnRheFJpZ2h0LCBkZWZhdWx0S2V5bWFwLCBkZWxldGVDaGFyQmFja3dhcmQsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUxpbmUsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0VGFiLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCBsaW5lQ29tbWVudCwgbGluZVVuY29tbWVudCwgbW92ZUxpbmVEb3duLCBtb3ZlTGluZVVwLCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHNlbGVjdEFsbCwgc2VsZWN0Q2hhckJhY2t3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBzaG93UGFuZWwsIEVkaXRvclZpZXcsIGdldFBhbmVsLCBEZWNvcmF0aW9uLCBWaWV3UGx1Z2luLCBydW5TY29wZUhhbmRsZXJzIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBjb2RlUG9pbnRBdCwgZnJvbUNvZGVQb2ludCwgY29kZVBvaW50U2l6ZSwgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIENoYXJDYXRlZ29yeSwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjLCBFZGl0b3JTdGF0ZSwgZmluZENsdXN0ZXJCcmVhayB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcbiAgICA/IHggPT4geC5ub3JtYWxpemUoXCJORktEXCIpIDogeCA9PiB4O1xuLyoqXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxuZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IGN1cnNvci4gVGhlIHF1ZXJ5IGlzIHRoZSBzZWFyY2ggc3RyaW5nLCBgZnJvbWAgdG9cbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxuICAgIFxuICAgIFdoZW4gYG5vcm1hbGl6ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgY2FsbGVkLCBvbiBib3RoIHRoZSBxdWVyeVxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxuICAgIFlvdSBjYW4sIGZvciBleGFtcGxlLCBjcmVhdGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBieVxuICAgIHBhc3NpbmcgYHMgPT4gcy50b0xvd2VyQ2FzZSgpYC5cbiAgICBcbiAgICBUZXh0IGlzIGFsd2F5cyBub3JtYWxpemVkIHdpdGhcbiAgICBbYC5ub3JtYWxpemUoXCJORktEXCIpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL25vcm1hbGl6ZSlcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoLCBub3JtYWxpemUsIHRlc3QpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IG1hdGNoIChvbmx5IGhvbGRzIGEgbWVhbmluZ2Z1bCB2YWx1ZSBhZnRlclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXG4gICAgICAgIGBkb25lYCBpcyBmYWxzZSkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGl0ZXJhdGVkIHJlZ2lvbiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXJSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSA/IHggPT4gbm9ybWFsaXplKGJhc2ljTm9ybWFsaXplKHgpKSA6IGJhc2ljTm9ybWFsaXplO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5ub3JtYWxpemUocXVlcnkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJQb3MgPT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludEF0KHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIHRoZSBuZXh0IG1hdGNoLiBVcGRhdGVzIHRoZSBpdGVyYXRvcidzXG4gICAgW2B2YWx1ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci52YWx1ZSkgYW5kXG4gICAgW2Bkb25lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLmRvbmUpIHByb3BlcnRpZXMuIFNob3VsZCBiZSBjYWxsZWRcbiAgICBhdCBsZWFzdCBvbmNlIGJlZm9yZSB1c2luZyB0aGUgY3Vyc29yLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRPdmVybGFwcGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYG5leHRgIG1ldGhvZCB3aWxsIGlnbm9yZSBtYXRjaGVzIHRoYXQgcGFydGlhbGx5IG92ZXJsYXAgYVxuICAgIHByZXZpb3VzIG1hdGNoLiBUaGlzIG1ldGhvZCBiZWhhdmVzIGxpa2UgYG5leHRgLCBidXQgaW5jbHVkZXNcbiAgICBzdWNoIG1hdGNoZXMuXG4gICAgKi9cbiAgICBuZXh0T3ZlcmxhcHBpbmcoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0ciA9IGZyb21Db2RlUG9pbnQobmV4dCksIHN0YXJ0ID0gdGhpcy5idWZmZXJTdGFydCArIHRoaXMuYnVmZmVyUG9zO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUoc3RyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2goY29kZSwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGNvZGUsIHBvcykge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goMSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy50ZXN0ICYmICF0aGlzLnRlc3QobWF0Y2guZnJvbSwgbWF0Y2gudG8sIHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcykpXG4gICAgICAgICAgICBtYXRjaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIENodW5rLkJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgICAgICAvLyBhZ2Fpbiwgc2luY2UgaXQnbGwgbGlrZWx5IGJlIGFibGUgdG8gbWF0Y2ggbW9yZVxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5mbGF0LnRvID49IHRoaXMudG8gfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPD0gdGhpcy5mbGF0LnRleHQubGVuZ3RoIC0gMTApICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbGF0LnRvID09IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR3JvdyB0aGUgZmxhdHRlbmVkIGRvY1xuICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IE11bHRpbGluZVJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG5mdW5jdGlvbiB2YWxpZFJlZ0V4cChzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHNvdXJjZSwgYmFzZUZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9DaGFyRW5kKHRleHQsIHBvcykge1xuICAgIGlmIChwb3MgPj0gdGV4dC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmVBdChwb3MpLCBuZXh0O1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRvICYmIChuZXh0ID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zIC0gbGluZS5mcm9tKSkgPj0gMHhEQzAwICYmIG5leHQgPCAweEUwMDApXG4gICAgICAgIHBvcysrO1xuICAgIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVEaWFsb2codmlldykge1xuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiIH0pO1xuICAgIGxldCBkb20gPSBlbHQoXCJmb3JtXCIsIHtcbiAgICAgICAgY2xhc3M6IFwiY20tZ290b0xpbmVcIixcbiAgICAgICAgb25rZXlkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSkgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH1cbiAgICB9LCBlbHQoXCJsYWJlbFwiLCB2aWV3LnN0YXRlLnBocmFzZShcIkdvIHRvIGxpbmVcIiksIFwiOiBcIiwgaW5wdXQpLCBcIiBcIiwgZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIHR5cGU6IFwic3VibWl0XCIgfSwgdmlldy5zdGF0ZS5waHJhc2UoXCJnb1wiKSkpO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSAvXihbKy1dKT8oXFxkKyk/KDpcXGQrKT8oJSk/JC8uZXhlYyhpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgWywgc2lnbiwgbG4sIGNsLCBwZXJjZW50XSA9IG1hdGNoO1xuICAgICAgICBsZXQgY29sID0gY2wgPyArY2wuc2xpY2UoMSkgOiAwO1xuICAgICAgICBsZXQgbGluZSA9IGxuID8gK2xuIDogc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgaWYgKGxuICYmIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYyA9IGxpbmUgLyAxMDA7XG4gICAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgICAgICBwYyA9IHBjICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgKHN0YXJ0TGluZS5udW1iZXIgLyBzdGF0ZS5kb2MubGluZXMpO1xuICAgICAgICAgICAgbGluZSA9IE1hdGgucm91bmQoc3RhdGUuZG9jLmxpbmVzICogcGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlLmRvYy5saW5lKE1hdGgubWF4KDEsIE1hdGgubWluKHN0YXRlLmRvYy5saW5lcywgbGluZSkpKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4geyBkb20gfTtcbn1cbmNvbnN0IGRpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGRpYWxvZ0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbCA/IGNyZWF0ZUxpbmVEaWFsb2cgOiBudWxsKVxufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBzaG93cyBhIGRpYWxvZyBhc2tpbmcgdGhlIHVzZXIgZm9yIGEgbGluZSBudW1iZXIsIGFuZFxud2hlbiBhIHZhbGlkIHBvc2l0aW9uIGlzIHByb3ZpZGVkLCBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoYXQgbGluZS5cblxuU3VwcG9ydHMgbGluZSBudW1iZXJzLCByZWxhdGl2ZSBsaW5lIG9mZnNldHMgcHJlZml4ZWQgd2l0aCBgK2Agb3JcbmAtYCwgZG9jdW1lbnQgcGVyY2VudGFnZXMgc3VmZml4ZWQgd2l0aCBgJWAsIGFuZCBhbiBvcHRpb25hbFxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxubnVtYmVyLlxuXG5UaGUgZGlhbG9nIGNhbiBiZSBzdHlsZWQgd2l0aCB0aGUgYHBhbmVsLmdvdG9MaW5lYCB0aGVtZVxuc2VsZWN0b3IuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkLCBmYWxzZSkgPT0gbnVsbClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW2RpYWxvZ0ZpZWxkLCBiYXNlVGhlbWUkMV0pKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgICAgIHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgfVxuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKS5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyA9IHtcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcbiAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IDEsXG4gICAgbWF4TWF0Y2hlczogMTAwLFxuICAgIHdob2xlV29yZHM6IGZhbHNlXG59O1xuY29uc3QgaGlnaGxpZ2h0Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IG91dHNpZGUgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgbm9uLXdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmRcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xufVxuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgaWYgKCFjb25mLmhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2Mod29yZC5mcm9tLCB3b3JkLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSByYW5nZS50byAtIHJhbmdlLmZyb207XG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBpZiAoY29uZi53aG9sZVdvcmRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRvOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHBvcyAtIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKTsgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIE1hdGgubWluKHRvICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCwgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHBDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnNlYXJjaCwge1xuICAgICAgICBpZ25vcmVDYXNlOiAhc3BlYy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICB0ZXN0OiBzcGVjLndob2xlV29yZCA/IHJlZ2V4cFdvcmRUZXN0KHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWRcbiAgICB9LCBmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBjaGFyQmVmb3JlKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCwgZmFsc2UpLCBpbmRleCk7XG59XG5mdW5jdGlvbiBjaGFyQWZ0ZXIoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoaW5kZXgsIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCkpO1xufVxuZnVuY3Rpb24gcmVnZXhwV29yZFRlc3QoY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKF9mcm9tLCBfdG8sIG1hdGNoKSA9PiAhbWF0Y2hbMF0ubGVuZ3RoIHx8XG4gICAgICAgIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG5jbGFzcyBSZWdFeHBRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHNpemUgPSAxOzsgc2l6ZSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCB0byAtIHNpemUgKiAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgdG8pLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAoc3RhcnQgPT0gZnJvbSB8fCByYW5nZS5mcm9tID4gc3RhcnQgKyAxMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UucmVwbGFjZSgvXFwkKFskJlxcZCtdKS9nLCAobSwgaSkgPT4gaSA9PSBcIiRcIiA/IFwiJFwiXG4gICAgICAgICAgICA6IGkgPT0gXCImXCIgPyByZXN1bHQubWF0Y2hbMF1cbiAgICAgICAgICAgICAgICA6IGkgIT0gXCIwXCIgJiYgK2kgPCByZXN1bHQubWF0Y2gubGVuZ3RoID8gcmVzdWx0Lm1hdGNoW2ldXG4gICAgICAgICAgICAgICAgICAgIDogbSkpO1xuICAgIH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKSwgTWF0aC5taW4odG8gKyAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLywgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG4vKipcbkEgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkuIE5vdGUgdGhhdFxudGhpcyBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlIHNlYXJjaCBzdGF0ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxuKGJ5IGluY2x1ZGluZyBbYHNlYXJjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaCkgaW4geW91ciBjb25maWd1cmF0aW9uIG9yXG5ieSBydW5uaW5nIFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSBhdCBsZWFzdFxub25jZSkuXG4qL1xuY29uc3Qgc2V0U2VhcmNoUXVlcnkgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hTdGF0ZShkZWZhdWx0UXVlcnkoc3RhdGUpLmNyZWF0ZSgpLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKGVmZmVjdC52YWx1ZS5jcmVhdGUoKSwgdmFsdWUucGFuZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZSh2YWx1ZS5xdWVyeSwgZWZmZWN0LnZhbHVlID8gY3JlYXRlU2VhcmNoUGFuZWwgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpXG59KTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xuICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGN1clN0YXRlID8gY3VyU3RhdGUucXVlcnkuc3BlYyA6IGRlZmF1bHRRdWVyeShzdGF0ZSk7XG59XG4vKipcblF1ZXJ5IHdoZXRoZXIgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGluIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gc2VhcmNoUGFuZWxPcGVuKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2hcIiB9KSwgc2VsZWN0ZWRNYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2ggY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIiB9KTtcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQoc3RhdGUpO1xuICAgIH1cbiAgICBoaWdobGlnaHQoeyBxdWVyeSwgcGFuZWwgfSkge1xuICAgICAgICBpZiAoIXBhbmVsIHx8ICFxdWVyeS5zcGVjLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXcuc3RhdGUsIGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBmcm9tICYmIHIudG8gPT0gdG8pO1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmZ1bmN0aW9uIHNlYXJjaENvbW1hbmQoZikge1xuICAgIHJldHVybiB2aWV3ID0+IHtcbiAgICAgICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUucXVlcnkuc3BlYy52YWxpZCA/IGYodmlldywgc3RhdGUpIDogb3BlblNlYXJjaFBhbmVsKHZpZXcpO1xuICAgIH07XG59XG4vKipcbk9wZW4gdGhlIHNlYXJjaCBwYW5lbCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW4sIGFuZCBtb3ZlIHRoZVxuc2VsZWN0aW9uIHRvIHRoZSBmaXJzdCBtYXRjaCBhZnRlciB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi5cbldpbGwgd3JhcCBhcm91bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB3aGVuIGl0IHJlYWNoZXMgdGhlXG5lbmQuXG4qL1xuY29uc3QgZmluZE5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZSwgdG8sIHRvKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogbmV4dC5mcm9tLCBoZWFkOiBuZXh0LnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHJhbmdlID0gcXVlcnkucHJldk1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHJhbmdlLmZyb20sIGhlYWQ6IHJhbmdlLnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIHJhbmdlKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMTAwMCk7XG4gICAgaWYgKCFyYW5nZXMgfHwgIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4qL1xuY29uc3Qgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxIHx8IHNlbC5tYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5tYWluO1xuICAgIGxldCByYW5nZXMgPSBbXSwgbWFpbiA9IDA7XG4gICAgZm9yIChsZXQgY3VyID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSk7ICFjdXIubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN1ci52YWx1ZS5mcm9tID09IGZyb20pXG4gICAgICAgICAgICBtYWluID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGN1ci52YWx1ZS5mcm9tLCBjdXIudmFsdWUudG8pKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgbWFpbiksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCByZXBsYWNlTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgbGV0IGFubm91bmNlID0gW107XG4gICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIG5leHQudG8gPT0gdG8pIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBzdGF0ZS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0LmZyb20sIHRvOiBuZXh0LnRvLCBpbnNlcnQ6IHJlcGxhY2VtZW50IH0pO1xuICAgICAgICBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBuZXh0LmZyb20sIG5leHQudG8pO1xuICAgICAgICBhbm5vdW5jZS5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBuZXh0LnRvID8gMCA6IG5leHQudG8gLSBuZXh0LmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgICAgIHNlbGVjdGlvbiA9IHsgYW5jaG9yOiBuZXh0LmZyb20gLSBvZmYsIGhlYWQ6IG5leHQudG8gLSBvZmYgfTtcbiAgICAgICAgYW5ub3VuY2UucHVzaChhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbm5vdW5jZVRleHQgPSB2aWV3LnN0YXRlLnBocmFzZShcInJlcGxhY2VkICQgbWF0Y2hlc1wiLCBjaGFuZ2VzLmxlbmd0aCkgKyBcIi5cIjtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5hbm5vdW5jZS5vZihhbm5vdW5jZVRleHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZS5hbGxcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLmNyZWF0ZVBhbmVsKHZpZXcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgd2hvbGVXb3JkOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sud2hvbGVXb3JkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcud2hvbGVXb3JkXG4gICAgfSk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYW5lbCkge1xuICAgICAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgICAgIGlmICghcGFuZWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIEFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJBbHQtZ1wiLCBydW46IGdvdG9MaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbl07XG5jbGFzcyBTZWFyY2hQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5ID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkucXVlcnkuc3BlYztcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgXCJtYWluLWZpZWxkXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnJlcGxhY2UsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcImNhc2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkucmVnZXhwLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmRGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwid29yZFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5Lndob2xlV29yZCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uKG5hbWUsIG9uY2xpY2ssIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgbmFtZSwgb25jbGljaywgdHlwZTogXCJidXR0b25cIiB9LCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IG9ua2V5ZG93bjogKGUpID0+IHRoaXMua2V5ZG93bihlKSwgY2xhc3M6IFwiY20tc2VhcmNoXCIgfSwgW1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGJ1dHRvbihcIm5leHRcIiwgKCkgPT4gZmluZE5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJuZXh0XCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJwcmV2XCIsICgpID0+IGZpbmRQcmV2aW91cyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInByZXZpb3VzXCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJzZWxlY3RcIiwgKCkgPT4gc2VsZWN0TWF0Y2hlcyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcImFsbFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMuY2FzZUZpZWxkLCBwaHJhc2UodmlldywgXCJtYXRjaCBjYXNlXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5yZUZpZWxkLCBwaHJhc2UodmlldywgXCJyZWdleHBcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLndvcmRGaWVsZCwgcGhyYXNlKHZpZXcsIFwiYnkgd29yZFwiKV0pLFxuICAgICAgICAgICAgLi4udmlldy5zdGF0ZS5yZWFkT25seSA/IFtdIDogW1xuICAgICAgICAgICAgICAgIGVsdChcImJyXCIpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VcIiwgKCkgPT4gcmVwbGFjZU5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlXCIpXSksXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZUFsbFwiLCAoKSA9PiByZXBsYWNlQWxsKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZSBhbGxcIildKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgICAgIH0sIFtcIlx1MDBEN1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93ZXN0KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiIsICJpbXBvcnQgeyBBbm5vdGF0aW9uLCBFZGl0b3JTZWxlY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBmcm9tQ29kZVBvaW50LCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIFJhbmdlU2V0LCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBsb2dFeGNlcHRpb24sIERpcmVjdGlvbiwgc2hvd1Rvb2x0aXAsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGdldFRvb2x0aXAsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuLyoqXG5BbiBpbnN0YW5jZSBvZiB0aGlzIGlzIHBhc3NlZCB0byBjb21wbGV0aW9uIHNvdXJjZSBmdW5jdGlvbnMuXG4qL1xuY2xhc3MgQ29tcGxldGlvbkNvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBjb21wbGV0aW9uIGNvbnRleHQuIChNb3N0bHkgdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgY29tcGxldGlvbiBzb3VyY2VzXHUyMDE0aW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxuICAgIHRoZXNlIGZvciB5b3UuKVxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZSB0aGF0IHRoZSBjb21wbGV0aW9uIGhhcHBlbnMgaW4uXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjb21wbGV0aW9uIGlzIGhhcHBlbmluZy5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgY29tcGxldGlvbiB3YXMgYWN0aXZhdGVkIGV4cGxpY2l0bHksIG9yXG4gICAgaW1wbGljaXRseSBieSB0eXBpbmcuIFRoZSB1c3VhbCB3YXkgdG8gcmVzcG9uZCB0byB0aGlzIGlzIHRvXG4gICAgb25seSByZXR1cm4gY29tcGxldGlvbnMgd2hlbiBlaXRoZXIgdGhlcmUgaXMgcGFydCBvZiBhXG4gICAgY29tcGxldGFibGUgZW50aXR5IGJlZm9yZSB0aGUgY3Vyc29yLCBvciBgZXhwbGljaXRgIGlzIHRydWUuXG4gICAgKi9cbiAgICBleHBsaWNpdCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCwgY29udGVudCwgYW5kIChpZiB0aGVyZSBpcyBhIHRva2VuKSB0eXBlIG9mIHRoZVxuICAgIHRva2VuIGJlZm9yZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgdG9rZW5CZWZvcmUodHlwZXMpIHtcbiAgICAgICAgbGV0IHRva2VuID0gc3ludGF4VHJlZSh0aGlzLnN0YXRlKS5yZXNvbHZlSW5uZXIodGhpcy5wb3MsIC0xKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICYmIHR5cGVzLmluZGV4T2YodG9rZW4ubmFtZSkgPCAwKVxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5wYXJlbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbiA/IHsgZnJvbTogdG9rZW4uZnJvbSwgdG86IHRoaXMucG9zLFxuICAgICAgICAgICAgdGV4dDogdGhpcy5zdGF0ZS5zbGljZURvYyh0b2tlbi5mcm9tLCB0aGlzLnBvcyksXG4gICAgICAgICAgICB0eXBlOiB0b2tlbi50eXBlIH0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hdGNoIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uIGRpcmVjdGx5IGJlZm9yZSB0aGVcbiAgICBjdXJzb3IuXG4gICAgKi9cbiAgICBtYXRjaEJlZm9yZShleHByKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCB0aGlzLnBvcyAtIDI1MCk7XG4gICAgICAgIGxldCBzdHIgPSBsaW5lLnRleHQuc2xpY2Uoc3RhcnQgLSBsaW5lLmZyb20sIHRoaXMucG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IGZvdW5kID0gc3RyLnNlYXJjaChlbnN1cmVBbmNob3IoZXhwciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiB7IGZyb206IHN0YXJ0ICsgZm91bmQsIHRvOiB0aGlzLnBvcywgdGV4dDogc3RyLnNsaWNlKGZvdW5kKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBZaWVsZHMgdHJ1ZSB3aGVuIHRoZSBxdWVyeSBoYXMgYmVlbiBhYm9ydGVkLiBDYW4gYmUgdXNlZnVsIGluXG4gICAgYXN5bmNocm9ub3VzIHF1ZXJpZXMgdG8gYXZvaWQgZG9pbmcgd29yayB0aGF0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkgeyByZXR1cm4gdGhpcy5hYm9ydExpc3RlbmVycyA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgQWxsb3dzIHlvdSB0byByZWdpc3RlciBhYm9ydCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgIHRoZSBxdWVyeSBpc1xuICAgIFthYm9ydGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uQ29udGV4dC5hYm9ydGVkKS5cbiAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJhYm9ydFwiICYmIHRoaXMuYWJvcnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudClcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBub3QgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmTm90SW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpXG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICB9O1xufVxuY2xhc3MgT3B0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wbGV0aW9uLCBzb3VyY2UsIG1hdGNoKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgfVxufVxuZnVuY3Rpb24gY3VyKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkOyB9XG4vLyBNYWtlIHN1cmUgdGhlIGdpdmVuIHJlZ2V4cCBoYXMgYSAkIGF0IGl0cyBlbmQgYW5kLCBpZiBgc3RhcnRgIGlzXG4vLyB0cnVlLCBhIF4gYXQgaXRzIHN0YXJ0LlxuZnVuY3Rpb24gZW5zdXJlQW5jaG9yKGV4cHIsIHN0YXJ0KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IHNvdXJjZSB9ID0gZXhwcjtcbiAgICBsZXQgYWRkU3RhcnQgPSBzdGFydCAmJiBzb3VyY2VbMF0gIT0gXCJeXCIsIGFkZEVuZCA9IHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT0gXCIkXCI7XG4gICAgaWYgKCFhZGRTdGFydCAmJiAhYWRkRW5kKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgJHthZGRTdGFydCA/IFwiXlwiIDogXCJcIn0oPzoke3NvdXJjZX0pJHthZGRFbmQgPyBcIiRcIiA6IFwiXCJ9YCwgKF9hID0gZXhwci5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGV4cHIuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikpO1xufVxuLyoqXG5UaGlzIGFubm90YXRpb24gaXMgYWRkZWQgdG8gdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHByb2R1Y2VkIGJ5XG5waWNraW5nIGEgY29tcGxldGlvbi5cbiovXG5jb25zdCBwaWNrZWRDb21wbGV0aW9uID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIGluc2VydHMgYVxuY29tcGxldGlvbidzIHRleHQgaW4gdGhlIG1haW4gc2VsZWN0aW9uIHJhbmdlLCBhbmQgYW55IG90aGVyXG5zZWxlY3Rpb24gcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgdGV4dCBpbiBmcm9udCBvZiBpdC5cbiovXG5mdW5jdGlvbiBpbnNlcnRDb21wbGV0aW9uVGV4dChzdGF0ZSwgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlID09IHN0YXRlLnNlbGVjdGlvbi5tYWluKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGZyb20sIHRvOiB0bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIHRleHQubGVuZ3RoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fFxuICAgICAgICAgICAgbGVuICYmIHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20gLSBsZW4sIHJhbmdlLmZyb20pICE9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20gLSBsZW4sIHRvOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gLSBsZW4gKyB0ZXh0Lmxlbmd0aClcbiAgICAgICAgfTtcbiAgICB9KSksIHsgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIgfSk7XG59XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gb3B0aW9uLnNvdXJjZTtcbiAgICBpZiAodHlwZW9mIGFwcGx5ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnNlcnRDb21wbGV0aW9uVGV4dCh2aWV3LnN0YXRlLCBhcHBseSwgcmVzdWx0LmZyb20sIHJlc3VsdC50bykpLCB7IGFubm90YXRpb25zOiBwaWNrZWRDb21wbGV0aW9uLm9mKG9wdGlvbi5jb21wbGV0aW9uKSB9KSk7XG4gICAgZWxzZVxuICAgICAgICBhcHBseSh2aWV3LCBvcHRpb24uY29tcGxldGlvbiwgcmVzdWx0LmZyb20sIHJlc3VsdC50byk7XG59XG5jb25zdCBTb3VyY2VDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXNTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IGtub3duID0gU291cmNlQ2FjaGUuZ2V0KHNvdXJjZSk7XG4gICAgaWYgKCFrbm93bilcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xuICAgIHJldHVybiBrbm93bjtcbn1cblxuLy8gQSBwYXR0ZXJuIG1hdGNoZXIgZm9yIGZ1enp5IGNvbXBsZXRpb24gbWF0Y2hpbmcuIENyZWF0ZSBhbiBpbnN0YW5jZVxuLy8gb25jZSBmb3IgYSBwYXR0ZXJuLCBhbmQgdGhlbiB1c2UgdGhhdCB0byBtYXRjaCBhbnkgbnVtYmVyIG9mXG4vLyBjb21wbGV0aW9ucy5cbmNsYXNzIEZ1enp5TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVkID0gW107XG4gICAgICAgIC8vIEJ1ZmZlcnMgcmV1c2VkIGJ5IGNhbGxzIHRvIGBtYXRjaGAgdG8gdHJhY2sgbWF0Y2hlZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gcG9zaXRpb25zLlxuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBbXTtcbiAgICAgICAgdGhpcy5ieVdvcmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXR0ZXJuLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY29kZVBvaW50QXQocGF0dGVybiwgcCksIHNpemUgPSBjb2RlUG9pbnRTaXplKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXR0ZXJuLnNsaWNlKHAsIHAgKyBzaXplKSwgdXBwZXIgPSBwYXJ0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmZvbGRlZC5wdXNoKGNvZGVQb2ludEF0KHVwcGVyID09IHBhcnQgPyBwYXJ0LnRvTG93ZXJDYXNlKCkgOiB1cHBlciwgMCkpO1xuICAgICAgICAgICAgcCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXN0cmFsID0gcGF0dGVybi5sZW5ndGggIT0gdGhpcy5jaGFycy5sZW5ndGg7XG4gICAgfVxuICAgIC8vIE1hdGNoZXMgYSBnaXZlbiB3b3JkIChjb21wbGV0aW9uKSBhZ2FpbnN0IHRoZSBwYXR0ZXJuIChpbnB1dCkuXG4gICAgLy8gV2lsbCByZXR1cm4gbnVsbCBmb3Igbm8gbWF0Y2gsIGFuZCBvdGhlcndpc2UgYW4gYXJyYXkgdGhhdCBzdGFydHNcbiAgICAvLyB3aXRoIHRoZSBtYXRjaCBzY29yZSwgZm9sbG93ZWQgYnkgYW55IG51bWJlciBvZiBgZnJvbSwgdG9gIHBhaXJzXG4gICAgLy8gaW5kaWNhdGluZyB0aGUgbWF0Y2hlZCBwYXJ0cyBvZiBgd29yZGAuXG4gICAgLy9cbiAgICAvLyBUaGUgc2NvcmUgaXMgYSBudW1iZXIgdGhhdCBpcyBtb3JlIG5lZ2F0aXZlIHRoZSB3b3JzZSB0aGUgbWF0Y2hcbiAgICAvLyBpcy4gU2VlIGBQZW5hbHR5YCBhYm92ZS5cbiAgICBtYXRjaCh3b3JkKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdHRlcm4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGNoYXJzLCBmb2xkZWQsIGFueSwgcHJlY2lzZSwgYnlXb3JkIH0gPSB0aGlzO1xuICAgICAgICAvLyBGb3Igc2luZ2xlLWNoYXJhY3RlciBxdWVyaWVzLCBvbmx5IG1hdGNoIHdoZW4gdGhleSBvY2N1ciByaWdodFxuICAgICAgICAvLyBhdCB0aGUgc3RhcnRcbiAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjb2RlUG9pbnRBdCh3b3JkLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PSBjaGFyc1swXSA/IFswLCAwLCBjb2RlUG9pbnRTaXplKGZpcnN0KV1cbiAgICAgICAgICAgICAgICA6IGZpcnN0ID09IGZvbGRlZFswXSA/IFstMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8sIDAsIGNvZGVQb2ludFNpemUoZmlyc3QpXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzAsIDAsIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FueVRvXSB8fCBuZXh0ID09IGZvbGRlZFthbnlUb10pXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChhbnlUbyA8IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFRwLlVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogVHAuTG93ZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBUcC5VcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIFRwLk5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIFRwLk5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyAtIHdvcmQubGVuZ3RoLCAwLCBhZGphY2VudEVuZF07XG4gICAgICAgIGlmIChkaXJlY3QgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBbLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIGRpcmVjdCwgZGlyZWN0ICsgdGhpcy5wYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiBbLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIGFkamFjZW50U3RhcnQsIGFkamFjZW50RW5kXTtcbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovICtcbiAgICAgICAgICAgICAgICAod29yZEFkamFjZW50ID8gMCA6IC0xMTAwIC8qIFBlbmFsdHkuR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gbnVsbCA6IHRoaXMucmVzdWx0KChhbnlbMF0gPyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gOiAwKSArIC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC0xMTAwIC8qIFBlbmFsdHkuR2FwICovLCBhbnksIHdvcmQpO1xuICAgIH1cbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3Njb3JlIC0gd29yZC5sZW5ndGhdLCBpID0gMTtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xuICAgICAgICAgICAgaWYgKGkgPiAxICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdE9uT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IHRydWUsXG4gICAgICAgICAgICBtYXhSZW5kZXJlZE9wdGlvbnM6IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IHRydWUsXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIGFib3ZlQ3Vyc29yOiBmYWxzZSxcbiAgICAgICAgICAgIGljb25zOiB0cnVlLFxuICAgICAgICAgICAgYWRkVG9PcHRpb25zOiBbXSxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGljb25zOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCB7IGxhYmVsIH0gPSBjb21wbGV0aW9uLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZUZpZWxkID0gc3RhdGVGaWVsZDtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm8gPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wb3NpdGlvbkluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3B0aW9ucy5sZW5ndGgsIHNlbGVjdGVkLCBjb25maWcubWF4UmVuZGVyZWRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIG9wdGlvbnNbK21hdGNoWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCBwcmV2U3RhdGUgPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBpZiAoY1N0YXRlICE9IHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gY1N0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkgIT0gKChfYiA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhISgoX2MgPSBjU3RhdGUub3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2FibGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgIH1cbiAgICB1cGRhdGVTZWwoKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSwgb3BlbiA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBpZiAob3Blbi5zZWxlY3RlZCA+IC0xICYmIG9wZW4uc2VsZWN0ZWQgPCB0aGlzLnJhbmdlLmZyb20gfHwgb3Blbi5zZWxlY3RlZCA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcGVuLm9wdGlvbnMubGVuZ3RoLCBvcGVuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykubWF4UmVuZGVyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoJ3RoZW4nIGluIGluZm9SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpbmZvUmVzdWx0LnRoZW4obm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJjb21wbGV0aW9uIGluZm9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmZvUGFuZShpbmZvUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbmZvUGFuZShjb250ZW50KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCI7XG4gICAgICAgIGRvbS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBvcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKVxuICAgICAgICAgICAgICAgICAgICBvcHQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0KVxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5saXN0LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBtZWFzdXJlSW5mbygpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XG4gICAgICAgIGlmICghc2VsIHx8ICF0aGlzLmluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbmZvUmVjdCA9IHRoaXMuaW5mby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNlbFJlY3QgPSBzZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIGxldCB3aW4gPSB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsUmVjdC50b3AgPiBNYXRoLm1pbihzcGFjZS5ib3R0b20sIGxpc3RSZWN0LmJvdHRvbSkgLSAxMCB8fFxuICAgICAgICAgICAgc2VsUmVjdC5ib3R0b20gPCBNYXRoLm1heChzcGFjZS50b3AsIGxpc3RSZWN0LnRvcCkgKyAxMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcnRsID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLlJUTCwgbGVmdCA9IHJ0bCwgbmFycm93ID0gZmFsc2UsIG1heFdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gXCJcIiwgYm90dG9tID0gXCJcIjtcbiAgICAgICAgbGV0IHNwYWNlTGVmdCA9IGxpc3RSZWN0LmxlZnQgLSBzcGFjZS5sZWZ0LCBzcGFjZVJpZ2h0ID0gc3BhY2UucmlnaHQgLSBsaXN0UmVjdC5yaWdodDtcbiAgICAgICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1JlY3Qud2lkdGgsIHNwYWNlUmlnaHQpKVxuICAgICAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1JlY3Qud2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluZm9SZWN0LndpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgICAgIHRvcCA9IChNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKHNlbFJlY3QudG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvUmVjdC5oZWlnaHQpKSAtIGxpc3RSZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3RSZWN0LnJpZ2h0IDogc3BhY2UucmlnaHQgLSBsaXN0UmVjdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKSArIFwicHhcIjtcbiAgICAgICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb1JlY3QuaGVpZ2h0IHx8IHNwYWNlQmVsb3cgPiBsaXN0UmVjdC50b3ApIC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICAgICAgdG9wID0gKHNlbFJlY3QuYm90dG9tIC0gbGlzdFJlY3QudG9wKSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsc2UgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgICAgICBib3R0b20gPSAobGlzdFJlY3QuYm90dG9tIC0gc2VsUmVjdC50b3ApICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsIGJvdHRvbSwgbWF4V2lkdGgsXG4gICAgICAgICAgICBjbGFzczogbmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwb3NpdGlvbkluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUudG9wID0gcG9zLnRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuYm90dG9tID0gcG9zLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUubWF4V2lkdGggPSBwb3MubWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mbyBjbS1jb21wbGV0aW9uSW5mby1cIiArIHBvcy5jbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS50b3AgPSBcIi0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxpID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIGxpLmlkID0gaWQgKyBcIi1cIiArIGk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMub3B0aW9uQ2xhc3MoY29tcGxldGlvbik7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHNvdXJjZShjb21wbGV0aW9uLCB0aGlzLnZpZXcuc3RhdGUsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG59XG4vLyBXZSBhbGxvY2F0ZSBhIG5ldyBmdW5jdGlvbiBpbnN0YW5jZSBldmVyeSB0aW1lIHRoZSBjb21wbGV0aW9uXG4vLyBjaGFuZ2VzIHRvIGZvcmNlIHJlZHJhd2luZy9yZXBvc2l0aW9uaW5nIG9mIHRoZSB0b29sdGlwXG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiBuZXcgQ29tcGxldGlvblRvb2x0aXAodmlldywgc3RhdGVGaWVsZCk7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoc2VsZi50b3AgPCBwYXJlbnQudG9wKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IHBhcmVudC50b3AgLSBzZWxmLnRvcDtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZi5ib3R0b20gLSBwYXJlbnQuYm90dG9tO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgaSA9IDA7XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBpZiAoYS5yZXN1bHQuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGxldCBnZXRNYXRjaCA9IGEucmVzdWx0LmdldE1hdGNoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IFsxZTkgLSBpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIGdldE1hdGNoKG9wdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG5ldyBPcHRpb24ob3B0aW9uLCBhLCBtYXRjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVyID0gbmV3IEZ1enp5TWF0Y2hlcihzdGF0ZS5zbGljZURvYyhhLmZyb20sIGEudG8pKSwgbWF0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IG1hdGNoZXIubWF0Y2gob3B0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5ib29zdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdICs9IG9wdGlvbi5ib29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChuZXcgT3B0aW9uKG9wdGlvbiwgYSwgbWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICBsZXQgY29tcGFyZSA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNvbXBhcmVDb21wbGV0aW9ucztcbiAgICBmb3IgKGxldCBvcHQgb2Ygb3B0aW9ucy5zb3J0KChhLCBiKSA9PiAoYi5tYXRjaFswXSAtIGEubWF0Y2hbMF0pIHx8IGNvbXBhcmUoYS5jb21wbGV0aW9uLCBiLmNvbXBsZXRpb24pKSkge1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBvcHQuY29tcGxldGlvbi5sYWJlbCB8fCBwcmV2LmRldGFpbCAhPSBvcHQuY29tcGxldGlvbi5kZXRhaWwgfHxcbiAgICAgICAgICAgIChwcmV2LnR5cGUgIT0gbnVsbCAmJiBvcHQuY29tcGxldGlvbi50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IG9wdC5jb21wbGV0aW9uLnR5cGUpIHx8XG4gICAgICAgICAgICBwcmV2LmFwcGx5ICE9IG9wdC5jb21wbGV0aW9uLmFwcGx5KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcbiAgICAgICAgZWxzZSBpZiAoc2NvcmUob3B0LmNvbXBsZXRpb24pID4gc2NvcmUocHJldikpXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gb3B0O1xuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBDb21wbGV0aW9uRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhdHRycywgdG9vbHRpcCwgdGltZXN0YW1wLCBzZWxlY3RlZCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPT0gdGhpcy5zZWxlY3RlZCB8fCBzZWxlY3RlZCA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZChhY3RpdmUsIHN0YXRlLCBpZCwgcHJldiwgY29uZikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbXBsZXRpb25EaWFsb2cocHJldi5vcHRpb25zLCBwcmV2LmF0dHJzLCBwcmV2LnRvb2x0aXAsIHByZXYudGltZXN0YW1wLCBwcmV2LnNlbGVjdGVkLCB0cnVlKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSksXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRvb2x0aXApLCB7IHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSksIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbjtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSlcbiAgICAgICAgICAgIG9wZW4gPSBDb21wbGV0aW9uRGlhbG9nLmJ1aWxkKGFjdGl2ZSwgc3RhdGUsIHRoaXMuaWQsIHRoaXMub3BlbiwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIlxufTtcbmZ1bmN0aW9uIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZFxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkID4gLTEpXG4gICAgICAgIHJlc3VsdFtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiXSA9IGlkICsgXCItXCIgKyBzZWxlY3RlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XG4gICAgcmV0dXJuIHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSA/IFwiaW5wdXRcIiA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgc3RhdGUsIGV4cGxpY2l0UG9zID0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdFBvcyA9IGV4cGxpY2l0UG9zO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSBnZXRVc2VyRXZlbnQodHIpLCB2YWx1ZSA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlVXNlckV2ZW50KHRyLCBldmVudCwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbiAmJiB2YWx1ZS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUgPyBjdXIodHIuc3RhdGUpIDogLTEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcImRlbGV0ZVwiIHx8ICFjb25mLmFjdGl2YXRlT25UeXBpbmcgPyB0aGlzLm1hcCh0ci5jaGFuZ2VzKSA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoY3VyKHRyLnN0YXJ0U3RhdGUpKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gdGhpcyA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXRQb3MsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHBvcyA8PSBmcm9tIDogcG9zIDwgdGhpcy5mcm9tKSB8fFxuICAgICAgICAgICAgcG9zID4gdG8gfHxcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHR5cGUgPT0gXCJpbnB1dFwiICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgZXhwbGljaXRQb3MgPSB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHVwZGF0ZWQ7XG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB0aGlzLnJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQudXBkYXRlICYmXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB1cGRhdGVkLCB1cGRhdGVkLmZyb20sIChfYSA9IHVwZGF0ZWQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlQ29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0ZXAgPSAxLCB0b29sdGlwO1xuICAgICAgICBpZiAoYnkgPT0gXCJwYWdlXCIgJiYgKHRvb2x0aXAgPSBnZXRUb29sdGlwKHZpZXcsIGNTdGF0ZS5vcGVuLnRvb2x0aXApKSlcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKHRvb2x0aXAuZG9tLm9mZnNldEhlaWdodCAvXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5kb20ucXVlcnlTZWxlY3RvcihcImxpXCIpLm9mZnNldEhlaWdodCkgLSAxKTtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBjU3RhdGUub3Blbi5vcHRpb25zO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjU3RhdGUub3Blbi5zZWxlY3RlZCA+IC0xID8gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgKyBzdGVwICogKGZvcndhcmQgPyAxIDogLTEpIDogZm9yd2FyZCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCA+PSBsZW5ndGgpXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWxlY3RlZEVmZmVjdC5vZihzZWxlY3RlZCkgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjY2VwdCB0aGUgY3VycmVudCBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5IHx8ICFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLnNlbGVjdGVkIDwgMCB8fFxuICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBEZWJvdW5jZVRpbWUgPSA1MCwgTWF4VXBkYXRlQ291bnQgPSA1MCwgTWluQWJvcnRUaW1lID0gMTAwMDtcbmNvbnN0IGNvbXBsZXRpb25QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2Ygdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZSlcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvZXNSZXNldCA9IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHRyLnNlbGVjdGlvbiB8fCB0ci5kb2NDaGFuZ2VkKSAmJiAhZ2V0VXNlckV2ZW50KHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAoZG9lc1Jlc2V0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5sZW5ndGggKyB1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IE1heFVwZGF0ZUNvdW50ICYmIERhdGUubm93KCkgLSBxdWVyeS50aW1lID4gTWluQWJvcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VVcGRhdGUpO1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIERlYm91bmNlVGltZSkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChnZXRVc2VyRXZlbnQodHIpID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShyID0+IHIuYWN0aXZlLnNvdXJjZSA9PSBhY3RpdmUuc291cmNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFF1ZXJ5KGFjdGl2ZSkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBDb21wbGV0aW9uQ29udGV4dChzdGF0ZSwgcG9zLCBhY3RpdmUuZXhwbGljaXRQb3MgPT0gcG9zKTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoYWN0aXZlLnNvdXJjZShjb250ZXh0KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgRGVib3VuY2VUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdFBvcywgcXVlcnkuZG9uZSwgcXVlcnkuZG9uZS5mcm9tLCAoX2EgPSBxdWVyeS5kb25lLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIocXVlcnkudXBkYXRlcy5sZW5ndGggPyBxdWVyeS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBxdWVyeS5hY3RpdmUuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGZhaWxlZC4gU2hvdWxkIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXR1cyBpZiBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXNuJ3QgYmVlbiByZS1zZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNvdXJjZShxdWVyeS5hY3RpdmUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXJlZCBieSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucy4gUmVzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRBY3RpdmVFZmZlY3Qub2YodXBkYXRlZCkgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgYmx1cigpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b29sdGlwICYmIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1cilcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDEgLyogQ29tcG9zaXRpb25TdGF0ZS5TdGFydGVkICovO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbmVuZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA9PSAzIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZEFuZE1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIGNvbXBvc2l0aW9uZW5kIGV2ZW50cyBzeW5jaHJvbm91c2x5LCBwb3NzaWJseVxuICAgICAgICAgICAgICAgIC8vIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSwgc28gZGlzcGF0Y2ggYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKGZhbHNlKSB9KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bFwiOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzE3Y1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzc3XCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzM0N1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCJcdTAwQjdcdTAwQjdcdTAwQjdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IGAkezQwMCAvKiBJbmZvLldpZHRoICovfXB4YCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdFwiOiB7IHJpZ2h0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0XCI6IHsgbGVmdDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0LW5hcnJvd1wiOiB7IHJpZ2h0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodC1uYXJyb3dcIjogeyBsZWZ0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIiZsaWdodCAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwMDAyMlwiIH0sXG4gICAgXCImZGFyayAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmYyMlwiIH0sXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIC0wLjdweCAtLjdlbVwiLFxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiOTAlXCIsXG4gICAgICAgIHdpZHRoOiBcIi44ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IFwiLjZlbVwiLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1mdW5jdGlvbiwgLmNtLWNvbXBsZXRpb25JY29uLW1ldGhvZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MDE5MidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjVDQidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTI1Q0MnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdUQ4MzVcdURDNjUnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY29uc3RhbnRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdUQ4MzVcdURDMzYnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdHlwZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzNVx1REM2MSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyMjJBJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUExJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdUQ4M0RcdUREMTFcXHVGRTBFJ1wiIH0gLy8gRGlzYWJsZSBlbW9qaSByZW5kZXJpbmdcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLW5hbWVzcGFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjVBMidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10ZXh0XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInYWJjJ1wiLCBmb250U2l6ZTogXCI1MCVcIiwgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XG4gICAgfVxufSk7XG5cbmNsYXNzIEZpZWxkUG9zIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbGluZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuY2xhc3MgRmllbGRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSwgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICBsZXQgdG8gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsID8gbnVsbCA6IG5ldyBGaWVsZFJhbmdlKHRoaXMuZmllbGQsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcywgZmllbGRQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmZpZWxkUG9zaXRpb25zID0gZmllbGRQb3NpdGlvbnM7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlKHN0YXRlLCBwb3MpIHtcbiAgICAgICAgbGV0IHRleHQgPSBbXSwgbGluZVN0YXJ0ID0gW3Bvc107XG4gICAgICAgIGxldCBsaW5lT2JqID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiYXNlSW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmVPYmoudGV4dClbMF07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy5saW5lcykge1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IGJhc2VJbmRlbnQsIHRhYnMgPSAvXlxcdCovLmV4ZWMobGluZSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFiczsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0LnB1c2gocG9zICsgaW5kZW50Lmxlbmd0aCAtIHRhYnMpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBpbmRlbnQgKyBsaW5lLnNsaWNlKHRhYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5maWVsZFBvc2l0aW9ucy5tYXAocG9zID0+IG5ldyBGaWVsZFJhbmdlKHBvcy5maWVsZCwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy5mcm9tLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLnRvKSk7XG4gICAgICAgIHJldHVybiB7IHRleHQsIHJhbmdlcyB9O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgbGluZXMgPSBbXSwgcG9zaXRpb25zID0gW10sIG07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGVtcGxhdGUuc3BsaXQoL1xcclxcbj98XFxuLykpIHtcbiAgICAgICAgICAgIHdoaWxlIChtID0gL1sjJF1cXHsoPzooXFxkKykoPzo6KFtefV0qKSk/fChbXn1dKikpXFx9Ly5leGVjKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcSA9IG1bMV0gPyArbVsxXSA6IG51bGwsIG5hbWUgPSBtWzJdIHx8IG1bM10gfHwgXCJcIiwgZm91bmQgPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxICE9IG51bGwgPyBmaWVsZHNbaV0uc2VxID09IHNlcSA6IG5hbWUgPyBmaWVsZHNbaV0ubmFtZSA9PSBuYW1lIDogZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGggJiYgKHNlcSA9PSBudWxsIHx8IChmaWVsZHNbaV0uc2VxICE9IG51bGwgJiYgZmllbGRzW2ldLnNlcSA8IHNlcSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc3BsaWNlKGksIDAsIHsgc2VxLCBuYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmZpZWxkID49IGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5maWVsZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgRmllbGRQb3MoZm91bmQsIGxpbmVzLmxlbmd0aCwgbS5pbmRleCwgbS5pbmRleCArIG5hbWUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbS5pbmRleCkgKyBuYW1lICsgbGluZS5zbGljZShtLmluZGV4ICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZXNjOyBlc2MgPSAvKFskI10pXFxcXHsvLmV4ZWMobGluZSk7KSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgZXNjLmluZGV4KSArIGVzY1sxXSArIFwie1wiICsgbGluZS5zbGljZShlc2MuaW5kZXggKyBlc2NbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gZXNjLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MuZnJvbS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLnRvLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbmlwcGV0KGxpbmVzLCBwb3NpdGlvbnMpO1xuICAgIH1cbn1cbmxldCBmaWVsZE1hcmtlciA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSgpIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9IH0pO1xubGV0IGZpZWxkUmFuZ2UgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc25pcHBldEZpZWxkXCIgfSk7XG5jbGFzcyBBY3RpdmVTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZXMsIGFjdGl2ZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZGVjbyA9IERlY29yYXRpb24uc2V0KHJhbmdlcy5tYXAociA9PiAoci5mcm9tID09IHIudG8gPyBmaWVsZE1hcmtlciA6IGZpZWxkUmFuZ2UpLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gci5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIW1hcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgdGhpcy5hY3RpdmUpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25JbnNpZGVGaWVsZChzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5yYW5nZXMuZXZlcnkocmFuZ2UgPT4gdGhpcy5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gdGhpcy5hY3RpdmUgJiYgci5mcm9tIDw9IHJhbmdlLmZyb20gJiYgci50byA+PSByYW5nZS50bykpO1xuICAgIH1cbn1cbmNvbnN0IHNldEFjdGl2ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgY2hhbmdlcykgeyByZXR1cm4gdmFsdWUgJiYgdmFsdWUubWFwKGNoYW5nZXMpOyB9XG59KTtcbmNvbnN0IG1vdmVUb0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc25pcHBldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhtb3ZlVG9GaWVsZCkgJiYgdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHZhbHVlLnJhbmdlcywgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHIuc2VsZWN0aW9uICYmICF2YWx1ZS5zZWxlY3Rpb25JbnNpZGVGaWVsZCh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCB2YWwgPT4gdmFsID8gdmFsLmRlY28gOiBEZWNvcmF0aW9uLm5vbmUpXG59KTtcbmZ1bmN0aW9uIGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgZmllbGQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuZmlsdGVyKHIgPT4gci5maWVsZCA9PSBmaWVsZCkubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbn1cbi8qKlxuQ29udmVydCBhIHNuaXBwZXQgdGVtcGxhdGUgdG8gYSBmdW5jdGlvbiB0aGF0IGNhblxuW2FwcGx5XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uLmFwcGx5KSBpdC4gU25pcHBldHMgYXJlIHdyaXR0ZW5cbnVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XG5cbiAgICBcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCJcblxuRWFjaCBgJHt9YCBwbGFjZWhvbGRlciAoeW91IG1heSBhbHNvIHVzZSBgI3t9YCkgaW5kaWNhdGVzIGEgZmllbGRcbnRoYXQgdGhlIHVzZXIgY2FuIGZpbGwgaW4uIEl0cyBuYW1lLCBpZiBhbnksIHdpbGwgYmUgdGhlIGRlZmF1bHRcbmNvbnRlbnQgZm9yIHRoZSBmaWVsZC5cblxuV2hlbiB0aGUgc25pcHBldCBpcyBhY3RpdmF0ZWQgYnkgY2FsbGluZyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24sXG50aGUgY29kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5ld2xpbmVzIGluIHRoZVxudGVtcGxhdGUgYXJlIGluZGVudGVkIGJ5IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgc3RhcnQgbGluZSwgcGx1c1xub25lIFtpbmRlbnQgdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBwZXIgdGFiIGNoYXJhY3RlciBhZnRlclxudGhlIG5ld2xpbmUuXG5cbk9uIGFjdGl2YXRpb24sIChhbGwgaW5zdGFuY2VzIG9mKSB0aGUgZmlyc3QgZmllbGQgYXJlIHNlbGVjdGVkLlxuVGhlIHVzZXIgY2FuIG1vdmUgYmV0d2VlbiBmaWVsZHMgd2l0aCBUYWIgYW5kIFNoaWZ0LVRhYiBhcyBsb25nIGFzXG50aGUgZmllbGRzIGFyZSBhY3RpdmUuIE1vdmluZyB0byB0aGUgbGFzdCBmaWVsZCBvciBtb3ZpbmcgdGhlXG5jdXJzb3Igb3V0IG9mIHRoZSBjdXJyZW50IGZpZWxkIGRlYWN0aXZhdGVzIHRoZSBmaWVsZHMuXG5cblRoZSBvcmRlciBvZiBmaWVsZHMgZGVmYXVsdHMgdG8gdGV4dHVhbCBvcmRlciwgYnV0IHlvdSBjYW4gYWRkXG5udW1iZXJzIHRvIHBsYWNlaG9sZGVycyAoYCR7MX1gIG9yIGAkezE6ZGVmYXVsdFRleHR9YCkgdG8gcHJvdmlkZVxuYSBjdXN0b20gb3JkZXIuXG5cblRvIGluY2x1ZGUgYSBsaXRlcmFsIGAke2Agb3IgYCN7YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYVxuYmFja3NsYXNoIGFmdGVyIHRoZSBkb2xsYXIgb3IgaGFzaCBhbmQgYmVmb3JlIHRoZSBicmFjZSAoYCRcXFxce2ApLlxuVGhpcyB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBzZXF1ZW5jZSB3aWxsIG5vdCBiZSBpbnRlcnByZXRlZCBhcyBhXG5wbGFjZWhvbGRlci5cbiovXG5mdW5jdGlvbiBzbmlwcGV0KHRlbXBsYXRlKSB7XG4gICAgbGV0IHNuaXBwZXQgPSBTbmlwcGV0LnBhcnNlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gKGVkaXRvciwgX2NvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjLnNlbGVjdGlvbiA9IGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgMCk7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgMCk7XG4gICAgICAgICAgICBsZXQgZWZmZWN0cyA9IHNwZWMuZWZmZWN0cyA9IFtzZXRBY3RpdmUub2YoYWN0aXZlKV07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZWRpdG9yLnN0YXRlLnVwZGF0ZShzcGVjKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVGaWVsZChkaXIpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCBkaXIgPCAwICYmIGFjdGl2ZS5hY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG5leHQgPSBhY3RpdmUuYWN0aXZlICsgZGlyLCBsYXN0ID0gZGlyID4gMCAmJiAhYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBuZXh0ICsgZGlyKTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YobGFzdCA/IG51bGwgOiBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBuZXh0KSlcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BIGNvbW1hbmQgdGhhdCBjbGVhcnMgdGhlIGFjdGl2ZSBzbmlwcGV0LCBpZiBhbnkuXG4qL1xuY29uc3QgY2xlYXJTbmlwcGV0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBlZmZlY3RzOiBzZXRBY3RpdmUub2YobnVsbCkgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0byB0aGUgbmV4dCBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgbmV4dFNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoMSk7XG4vKipcbk1vdmUgdG8gdGhlIHByZXZpb3VzIHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBwcmV2U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgtMSk7XG5jb25zdCBkZWZhdWx0U25pcHBldEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJUYWJcIiwgcnVuOiBuZXh0U25pcHBldEZpZWxkLCBzaGlmdDogcHJldlNuaXBwZXRGaWVsZCB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsZWFyU25pcHBldCB9XG5dO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBrZXkgYmluZGluZ3MgdXNlZCBieVxuc25pcHBldHMuIFRoZSBkZWZhdWx0IGJpbmRzIFRhYiB0b1xuW2BuZXh0U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubmV4dFNuaXBwZXRGaWVsZCksIFNoaWZ0LVRhYiB0b1xuW2BwcmV2U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUucHJldlNuaXBwZXRGaWVsZCksIGFuZCBFc2NhcGVcbnRvIFtgY2xlYXJTbmlwcGV0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xlYXJTbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxufSk7XG5jb25zdCBhZGRTbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGUoW3NuaXBwZXRLZXltYXBdLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChzbmlwcGV0S2V5bWFwKSkpO1xuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIGZyb20gYSBzbmlwcGV0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZVxucHJvcGVydGllcyBmcm9tIGBjb21wbGV0aW9uYCwgcGx1cyBhbiBgYXBwbHlgIGZ1bmN0aW9uIHRoYXRcbmFwcGxpZXMgdGhlIHNuaXBwZXQuXG4qL1xuZnVuY3Rpb24gc25pcHBldENvbXBsZXRpb24odGVtcGxhdGUsIGNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21wbGV0aW9uKSwgeyBhcHBseTogc25pcHBldCh0ZW1wbGF0ZSkgfSk7XG59XG5jb25zdCBzbmlwcGV0UG9pbnRlckhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBtb3VzZWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHZpZXcuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSksIHBvcztcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgKHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbWF0Y2ggPSBhY3RpdmUucmFuZ2VzLmZpbmQociA9PiByLmZyb20gPD0gcG9zICYmIHIudG8gPj0gcG9zKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5maWVsZCA9PSBhY3RpdmUuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPiBtYXRjaC5maWVsZCkgPyBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcbiAgICBsZXQgZXNjYXBlZCA9IHdvcmRDaGFycy5yZXBsYWNlKC9bXFxcXFsuKyo/KCl7fF4kXS9nLCBcIlxcXFwkJlwiKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV8ke2VzY2FwZWR9XStgLCBcInVnXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXHcke2VzY2FwZWR9XWAsIFwiZ1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBSRShyZSwgZikge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGYocmUuc291cmNlKSwgcmUudW5pY29kZSA/IFwidVwiIDogXCJcIik7XG59XG5jb25zdCB3b3JkQ2FjaGVzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiB3b3JkQ2FjaGUod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIHdvcmRDYWNoZXNbd29yZENoYXJzXSB8fCAod29yZENhY2hlc1t3b3JkQ2hhcnNdID0gbmV3IFdlYWtNYXApO1xufVxuZnVuY3Rpb24gc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCkge1xuICAgIGZvciAobGV0IGxpbmVzID0gZG9jLml0ZXJMaW5lcygpLCBwb3MgPSAwOyAhbGluZXMubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcbiAgICAgICAgd29yZFJFLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gd29yZFJFLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIGxhYmVsOiBtWzBdIH0pO1xuICAgICAgICAgICAgICAgIHNlZW5bbVswXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHZhbHVlLmxlbmd0aCArIDE7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFdvcmRzKGRvYywgY2FjaGUsIHdvcmRSRSwgdG8sIGlnbm9yZUF0KSB7XG4gICAgbGV0IGJpZyA9IGRvYy5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbGxlY3RXb3JkcyhjaCwgY2FjaGUsIHdvcmRSRSwgdG8gLSBwb3MsIGlnbm9yZUF0IC0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bYy5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVdvcmRzKGNoLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQgLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpO1xuICAgIH1cbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgY2FjaGUuc2V0KGRvYywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCB3b3JkQ2hhcnMgPSBjb250ZXh0LnN0YXRlLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGNvbnRleHQucG9zKS5qb2luKFwiXCIpO1xuICAgIGxldCByZSA9IHdvcmRSRSh3b3JkQ2hhcnMpO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XG4gICAgaWYgKCF0b2tlbiAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcbiAgICBsZXQgb3B0aW9ucyA9IGNvbGxlY3RXb3Jkcyhjb250ZXh0LnN0YXRlLmRvYywgd29yZENhY2hlKHdvcmRDaGFycyksIHJlLCA1MDAwMCAvKiBDLlJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXBwZWQ7XG4gICAgfVxufSk7XG5jb25zdCBza2lwQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykgeyByZXR1cm4gbWFwcGluZy5tYXBQb3ModmFsdWUpOyB9XG59KTtcbmNvbnN0IGNsb3NlZEJyYWNrZXQgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG59O1xuY2xvc2VkQnJhY2tldC5zdGFydFNpZGUgPSAxO1xuY2xvc2VkQnJhY2tldC5lbmRTaWRlID0gLTE7XG5jb25zdCBicmFja2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCkuZnJvbTtcbiAgICAgICAgICAgIGxldCBwcmV2TGluZVN0YXJ0ID0gdHIuc3RhcnRTdGF0ZS5kb2MubGluZUF0KHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkuZnJvbTtcbiAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgIT0gdHIuY2hhbmdlcy5tYXBQb3MocHJldkxpbmVTdGFydCwgLTEpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gUmFuZ2VTZXQuZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBhZGQ6IFtjbG9zZWRCcmFja2V0LnJhbmdlKGVmZmVjdC52YWx1ZSwgZWZmZWN0LnZhbHVlICsgMSldIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNraXBCcmFja2V0RWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZnJvbSA9PiBmcm9tICE9IGVmZmVjdC52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG5icmFja2V0IGlzIHR5cGVkLCBpdHMgY2xvc2luZyBicmFja2V0IGlzIGltbWVkaWF0ZWx5IGluc2VydGVkXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcbmNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbnRoYXQgYnJhY2tldC5cbiovXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbaW5wdXRIYW5kbGVyLCBicmFja2V0U3RhdGVdO1xufVxuY29uc3QgZGVmaW5lZENsb3NpbmcgPSBcIigpW117fTw+XCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NpbmcoY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5iYWNrd2FyZFwiIH0pKTtcbiAgICByZXR1cm4gIWRvbnQ7XG59O1xuLyoqXG5DbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxuKi9cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8qKlxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxuZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbnNlbGVjdGlvbiwgYW5kIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggaXQgcmVxdWlyZXMgY3VzdG9tXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxucHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRpbmcgdGhhdCBjdXN0b20gYmVoYXZpb3IuIChZb3Ugb25seSBuZWVkIHRoaXMgaWYgeW91IHdhbnRcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRzXHUyMDE0dGhlXG5bYGNsb3NlQnJhY2tldHNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxudGFrZSBjYXJlIG9mIHJ1bm5pbmcgdGhpcyBmb3IgdXNlciBpbnB1dC4pXG4qL1xuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKGNvZGVQb2ludEF0KHRvaywgMCkpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VkID09IHRvayA/IGhhbmRsZVNhbWUoc3RhdGUsIHRvaywgdG9rZW5zLmluZGV4T2YodG9rICsgdG9rICsgdG9rKSA+IC0xLCBjb25mKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT3BlbihzdGF0ZSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNsb3NlKHN0YXRlLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBvcGVuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgbW92ZWQgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkb250ID0gcmFuZ2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKG1vdmVkLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIGVmZmVjdHM6IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKCh7IGZyb20gfSkgPT4gc2tpcEJyYWNrZXRFZmZlY3Qub2YoZnJvbSkpXG4gICAgfSk7XG59XG4vLyBIYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBvcGVuIGFuZCBjbG9zZSB0b2tlbiBhcmUgdGhlIHNhbWUsIGFuZFxuLy8gcG9zc2libHkgdHJpcGxlIHF1b3RlcyAoYXMgaW4gYFwiXCJcImFiY1wiXCJcImAtc3R5bGUgcXVvdGluZykuXG5mdW5jdGlvbiBoYW5kbGVTYW1lKHN0YXRlLCB0b2tlbiwgYWxsb3dUcmlwbGUsIGNvbmZpZykge1xuICAgIGxldCBzdHJpbmdQcmVmaXhlcyA9IGNvbmZpZy5zdHJpbmdQcmVmaXhlcyB8fCBkZWZhdWx0cy5zdHJpbmdQcmVmaXhlcztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcG9zKSwgc3RhcnQ7XG4gICAgICAgIGlmIChuZXh0ID09IHRva2VuKSB7XG4gICAgICAgICAgICBpZiAobm9kZVN0YXJ0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVHJpcGxlID0gYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyB0b2tlbi5sZW5ndGggKiAzKSA9PSB0b2tlbiArIHRva2VuICsgdG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoICogKGlzVHJpcGxlID8gMyA6IDEpKSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogc2tpcEJyYWNrZXRFZmZlY3Qub2YocG9zKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHBvcykgPT0gdG9rZW4gKyB0b2tlbiAmJlxuICAgICAgICAgICAgKHN0YXJ0ID0gY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgc3RyaW5nUHJlZml4ZXMpKSA+IC0xICYmXG4gICAgICAgICAgICBub2RlU3RhcnQoc3RhdGUsIHN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4gKyB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcykobmV4dCkgIT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgIGlmIChjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHN0cmluZ1ByZWZpeGVzKSA+IC0xICYmICFwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHRva2VuLCBzdHJpbmdQcmVmaXhlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9kZVN0YXJ0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MgKyAxKTtcbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgJiYgdHJlZS5mcm9tID09IHBvcztcbn1cbmZ1bmN0aW9uIHByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgcXVvdGVUb2tlbiwgcHJlZml4ZXMpIHtcbiAgICBsZXQgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKTtcbiAgICBsZXQgbWF4UHJlZml4ID0gcHJlZml4ZXMucmVkdWNlKChtLCBwKSA9PiBNYXRoLm1heChtLCBwLmxlbmd0aCksIDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgTWF0aC5taW4obm9kZS50bywgbm9kZS5mcm9tICsgcXVvdGVUb2tlbi5sZW5ndGggKyBtYXhQcmVmaXgpKTtcbiAgICAgICAgbGV0IHF1b3RlUG9zID0gc3RhcnQuaW5kZXhPZihxdW90ZVRva2VuKTtcbiAgICAgICAgaWYgKCFxdW90ZVBvcyB8fCBxdW90ZVBvcyA+IC0xICYmIHByZWZpeGVzLmluZGV4T2Yoc3RhcnQuc2xpY2UoMCwgcXVvdGVQb3MpKSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoZmlyc3QgJiYgZmlyc3QuZnJvbSA9PSBub2RlLmZyb20gJiYgZmlyc3QudG8gLSBmaXJzdC5mcm9tID4gcXVvdGVUb2tlbi5sZW5ndGggKyBxdW90ZVBvcykge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhmaXJzdC50byAtIHF1b3RlVG9rZW4ubGVuZ3RoLCBmaXJzdC50bykgPT0gcXVvdGVUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmlyc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnRvID09IHBvcyAmJiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBwcmVmaXhlcykge1xuICAgIGxldCBjaGFyQ2F0ID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgaWYgKGNoYXJDYXQoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgZm9yIChsZXQgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIHByZWZpeC5sZW5ndGg7XG4gICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhzdGFydCwgcG9zKSA9PSBwcmVmaXggJiYgY2hhckNhdChzdGF0ZS5zbGljZURvYyhzdGFydCAtIDEsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYXV0b2NvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gYXV0b2NvbXBsZXRpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb21wbGV0aW9uU3RhdGUsXG4gICAgICAgIGNvbXBsZXRpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY29tcGxldGlvblBsdWdpbixcbiAgICAgICAgY29tcGxldGlvbktleW1hcEV4dCxcbiAgICAgICAgYmFzZVRoZW1lXG4gICAgXTtcbn1cbi8qKlxuQmFzaWMga2V5YmluZGluZ3MgZm9yIGF1dG9jb21wbGV0aW9uLlxuXG4gLSBDdHJsLVNwYWNlOiBbYHN0YXJ0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnN0YXJ0Q29tcGxldGlvbilcbiAtIEVzY2FwZTogW2BjbG9zZUNvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUNvbXBsZXRpb24pXG4gLSBBcnJvd0Rvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUpYFxuIC0gQXJyb3dVcDogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAoZmFsc2UpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBFbnRlcjogW2BhY2NlcHRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYWNjZXB0Q29tcGxldGlvbilcbiovXG5jb25zdCBjb21wbGV0aW9uS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU3BhY2VcIiwgcnVuOiBzdGFydENvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZUNvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSkgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBhY2NlcHRDb21wbGV0aW9uIH1cbl07XG5jb25zdCBjb21wbGV0aW9uS2V5bWFwRXh0ID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGVOKFtjb21wbGV0aW9uQ29uZmlnXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuZGVmYXVsdEtleW1hcCA/IFtjb21wbGV0aW9uS2V5bWFwXSA6IFtdKSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBjb21wbGV0aW9uIHN0YXR1cy4gV2hlbiBjb21wbGV0aW9ucyBhcmUgYXZhaWxhYmxlLFxudGhpcyB3aWxsIHJldHVybiBgXCJhY3RpdmVcImAuIFdoZW4gY29tcGxldGlvbnMgYXJlIHBlbmRpbmcgKGluIHRoZVxucHJvY2VzcyBvZiBiZWluZyBxdWVyaWVkKSwgdGhpcyByZXR1cm5zIGBcInBlbmRpbmdcImAuIE90aGVyd2lzZSwgaXRcbnJldHVybnMgYG51bGxgLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25TdGF0dXMoc3RhdGUpIHtcbiAgICBsZXQgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykgPyBcInBlbmRpbmdcIlxuICAgICAgICA6IGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gXCJhY3RpdmVcIiA6IG51bGw7XG59XG5jb25zdCBjb21wbGV0aW9uQXJyYXlDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcDtcbi8qKlxuUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNvbXBsZXRpb25zIGFzIGFuIGFycmF5LlxuKi9cbmZ1bmN0aW9uIGN1cnJlbnRDb21wbGV0aW9ucyhzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICBpZiAoIW9wZW4gfHwgb3Blbi5kaXNhYmxlZClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBjb21wbGV0aW9ucyA9IGNvbXBsZXRpb25BcnJheUNhY2hlLmdldChvcGVuLm9wdGlvbnMpO1xuICAgIGlmICghY29tcGxldGlvbnMpXG4gICAgICAgIGNvbXBsZXRpb25BcnJheUNhY2hlLnNldChvcGVuLm9wdGlvbnMsIGNvbXBsZXRpb25zID0gb3Blbi5vcHRpb25zLm1hcChvID0+IG8uY29tcGxldGlvbikpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbi8qKlxuUmV0dXJuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbiwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF0uY29tcGxldGlvbiA6IG51bGw7XG59XG4vKipcblJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwb3NpdGlvbiBpbiB0aGUgYWN0aXZlIGNvbXBsZXRpb25cbmxpc3QsIG9yIG51bGwgaWYgbm8gY29tcGxldGlvbnMgYXJlIGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb25JbmRleChzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLnNlbGVjdGVkIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGNoYW5nZVxudGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkQ29tcGxldGlvbihpbmRleCkge1xuICAgIHJldHVybiBzZXRTZWxlY3RlZEVmZmVjdC5vZihpbmRleCk7XG59XG5cbmV4cG9ydCB7IENvbXBsZXRpb25Db250ZXh0LCBhY2NlcHRDb21wbGV0aW9uLCBhdXRvY29tcGxldGlvbiwgY2xlYXJTbmlwcGV0LCBjbG9zZUJyYWNrZXRzLCBjbG9zZUJyYWNrZXRzS2V5bWFwLCBjbG9zZUNvbXBsZXRpb24sIGNvbXBsZXRlQW55V29yZCwgY29tcGxldGVGcm9tTGlzdCwgY29tcGxldGlvbktleW1hcCwgY29tcGxldGlvblN0YXR1cywgY3VycmVudENvbXBsZXRpb25zLCBkZWxldGVCcmFja2V0UGFpciwgaWZJbiwgaWZOb3RJbiwgaW5zZXJ0QnJhY2tldCwgaW5zZXJ0Q29tcGxldGlvblRleHQsIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uLCBuZXh0U25pcHBldEZpZWxkLCBwaWNrZWRDb21wbGV0aW9uLCBwcmV2U25pcHBldEZpZWxkLCBzZWxlY3RlZENvbXBsZXRpb24sIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4LCBzZXRTZWxlY3RlZENvbXBsZXRpb24sIHNuaXBwZXQsIHNuaXBwZXRDb21wbGV0aW9uLCBzbmlwcGV0S2V5bWFwLCBzdGFydENvbXBsZXRpb24gfTtcbiIsICJpbXBvcnQgeyBEZWNvcmF0aW9uLCBzaG93UGFuZWwsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgZ3V0dGVyLCBzaG93VG9vbHRpcCwgZ2V0UGFuZWwsIFdpZGdldFR5cGUsIGhvdmVyVG9vbHRpcCwgR3V0dGVyTWFya2VyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNsYXNzIFNlbGVjdGVkRGlhZ25vc3RpYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbn1cbmNsYXNzIExpbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MsIHBhbmVsLCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlKSB7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgbGlzdCBvZiBkaWFnbm9zdGljcyBmb3Igd2hpY2ggdG8gY3JlYXRlIG1hcmtlcnNcbiAgICAgICAgbGV0IG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gc3RhdGUuZmFjZXQobGludENvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgIG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihtYXJrZWREaWFnbm9zdGljcyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBEZWNvcmF0aW9uLnNldChtYXJrZWREaWFnbm9zdGljcy5tYXAoKGQpID0+IHtcbiAgICAgICAgICAgIC8vIEZvciB6ZXJvLWxlbmd0aCByYW5nZXMgb3IgcmFuZ2VzIGNvdmVyaW5nIG9ubHkgYSBsaW5lIGJyZWFrLCBjcmVhdGUgYSB3aWRnZXRcbiAgICAgICAgICAgIHJldHVybiBkLmZyb20gPT0gZC50byB8fCAoZC5mcm9tID09IGQudG8gLSAxICYmIHN0YXRlLmRvYy5saW5lQXQoZC5mcm9tKS50byA9PSBkLmZyb20pXG4gICAgICAgICAgICAgICAgPyBEZWNvcmF0aW9uLndpZGdldCh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IERpYWdub3N0aWNXaWRnZXQoZCksXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGRcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShkLmZyb20pXG4gICAgICAgICAgICAgICAgOiBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBkLnNldmVyaXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGRcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShkLmZyb20sIGQudG8pO1xuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKHJhbmdlcywgcGFuZWwsIGZpbmREaWFnbm9zdGljKHJhbmdlcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkaWFnbm9zdGljID0gbnVsbCwgYWZ0ZXIgPSAwKSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKGFmdGVyLCAxZTksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKGRpYWdub3N0aWMgJiYgc3BlYy5kaWFnbm9zdGljICE9IGRpYWdub3N0aWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvdW5kID0gbmV3IFNlbGVjdGVkRGlhZ25vc3RpYyhmcm9tLCB0bywgc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSB7XG4gICAgcmV0dXJuICEhKHRyLmVmZmVjdHMuc29tZShlID0+IGUuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB8fCB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZSh0b29sdGlwLnBvcykpO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGVMaW50KHN0YXRlLCBlZmZlY3RzKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpID8gZWZmZWN0cyA6IGVmZmVjdHMuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbXG4gICAgICAgIGxpbnRTdGF0ZSxcbiAgICAgICAgRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5jb21wdXRlKFtsaW50U3RhdGVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBzZWxlY3RlZCwgcGFuZWwgfSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gRGVjb3JhdGlvbi5ub25lIDogRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICAgICAgICAgIGFjdGl2ZU1hcmsucmFuZ2Uoc2VsZWN0ZWQuZnJvbSwgc2VsZWN0ZWQudG8pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSksXG4gICAgICAgIGhvdmVyVG9vbHRpcChsaW50VG9vbHRpcCwgeyBoaWRlT246IGhpZGVUb29sdGlwIH0pLFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdKSk7XG59XG4vKipcblJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2V0IG9mXG5kaWFnbm9zdGljcywgYW5kIGVuYWJsZXMgdGhlIGxpbnQgZXh0ZW5zaW9uIGlmIGlmIHdhc24ndCBhbHJlYWR5XG5hY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2V0RGlhZ25vc3RpY3Moc3RhdGUsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHN0YXRlLCBbc2V0RGlhZ25vc3RpY3NFZmZlY3Qub2YoZGlhZ25vc3RpY3MpXSlcbiAgICB9O1xufVxuLyoqXG5UaGUgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgc2V0IG9mIGFjdGl2ZSBkaWFnbm9zdGljcy4gQ2FuXG5iZSB1c2VmdWwgd2hlbiB3cml0aW5nIGFuIGV4dGVuc2lvbiB0aGF0IG5lZWRzIHRvIHRyYWNrIHRoZXNlLlxuKi9cbmNvbnN0IHNldERpYWdub3N0aWNzRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBtb3ZlUGFuZWxTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUoRGVjb3JhdGlvbi5ub25lLCBudWxsLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSB2YWx1ZS5kaWFnbm9zdGljcy5tYXAodHIuY2hhbmdlcyksIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWxQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5zZWxlY3RlZC5mcm9tLCAxKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgdmFsdWUuc2VsZWN0ZWQuZGlhZ25vc3RpYywgc2VsUG9zKSB8fCBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIG51bGwsIHNlbFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUobWFwcGVkLCB2YWx1ZS5wYW5lbCwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTGludFN0YXRlLmluaXQoZWZmZWN0LnZhbHVlLCB2YWx1ZS5wYW5lbCwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgZWZmZWN0LnZhbHVlID8gTGludFBhbmVsLm9wZW4gOiBudWxsLCB2YWx1ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMobW92ZVBhbmVsU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgdmFsdWUucGFuZWwsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBbc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbCksXG4gICAgICAgIEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCBzID0+IHMuZGlhZ25vc3RpY3MpXVxufSk7XG4vKipcblJldHVybnMgdGhlIG51bWJlciBvZiBhY3RpdmUgbGludCBkaWFnbm9zdGljcyBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZGlhZ25vc3RpY0NvdW50KHN0YXRlKSB7XG4gICAgbGV0IGxpbnQgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGludCA/IGxpbnQuZGlhZ25vc3RpY3Muc2l6ZSA6IDA7XG59XG5jb25zdCBhY3RpdmVNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtYWN0aXZlXCIgfSk7XG5mdW5jdGlvbiBsaW50VG9vbHRpcCh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBkaWFnbm9zdGljcyB9ID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgIGxldCBmb3VuZCA9IFtdLCBzdGFja1N0YXJ0ID0gMmU4LCBzdGFja0VuZCA9IDA7XG4gICAgZGlhZ25vc3RpY3MuYmV0d2Vlbihwb3MgLSAoc2lkZSA8IDAgPyAxIDogMCksIHBvcyArIChzaWRlID4gMCA/IDEgOiAwKSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAocG9zID49IGZyb20gJiYgcG9zIDw9IHRvICYmXG4gICAgICAgICAgICAoZnJvbSA9PSB0byB8fCAoKHBvcyA+IGZyb20gfHwgc2lkZSA+IDApICYmIChwb3MgPCB0byB8fCBzaWRlIDwgMCkpKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICAgICAgc3RhY2tTdGFydCA9IE1hdGgubWluKGZyb20sIHN0YWNrU3RhcnQpO1xuICAgICAgICAgICAgc3RhY2tFbmQgPSBNYXRoLm1heCh0bywgc3RhY2tFbmQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgIGZvdW5kID0gZGlhZ25vc3RpY0ZpbHRlcihmb3VuZCk7XG4gICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvczogc3RhY2tTdGFydCxcbiAgICAgICAgZW5kOiBzdGFja0VuZCxcbiAgICAgICAgYWJvdmU6IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFja1N0YXJ0KS50byA8IHN0YWNrRW5kLFxuICAgICAgICBjcmVhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb206IGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBmb3VuZCkgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4gZWx0KFwidWxcIiwgeyBjbGFzczogXCJjbS10b29sdGlwLWxpbnRcIiB9LCBkaWFnbm9zdGljcy5tYXAoZCA9PiByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGQsIGZhbHNlKSkpO1xufVxuLyoqXG5Db21tYW5kIHRvIG9wZW4gYW5kIGZvY3VzIHRoZSBsaW50IHBhbmVsLlxuKi9cbmNvbnN0IG9wZW5MaW50UGFuZWwgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQucGFuZWwpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQodmlldy5zdGF0ZSwgW3RvZ2dsZVBhbmVsLm9mKHRydWUpXSkgfSk7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgTGludFBhbmVsLm9wZW4pO1xuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tcGFuZWwtbGludCB1bFwiKS5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ29tbWFuZCB0byBjbG9zZSB0aGUgbGludCBwYW5lbCwgd2hlbiBvcGVuLlxuKi9cbmNvbnN0IGNsb3NlTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBkaWFnbm9zdGljLlxuKi9cbmNvbnN0IG5leHREaWFnbm9zdGljID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoc2VsLnRvICsgMSk7XG4gICAgaWYgKCFuZXh0LnZhbHVlKSB7XG4gICAgICAgIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKDApO1xuICAgICAgICBpZiAoIW5leHQudmFsdWUgfHwgbmV4dC5mcm9tID09IHNlbC5mcm9tICYmIG5leHQudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogbmV4dC5mcm9tLCBoZWFkOiBuZXh0LnRvIH0sIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBzZXQgb2YgZGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSBsaW50IGZ1bmN0aW9uYWxpdHkuXG5cbi0gQ3RybC1TaGlmdC1tIChDbWQtU2hpZnQtbSBvbiBtYWNPUyk6IFtgb3BlbkxpbnRQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5vcGVuTGludFBhbmVsKVxuLSBGODogW2BuZXh0RGlhZ25vc3RpY2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5uZXh0RGlhZ25vc3RpYylcbiovXG5jb25zdCBsaW50S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1tXCIsIHJ1bjogb3BlbkxpbnRQYW5lbCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJGOFwiLCBydW46IG5leHREaWFnbm9zdGljIH1cbl07XG5jb25zdCBsaW50UGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgIGxldCB7IGRlbGF5IH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGRlbGF5KTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA8IHRoaXMubGludFRpbWUgLSAxMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnJ1biwgdGhpcy5saW50VGltZSAtIG5vdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgeyBzb3VyY2VzIH0gPSBzdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHNvdXJjZXMubWFwKHNvdXJjZSA9PiBQcm9taXNlLnJlc29sdmUoc291cmNlKHRoaXMudmlldykpKSkudGhlbihhbm5vdGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFsbCA9IGFubm90YXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jID09IHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHNldERpYWdub3N0aWNzKHRoaXMudmlldy5zdGF0ZSwgYWxsKSk7XG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycm9yKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgY29uZmlnICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbnRDb25maWcpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKSB9LCBjb21iaW5lQ29uZmlnKGlucHV0Lm1hcChpID0+IGkuY29uZmlnKSwge1xuICAgICAgICAgICAgZGVsYXk6IDc1MCxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgZW5hYmxlczogbGludFBsdWdpblxufSk7XG4vKipcbkdpdmVuIGEgZGlhZ25vc3RpYyBzb3VyY2UsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBleHRlbnNpb24gdGhhdFxuZW5hYmxlcyBsaW50aW5nIHdpdGggdGhhdCBzb3VyY2UuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxuZWRpdG9yIGlzIGlkbGUgKGFmdGVyIGl0cyBjb250ZW50IGNoYW5nZWQpLlxuKi9cbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KTtcbn1cbi8qKlxuRm9yY2VzIGFueSBsaW50ZXJzIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKSB0byBydW4gd2hlbiB0aGVcbmVkaXRvciBpcyBpZGxlIHRvIHJ1biByaWdodCBhd2F5LlxuKi9cbmZ1bmN0aW9uIGZvcmNlTGludGluZyh2aWV3KSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKGxpbnRQbHVnaW4pO1xuICAgIGlmIChwbHVnaW4pXG4gICAgICAgIHBsdWdpbi5mb3JjZSgpO1xufVxuZnVuY3Rpb24gYXNzaWduS2V5cyhhY3Rpb25zKSB7XG4gICAgbGV0IGFzc2lnbmVkID0gW107XG4gICAgaWYgKGFjdGlvbnMpXG4gICAgICAgIGFjdGlvbnM6IGZvciAobGV0IHsgbmFtZSB9IG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IG5hbWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChjaCkgJiYgIWFzc2lnbmVkLnNvbWUoYyA9PiBjLnRvTG93ZXJDYXNlKCkgPT0gY2gudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduZWQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBhc3NpZ25lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgaW5QYW5lbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQga2V5cyA9IGluUGFuZWwgPyBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucykgOiBbXTtcbiAgICByZXR1cm4gZWx0KFwibGlcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljIGNtLWRpYWdub3N0aWMtXCIgKyBkaWFnbm9zdGljLnNldmVyaXR5IH0sIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljVGV4dFwiIH0sIGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSA/IGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSgpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcbiAgICAgICAgbGV0IGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgYWN0aW9uLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gYWN0aW9uLCBrZXlJbmRleCA9IGtleXNbaV0gPyBuYW1lLmluZGV4T2Yoa2V5c1tpXSkgOiAtMTtcbiAgICAgICAgbGV0IG5hbWVFbHQgPSBrZXlJbmRleCA8IDAgPyBuYW1lIDogW25hbWUuc2xpY2UoMCwga2V5SW5kZXgpLFxuICAgICAgICAgICAgZWx0KFwidVwiLCBuYW1lLnNsaWNlKGtleUluZGV4LCBrZXlJbmRleCArIDEpKSxcbiAgICAgICAgICAgIG5hbWUuc2xpY2Uoa2V5SW5kZXggKyAxKV07XG4gICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWRpYWdub3N0aWNBY3Rpb25cIixcbiAgICAgICAgICAgIG9uY2xpY2s6IGNsaWNrLFxuICAgICAgICAgICAgb25tb3VzZWRvd246IGNsaWNrLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGAgQWN0aW9uOiAke25hbWV9JHtrZXlJbmRleCA8IDAgPyBcIlwiIDogYCAoYWNjZXNzIGtleSBcIiR7a2V5c1tpXX0pXCJgfS5gXG4gICAgICAgIH0sIG5hbWVFbHQpO1xuICAgIH0pLCBkaWFnbm9zdGljLnNvdXJjZSAmJiBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljU291cmNlXCIgfSwgZGlhZ25vc3RpYy5zb3VyY2UpKTtcbn1cbmNsYXNzIERpYWdub3N0aWNXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5kaWFnbm9zdGljID09IHRoaXMuZGlhZ25vc3RpYzsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWxpbnRQb2ludCBjbS1saW50UG9pbnQtXCIgKyB0aGlzLmRpYWdub3N0aWMuc2V2ZXJpdHkgfSk7XG4gICAgfVxufVxuY2xhc3MgUGFuZWxJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgICAgIHRoaXMuaWQgPSBcIml0ZW1fXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIHRoaXMuZG9tID0gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb20uaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIH1cbn1cbmNsYXNzIExpbnRQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIGxldCBvbmtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGNsb3NlTGludFBhbmVsKHRoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM4IHx8IGV2ZW50LmtleUNvZGUgPT0gMzMpIHsgLy8gQXJyb3dVcCwgUGFnZVVwXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxICsgdGhpcy5pdGVtcy5sZW5ndGgpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCB8fCBldmVudC5rZXlDb2RlID09IDM0KSB7IC8vIEFycm93RG93biwgUGFnZURvd25cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNikgeyAvLyBIb21lXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNSkgeyAvLyBFbmRcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24odGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPj0gNjUgJiYgZXZlbnQua2V5Q29kZSA8PSA5MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkgeyAvLyBBLVpcbiAgICAgICAgICAgICAgICBsZXQgeyBkaWFnbm9zdGljIH0gPSB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0sIGtleXMgPSBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgPT0gZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWMuYWN0aW9uc1tpXS5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBlbHQoXCJ1bFwiLCB7XG4gICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIHJvbGU6IFwibGlzdGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJEaWFnbm9zdGljc1wiKSxcbiAgICAgICAgICAgIG9ua2V5ZG93bixcbiAgICAgICAgICAgIG9uY2xpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KVxuICAgICAgICB9LCBcIlx1MDBEN1wiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgZGlhZ25vc3RpY3MsIHNlbGVjdGVkIH0gPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IGkgPSAwLCBuZWVkc1N5bmMgPSBmYWxzZSwgbmV3U2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgZGlhZ25vc3RpY3MuYmV0d2VlbigwLCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKF9zdGFydCwgX2VuZCwgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xLCBpdGVtO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLml0ZW1zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLmRpYWdub3N0aWMgPT0gc3BlYy5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgUGFuZWxJdGVtKHRoaXMudmlldywgc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbZm91bmRdO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgZm91bmQgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgaXRlbS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmICEodGhpcy5pdGVtcy5sZW5ndGggPT0gMSAmJiB0aGlzLml0ZW1zWzBdLmRpYWdub3N0aWMuZnJvbSA8IDApKSB7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCB7XG4gICAgICAgICAgICAgICAgZnJvbTogLTEsIHRvOiAtMSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIk5vIGRpYWdub3N0aWNzXCIpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgbmV3U2VsZWN0ZWRJdGVtLmlkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHJlYWQ6ICgpID0+ICh7IHNlbDogbmV3U2VsZWN0ZWRJdGVtLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcGFuZWw6IHRoaXMubGlzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KSxcbiAgICAgICAgICAgICAgICB3cml0ZTogKHsgc2VsLCBwYW5lbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwudG9wIDwgcGFuZWwudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCAtPSBwYW5lbC50b3AgLSBzZWwudG9wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWwuYm90dG9tID4gcGFuZWwuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSBzZWwuYm90dG9tIC0gcGFuZWwuYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzU3luYylcbiAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBsZXQgZG9tUG9zID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZ1bmN0aW9uIHJtKCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBkb21Qb3M7XG4gICAgICAgICAgICBkb21Qb3MgPSBwcmV2Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcHJldi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbS5wYXJlbnROb2RlID09IHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb21Qb3MgIT0gaXRlbS5kb20pXG4gICAgICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICAgICAgZG9tUG9zID0gaXRlbS5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0uZG9tLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkb21Qb3MpXG4gICAgICAgICAgICBybSgpO1xuICAgIH1cbiAgICBtb3ZlU2VsZWN0aW9uKHNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZmluZERpYWdub3N0aWMoZmllbGQuZGlhZ25vc3RpY3MsIHRoaXMuaXRlbXNbc2VsZWN0ZWRJbmRleF0uZGlhZ25vc3RpYyk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogc2VsZWN0aW9uLmZyb20sIGhlYWQ6IHNlbGVjdGlvbi50byB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBlZmZlY3RzOiBtb3ZlUGFuZWxTZWxlY3Rpb24ub2Yoc2VsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG9wZW4odmlldykgeyByZXR1cm4gbmV3IExpbnRQYW5lbCh2aWV3KTsgfVxufVxuZnVuY3Rpb24gc3ZnKGNvbnRlbnQsIGF0dHJzID0gYHZpZXdCb3g9XCIwIDAgNDAgNDBcImApIHtcbiAgICByZXR1cm4gYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICR7YXR0cnN9PiR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpfTwvc3ZnPicpYDtcbn1cbmZ1bmN0aW9uIHVuZGVybGluZShjb2xvcikge1xuICAgIHJldHVybiBzdmcoYDxwYXRoIGQ9XCJtMCAyLjUgbDIgLTEuNSBsMSAwIGwyIDEuNSBsMSAwXCIgc3Ryb2tlPVwiJHtjb2xvcn1cIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIi43XCIvPmAsIGB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIzXCJgKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZGlhZ25vc3RpY1wiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDZweCAzcHggOHB4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTFweFwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1lcnJvclwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICNkMTFcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtd2FybmluZ1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkIG9yYW5nZVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1pbmZvXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgIzk5OVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY0FjdGlvblwiOiB7XG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM0NDRcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjNweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIjhweFwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljU291cmNlXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIG9wYWNpdHk6IC43XG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwibGVmdCBib3R0b21cIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJyZXBlYXQteFwiLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBcIjAuN3B4XCIsXG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtZXJyb3JcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjZDExXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLXdhcm5pbmdcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCJvcmFuZ2VcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtaW5mb1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiM5OTlcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtYWN0aXZlXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmRkOTk4MFwiIH0sXG4gICAgXCIuY20tdG9vbHRpcC1saW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFyZ2luOiAwXG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IFwiLTJweFwiLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjRweCBzb2xpZCAjZDExXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LXdhcm5pbmdcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCJvcmFuZ2VcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtaW5mb1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIiM5OTlcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbC5jbS1wYW5lbC1saW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIHVsXCI6IHtcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDBweFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiJiBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCIsXG4gICAgICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmZvY3VzIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZF9mYWxsYmFjazogXCIjYmRmXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICAgIGNvbG9yX2ZhbGxiYWNrOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiSGlnaGxpZ2h0VGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjJweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNsYXNzIExpbnRHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IGRpYWdub3N0aWNzLnJlZHVjZSgobWF4LCBkKSA9PiB7XG4gICAgICAgICAgICBsZXQgcyA9IGQuc2V2ZXJpdHk7XG4gICAgICAgICAgICByZXR1cm4gcyA9PSBcImVycm9yXCIgfHwgcyA9PSBcIndhcm5pbmdcIiAmJiBtYXggPT0gXCJpbmZvXCIgPyBzIDogbWF4O1xuICAgICAgICB9LCBcImluZm9cIik7XG4gICAgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWxpbnQtbWFya2VyIGNtLWxpbnQtbWFya2VyLVwiICsgdGhpcy5zZXZlcml0eTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gdGhpcy5kaWFnbm9zdGljcztcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3NGaWx0ZXIpXG4gICAgICAgICAgICBkaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzRmlsdGVyKGRpYWdub3N0aWNzKTtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIGVsdC5vbm1vdXNlb3ZlciA9ICgpID0+IGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBlbHQsIGRpYWdub3N0aWNzKTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFja0hvdmVyT24odmlldywgbWFya2VyKSB7XG4gICAgbGV0IG1vdXNlbW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgcmVjdCA9IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggPiByZWN0LmxlZnQgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WCA8IHJlY3QucmlnaHQgKyAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiZcbiAgICAgICAgICAgIGV2ZW50LmNsaWVudFkgPiByZWN0LnRvcCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRZIDwgcmVjdC5ib3R0b20gKyAxMCAvKiBIb3Zlci5NYXJnaW4gKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDsgdGFyZ2V0OyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwLWxpbnRcIikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSk7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJUb29sdGlwKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRMaW50R3V0dGVyVG9vbHRpcC5vZihudWxsKSB9KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSk7XG59XG5mdW5jdGlvbiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgbWFya2VyLCBkaWFnbm9zdGljcykge1xuICAgIGZ1bmN0aW9uIGhvdmVyZWQoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5lbGVtZW50QXRIZWlnaHQobWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIDUgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgY29uc3QgbGluZVBvcyA9IHZpZXcuY29vcmRzQXRQb3MobGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGxpbmVQb3MpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRMaW50R3V0dGVyVG9vbHRpcC5vZih7XG4gICAgICAgICAgICAgICAgICAgIHBvczogbGluZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBhYm92ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvb3JkczogKCkgPT4gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB0cmFja0hvdmVyT24odmlldywgbWFya2VyKTtcbiAgICB9XG4gICAgbGV0IHsgaG92ZXJUaW1lIH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpO1xuICAgIGxldCBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgbWFya2VyLm9ubW91c2VvdXQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfTtcbiAgICBtYXJrZXIub25tb3VzZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlcnNGb3JEaWFnbm9zdGljcyhkb2MsIGRpYWdub3N0aWNzKSB7XG4gICAgbGV0IGJ5TGluZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgZGlhZ25vc3RpYyBvZiBkaWFnbm9zdGljcykge1xuICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQoZGlhZ25vc3RpYy5mcm9tKTtcbiAgICAgICAgKGJ5TGluZVtsaW5lLmZyb21dIHx8IChieUxpbmVbbGluZS5mcm9tXSA9IFtdKSkucHVzaChkaWFnbm9zdGljKTtcbiAgICB9XG4gICAgbGV0IG1hcmtlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIGluIGJ5TGluZSkge1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IExpbnRHdXR0ZXJNYXJrZXIoYnlMaW5lW2xpbmVdKS5yYW5nZSgrbGluZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya2VycywgdHJ1ZSk7XG59XG5jb25zdCBsaW50R3V0dGVyRXh0ZW5zaW9uID0gLypAX19QVVJFX18qL2d1dHRlcih7XG4gICAgY2xhc3M6IFwiY20tZ3V0dGVyLWxpbnRcIixcbiAgICBtYXJrZXJzOiB2aWV3ID0+IHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlck1hcmtlcnMpLFxufSk7XG5jb25zdCBsaW50R3V0dGVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUobWFya2VycywgdHIpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHRyLnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIoZGlhZ25vc3RpY3MgfHwgW10pO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzRm9yRGlhZ25vc3RpY3ModHIuc3RhdGUuZG9jLCBkaWFnbm9zdGljcy5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxufSk7XG5jb25zdCBzZXRMaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRHdXR0ZXJUb29sdGlwID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh0b29sdGlwLCB0cikge1xuICAgICAgICBpZiAodG9vbHRpcCAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdG9vbHRpcCA9IGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSA/IG51bGwgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvb2x0aXApLCB7IHBvczogdHIuY2hhbmdlcy5tYXBQb3ModG9vbHRpcC5wb3MpIH0pO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHQsIGUpID0+IGUuaXMoc2V0TGludEd1dHRlclRvb2x0aXApID8gZS52YWx1ZSA6IHQsIHRvb2x0aXApO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZmllbGQgPT4gc2hvd1Rvb2x0aXAuZnJvbShmaWVsZClcbn0pO1xuY29uc3QgbGludEd1dHRlclRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1ndXR0ZXItbGludFwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjEuNGVtXCIsXG4gICAgICAgIFwiJiAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiBcIi4yZW1cIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlclwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjFlbVwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWluZm9cIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2FhZlwiIHN0cm9rZT1cIiM3N2VcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTUgNUwzNSA1TDM1IDM1TDUgMzVaXCIvPmApXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci13YXJuaW5nXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNmZThcIiBzdHJva2U9XCIjZmQ3XCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMCA2TDM3IDM1TDMgMzVaXCIvPmApLFxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItZXJyb3JcIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjIwXCIgcj1cIjE1XCIgZmlsbD1cIiNmODdcIiBzdHJva2U9XCIjZjQzXCIgc3Ryb2tlLXdpZHRoPVwiNlwiLz5gKVxuICAgIH0sXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgaG92ZXJUaW1lOiAzMDAgLyogSG92ZXIuVGltZSAqLyxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgYSBndXR0ZXIgc2hvd2luZyBtYXJrZXJzIGZvclxuZWFjaCBsaW5lIHRoYXQgaGFzIGRpYWdub3N0aWNzLCB3aGljaCBjYW4gYmUgaG92ZXJlZCBvdmVyIHRvIHNlZVxudGhlIGRpYWdub3N0aWNzLlxuKi9cbmZ1bmN0aW9uIGxpbnRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2xpbnRHdXR0ZXJDb25maWcub2YoY29uZmlnKSwgbGludEd1dHRlck1hcmtlcnMsIGxpbnRHdXR0ZXJFeHRlbnNpb24sIGxpbnRHdXR0ZXJUaGVtZSwgbGludEd1dHRlclRvb2x0aXBdO1xufVxuLyoqXG5JdGVyYXRlIG92ZXIgdGhlIG1hcmtlZCBkaWFnbm9zdGljcyBmb3IgdGhlIGdpdmVuIGVkaXRvciBzdGF0ZSxcbmNhbGxpbmcgYGZgIGZvciBlYWNoIG9mIHRoZW0uIE5vdGUgdGhhdCwgaWYgdGhlIGRvY3VtZW50IGNoYW5nZWRcbnNpbmNlIHRoZSBkaWFnbm9zdGljcyB3ZXJlY3JlYXRlZCwgdGhlIGBEaWFnbm9zdGljYCBvYmplY3Qgd2lsbFxuaG9sZCB0aGUgb3JpZ2luYWwgb3V0ZGF0ZWQgcG9zaXRpb24sIHdoZXJlYXMgdGhlIGB0b2AgYW5kIGBmcm9tYFxuYXJndW1lbnRzIGhvbGQgdGhlIGRpYWdub3N0aWMncyBjdXJyZW50IHBvc2l0aW9uLlxuKi9cbmZ1bmN0aW9uIGZvckVhY2hEaWFnbm9zdGljKHN0YXRlLCBmKSB7XG4gICAgbGV0IGxTdGF0ZSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChsU3RhdGUgJiYgbFN0YXRlLmRpYWdub3N0aWNzLnNpemUpXG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSBSYW5nZVNldC5pdGVyKFtsU3RhdGUuZGlhZ25vc3RpY3NdKTsgaXRlci52YWx1ZTsgaXRlci5uZXh0KCkpXG4gICAgICAgICAgICBmKGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljLCBpdGVyLmZyb20sIGl0ZXIudG8pO1xufVxuXG5leHBvcnQgeyBjbG9zZUxpbnRQYW5lbCwgZGlhZ25vc3RpY0NvdW50LCBmb3JFYWNoRGlhZ25vc3RpYywgZm9yY2VMaW50aW5nLCBsaW50R3V0dGVyLCBsaW50S2V5bWFwLCBsaW50ZXIsIG5leHREaWFnbm9zdGljLCBvcGVuTGludFBhbmVsLCBzZXREaWFnbm9zdGljcywgc2V0RGlhZ25vc3RpY3NFZmZlY3QgfTtcbiIsICJpbXBvcnQgeyBsaW5lTnVtYmVycywgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgY3Jvc3NoYWlyQ3Vyc29yLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmV4cG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgZm9sZEd1dHRlciwgaW5kZW50T25JbnB1dCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGJyYWNrZXRNYXRjaGluZywgZm9sZEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IGhpc3RvcnksIGRlZmF1bHRLZXltYXAsIGhpc3RvcnlLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5pbXBvcnQgeyBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBzZWFyY2hLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9zZWFyY2gnO1xuaW1wb3J0IHsgY2xvc2VCcmFja2V0cywgYXV0b2NvbXBsZXRpb24sIGNsb3NlQnJhY2tldHNLZXltYXAsIGNvbXBsZXRpb25LZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnO1xuaW1wb3J0IHsgbGludEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xpbnQnO1xuXG4vLyAoVGhlIHN1cGVyZmx1b3VzIGZ1bmN0aW9uIGNhbGxzIGFyb3VuZCB0aGUgbGlzdCBvZiBleHRlbnNpb25zIHdvcmtcbi8vIGFyb3VuZCBjdXJyZW50IGxpbWl0YXRpb25zIGluIHRyZWUtc2hha2luZyBzb2Z0d2FyZS4pXG4vKipcblRoaXMgaXMgYW4gZXh0ZW5zaW9uIHZhbHVlIHRoYXQganVzdCBwdWxscyB0b2dldGhlciBhIG51bWJlciBvZlxuZXh0ZW5zaW9ucyB0aGF0IHlvdSBtaWdodCB3YW50IGluIGEgYmFzaWMgZWRpdG9yLiBJdCBpcyBtZWFudCBhcyBhXG5jb252ZW5pZW50IGhlbHBlciB0byBxdWlja2x5IHNldCB1cCBDb2RlTWlycm9yIHdpdGhvdXQgaW5zdGFsbGluZ1xuYW5kIGltcG9ydGluZyBhIGxvdCBvZiBzZXBhcmF0ZSBwYWNrYWdlcy5cblxuU3BlY2lmaWNhbGx5LCBpdCBpbmNsdWRlcy4uLlxuXG4gLSBbdGhlIGRlZmF1bHQgY29tbWFuZCBiaW5kaW5nc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWZhdWx0S2V5bWFwKVxuIC0gW2xpbmUgbnVtYmVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxpbmVOdW1iZXJzKVxuIC0gW3NwZWNpYWwgY2hhcmFjdGVyIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodFNwZWNpYWxDaGFycylcbiAtIFt0aGUgdW5kbyBoaXN0b3J5XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmhpc3RvcnkpXG4gLSBbYSBmb2xkIGd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKVxuIC0gW2N1c3RvbSBzZWxlY3Rpb24gZHJhd2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pXG4gLSBbZHJvcCBjdXJzb3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcm9wQ3Vyc29yKVxuIC0gW211bHRpcGxlIHNlbGVjdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG4gLSBbcmVpbmRlbnRhdGlvbiBvbiBpbnB1dF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRPbklucHV0KVxuIC0gW3RoZSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUpIChhcyBmYWxsYmFjaylcbiAtIFticmFja2V0IG1hdGNoaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmJyYWNrZXRNYXRjaGluZylcbiAtIFticmFja2V0IGNsb3NpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpXG4gLSBbYXV0b2NvbXBsZXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uKVxuIC0gW3JlY3Rhbmd1bGFyIHNlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKSBhbmQgW2Nyb3NzaGFpciBjdXJzb3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5jcm9zc2hhaXJDdXJzb3IpXG4gLSBbYWN0aXZlIGxpbmUgaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSlcbiAtIFthY3RpdmUgbGluZSBndXR0ZXIgaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcilcbiAtIFtzZWxlY3Rpb24gbWF0Y2ggaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5oaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKVxuIC0gW3NlYXJjaF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guc2VhcmNoS2V5bWFwKVxuIC0gW2xpbnRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50S2V5bWFwKVxuXG4oWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gYWRkIHNvbWUgbGFuZ3VhZ2UgcGFja2FnZSB0byB5b3VyIHNldHVwXG50b28uKVxuXG5UaGlzIGV4dGVuc2lvbiBkb2VzIG5vdCBhbGxvdyBjdXN0b21pemF0aW9uLiBUaGUgaWRlYSBpcyB0aGF0LFxub25jZSB5b3UgZGVjaWRlIHlvdSB3YW50IHRvIGNvbmZpZ3VyZSB5b3VyIGVkaXRvciBtb3JlIHByZWNpc2VseSxcbnlvdSB0YWtlIHRoaXMgcGFja2FnZSdzIHNvdXJjZSAod2hpY2ggaXMganVzdCBhIGJ1bmNoIG9mIGltcG9ydHNcbmFuZCBhbiBhcnJheSBsaXRlcmFsKSwgY29weSBpdCBpbnRvIHlvdXIgb3duIGNvZGUsIGFuZCBhZGp1c3QgaXRcbmFzIGRlc2lyZWQuXG4qL1xuY29uc3QgYmFzaWNTZXR1cCA9IC8qQF9fUFVSRV9fKi8oKCkgPT4gW1xuICAgIGxpbmVOdW1iZXJzKCksXG4gICAgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpLFxuICAgIGhpZ2hsaWdodFNwZWNpYWxDaGFycygpLFxuICAgIGhpc3RvcnkoKSxcbiAgICBmb2xkR3V0dGVyKCksXG4gICAgZHJhd1NlbGVjdGlvbigpLFxuICAgIGRyb3BDdXJzb3IoKSxcbiAgICBFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucy5vZih0cnVlKSxcbiAgICBpbmRlbnRPbklucHV0KCksXG4gICAgc3ludGF4SGlnaGxpZ2h0aW5nKGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgeyBmYWxsYmFjazogdHJ1ZSB9KSxcbiAgICBicmFja2V0TWF0Y2hpbmcoKSxcbiAgICBjbG9zZUJyYWNrZXRzKCksXG4gICAgYXV0b2NvbXBsZXRpb24oKSxcbiAgICByZWN0YW5ndWxhclNlbGVjdGlvbigpLFxuICAgIGNyb3NzaGFpckN1cnNvcigpLFxuICAgIGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSxcbiAgICBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKCksXG4gICAga2V5bWFwLm9mKFtcbiAgICAgICAgLi4uY2xvc2VCcmFja2V0c0tleW1hcCxcbiAgICAgICAgLi4uZGVmYXVsdEtleW1hcCxcbiAgICAgICAgLi4uc2VhcmNoS2V5bWFwLFxuICAgICAgICAuLi5oaXN0b3J5S2V5bWFwLFxuICAgICAgICAuLi5mb2xkS2V5bWFwLFxuICAgICAgICAuLi5jb21wbGV0aW9uS2V5bWFwLFxuICAgICAgICAuLi5saW50S2V5bWFwXG4gICAgXSlcbl0pKCk7XG4vKipcbkEgbWluaW1hbCBzZXQgb2YgZXh0ZW5zaW9ucyB0byBjcmVhdGUgYSBmdW5jdGlvbmFsIGVkaXRvci4gT25seVxuaW5jbHVkZXMgW3RoZSBkZWZhdWx0IGtleW1hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWZhdWx0S2V5bWFwKSwgW3VuZG9cbmhpc3RvcnldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaGlzdG9yeSksIFtzcGVjaWFsIGNoYXJhY3RlclxuaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKSwgW2N1c3RvbSBzZWxlY3Rpb25cbmRyYXdpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSwgYW5kIFtkZWZhdWx0IGhpZ2hsaWdodFxuc3R5bGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKS5cbiovXG5jb25zdCBtaW5pbWFsU2V0dXAgPSAvKkBfX1BVUkVfXyovKCgpID0+IFtcbiAgICBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoKSxcbiAgICBoaXN0b3J5KCksXG4gICAgZHJhd1NlbGVjdGlvbigpLFxuICAgIHN5bnRheEhpZ2hsaWdodGluZyhkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHsgZmFsbGJhY2s6IHRydWUgfSksXG4gICAga2V5bWFwLm9mKFtcbiAgICAgICAgLi4uZGVmYXVsdEtleW1hcCxcbiAgICAgICAgLi4uaGlzdG9yeUtleW1hcCxcbiAgICBdKVxuXSkoKTtcblxuZXhwb3J0IHsgYmFzaWNTZXR1cCwgbWluaW1hbFNldHVwIH07XG4iLCAiaW1wb3J0IHsgUGFyc2VyLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIFRyZWUsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8vLyBBIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbi8vLyBwYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbi8vLyB0aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuLy8vIGFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbmNsYXNzIFN0YWNrIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICBwLCBcbiAgICAvLy8gSG9sZHMgc3RhdGUsIGlucHV0IHBvcywgYnVmZmVyIGluZGV4IHRyaXBsZXRzIGZvciBhbGwgYnV0IHRoZVxuICAgIC8vLyB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgc3RhY2ssIFxuICAgIC8vLyBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlUG9zLCBcbiAgICAvLy8gVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICBwb3MsIFxuICAgIC8vLyBUaGUgZHluYW1pYyBzY29yZSBvZiB0aGUgc3RhY2ssIGluY2x1ZGluZyBkeW5hbWljIHByZWNlZGVuY2VcbiAgICAvLy8gYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzY29yZSwgXG4gICAgLy8gVGhlIG91dHB1dCBidWZmZXIuIEhvbGRzICh0eXBlLCBzdGFydCwgZW5kLCBzaXplKSBxdWFkc1xuICAgIC8vIHJlcHJlc2VudGluZyBub2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIsIHdoZXJlIGBzaXplYCBpc1xuICAgIC8vIGFtb3VudCBvZiBidWZmZXIgYXJyYXkgZW50cmllcyBjb3ZlcmVkIGJ5IHRoaXMgbm9kZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjdXJDb250ZXh0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gICAgLy8vIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICAvLy8gcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgLy8vIHRyYWNrZXIuXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2VcdTIwMTR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhY2tbYmFzZSAtIDJdO1xuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IHRoaXMuc3RhY2tbYmFzZSAtIDFdLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBSZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTa2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIGlzUmVkdWNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBFcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWR1Y2UgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBHb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICAgICAgaWYgKG5leHRFbmQgPiB0aGlzLnBvcyB8fCBuZXh0IDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQobmV4dCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFNoaWZ0LWFuZC1zdGF5LCB3aGljaCBtZWFucyB0aGlzIGlzIGEgc2tpcHBlZCB0b2tlblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQobmV4dCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDE5MCAvKiBEZWxldGUgKi87XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICAvLy8gYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgLy8vIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgLy8vIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBNYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBNYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSBkZXB0aCAqIDM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICAgIC8vLyB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgLy8vIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICBnZXQgZGVhZEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBFbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8vLyBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgLy8vIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIC8vLyBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLnAucGFyc2VyOyB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICAvLy8gdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLnAucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxuICAgIHNoaWZ0Q29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICByZWR1Y2VDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtMyk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNldExvb2tBaGVhZChsb29rQWhlYWQpIHtcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IHRoaXMubG9va0FoZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2tBaGVhZCA+IDApXG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICB9XG59XG5jbGFzcyBTdGFja0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHJhY2tlci5zdHJpY3QgPyB0cmFja2VyLmhhc2goY29udGV4dCkgOiAwO1xuICAgIH1cbn1cbnZhciBSZWNvdmVyO1xuKGZ1bmN0aW9uIChSZWNvdmVyKSB7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiSW5zZXJ0XCJdID0gMjAwXSA9IFwiSW5zZXJ0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGVsZXRlXCJdID0gMTkwXSA9IFwiRGVsZXRlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiUmVkdWNlXCJdID0gMTAwXSA9IFwiUmVkdWNlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4TmV4dFwiXSA9IDRdID0gXCJNYXhOZXh0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDMwMF0gPSBcIk1heEluc2VydFN0YWNrRGVwdGhcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCJdID0gMTIwXSA9IFwiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiO1xufSkoUmVjb3ZlciB8fCAoUmVjb3ZlciA9IHt9KSk7XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhcnQuc3RhY2s7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVkVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IDA7XG4gICAgICAgIHRoaXMubWFzayA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IDA7XG4gICAgfVxufVxuY29uc3QgbnVsbFRva2VuID0gbmV3IENhY2hlZFRva2VuO1xuLy8vIFtUb2tlbml6ZXJzXSgjbHIuRXh0ZXJuYWxUb2tlbml6ZXIpIGludGVyYWN0IHdpdGggdGhlIGlucHV0XG4vLy8gdGhyb3VnaCB0aGlzIGludGVyZmFjZS4gSXQgcHJlc2VudHMgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mXG4vLy8gY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2Zcbi8vLyBbcmFuZ2VzXSgjY29tbW9uLlBhcnNlci5wYXJzZV5yYW5nZXMpIGZyb20gdG9rZW5pemVyIGNvZGUuXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBpbnB1dCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvLy8gQmFja3VwIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvLy8gVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIC8vLyB3aGVuIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLmVuZCA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsaXBQb3MocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5yYW5nZS5mcm9tICYmIHBvcyA8IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIGlmIChyYW5nZS50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocG9zLCByYW5nZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kO1xuICAgIH1cbiAgICAvLy8gTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgLy8vIGAubmV4dGAsIGAucGVlaygtMSlgIGdpdmVzIHlvdSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLCBhbmQgc29cbiAgICAvLy8gb24uXG4gICAgLy8vXG4gICAgLy8vIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIC8vLyBvbiBwb3RlbnRpYWxseSBmYXItYXdheSBjb250ZW50LCB3aGljaCBtYXkgcmVkdWNlIHRoZVxuICAgIC8vLyBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmdcdTIwMTR3aGVuIGxvb2tpbmcgZm9yd2FyZFx1MjAxNG9yIGV2ZW5cbiAgICAvLy8gY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICAvLy8gdW5pdHMsIHNpbmNlIHRoZSBsaWJyYXJ5IGRvZXMgbm90IHRyYWNrIGxvb2tiZWhpbmQuXG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuY2h1bmtPZmYgKyBvZmZzZXQsIHBvcywgcmVzdWx0O1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHBvcyA9IHJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiBwb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQocG9zIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJhbmdlSW5kZXgsIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFuZ2UudG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2VzWysraV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMuY2h1bmsyUG9zID0gcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgdGhpcy5jaHVuazIubGVuZ3RoID4gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgcmFuZ2UudG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgLy8vIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uLCBidXQgeW91IGNhbiBwYXNzIGFuIG9mZnNldCAocmVsYXRpdmUgdG9cbiAgICAvLy8gdGhlIHN0cmVhbSBwb3NpdGlvbikgdG8gY2hhbmdlIHRoYXQuXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgc3RyZWFtIGZvcndhcmQgTiAoZGVmYXVsdHMgdG8gMSkgY29kZSB1bml0cy4gUmV0dXJuc1xuICAgIC8vLyB0aGUgbmV3IHZhbHVlIG9mIFtgbmV4dGBdKCNsci5JbnB1dFN0cmVhbS5uZXh0KS5cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZXNldChwb3MsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4uc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB0b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5leHRlbmRlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgIT0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLnJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWy0tdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPj0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rUG9zICYmIHBvcyA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSBwb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmtQb3MgJiYgdG8gPD0gdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmtQb3MsIHRvIC0gdGhpcy5jaHVua1Bvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmsyUG9zICYmIHRvIDw9IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsyLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rMlBvcywgdG8gLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMucmFuZ2UuZnJvbSAmJiB0byA8PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQucmVhZChmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmlucHV0LnJlYWQoTWF0aC5tYXgoci5mcm9tLCBmcm9tKSwgTWF0aC5taW4oci50bywgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vLyBAaW50ZXJuYWxcbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7IHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCk7IH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIGBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbi8vLyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtLCBzY2FucyBmb3IgdGhlIHR5cGVzIG9mIHRva2VucyBpdFxuICAgIC8vLyByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgLy8vIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICAvLy8gb25lLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgaW5wdXQudG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCBzdGFjaywgZ3JvdXApIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkaWFsZWN0IH0gPSBwYXJzZXI7XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0LnRva2VuLnZhbHVlID09IC0xIHx8IGlucHV0LnRva2VuLnZhbHVlID09IHRlcm0gfHwgcGFyc2VyLm92ZXJyaWRlcyh0ZXJtLCBpbnB1dC50b2tlbi52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQubmV4dCwgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBFT0ZcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIGhpZ2ggPiBsb3cgJiYgZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDNdID09IDY1NTM1IC8qIEVuZCAqLyAmJiBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gM10gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBHYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBTdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBCYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBCYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbnZhciBTYWZldHk7XG4oZnVuY3Rpb24gKFNhZmV0eSkge1xuICAgIFNhZmV0eVtTYWZldHlbXCJNYXJnaW5cIl0gPSAyNV0gPSBcIk1hcmdpblwiO1xufSkoU2FmZXR5IHx8IChTYWZldHkgPSB7fSkpO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpO1xuICAgIGN1cnNvci5tb3ZlVG8ocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDwgcG9zIDogY3Vyc29yLmZyb20gPiBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihjdXJzb3IudG8gLSAxLCBwb3MgLSAyNSAvKiBNYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBNYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIG5vZGVTZXQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rQWhlYWQgfHwgZW5kICsgbG9va0FoZWFkIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gTWF0aC5tYXgodGhpcy5zYWZlRnJvbSwgcG9zKSkgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2spIHtcbiAgICAgICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1haW4gPSBudWxsO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IE1hdGgubWF4KHRva2VuLmxvb2tBaGVhZCwgbG9va0FoZWFkKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIEVyciAqLztcbiAgICAgICAgcmV0dXJuIG1haW47XG4gICAgfVxuICAgIHVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YXJ0LCB0b2tlbiksIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0odGhpcy5zdHJlYW0ucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2sucC5wYXJzZXIuZGlhbGVjdC5hbGxvd3MocmVzdWx0ID4+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCAmIDEpID09IDAgLyogU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDIpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG52YXIgUmVjO1xuKGZ1bmN0aW9uIChSZWMpIHtcbiAgICBSZWNbUmVjW1wiRGlzdGFuY2VcIl0gPSA1XSA9IFwiRGlzdGFuY2VcIjtcbiAgICBSZWNbUmVjW1wiTWF4UmVtYWluaW5nUGVyU3RlcFwiXSA9IDNdID0gXCJNYXhSZW1haW5pbmdQZXJTdGVwXCI7XG4gICAgLy8gV2hlbiB0d28gc3RhY2tzIGhhdmUgYmVlbiBydW5uaW5nIGluZGVwZW5kZW50bHkgbG9uZyBlbm91Z2ggdG9cbiAgICAvLyBhZGQgdGhpcyBtYW55IGVsZW1lbnRzIHRvIHRoZWlyIGJ1ZmZlcnMsIHBydW5lIG9uZS5cbiAgICBSZWNbUmVjW1wiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIl0gPSA1MDBdID0gXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiO1xuICAgIFJlY1tSZWNbXCJGb3JjZVJlZHVjZUxpbWl0XCJdID0gMTBdID0gXCJGb3JjZVJlZHVjZUxpbWl0XCI7XG4gICAgLy8gT25jZSBhIHN0YWNrIHJlYWNoZXMgdGhpcyBkZXB0aCAoaW4gLnN0YWNrLmxlbmd0aCkgZm9yY2UtcmVkdWNlXG4gICAgLy8gaXQgYmFjayB0byBDdXRUbyB0byBhdm9pZCBjcmVhdGluZyB0cmVlcyB0aGF0IG92ZXJmbG93IHRoZSBzdGFja1xuICAgIC8vIG9uIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgUmVjW1JlY1tcIkN1dERlcHRoXCJdID0gMTUwMDBdID0gXCJDdXREZXB0aFwiO1xuICAgIFJlY1tSZWNbXCJDdXRUb1wiXSA9IDkwMDBdID0gXCJDdXRUb1wiO1xufSkoUmVjIHx8IChSZWMgPSB7fSkpO1xuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyBcdTI2NTQsIFx1MjY1NSwgXHUyNjU2LCBcdTI2NTcsIFx1MjY1OCwgXHUyNjU5LCBcdTI2NjAsIFx1MjY2MSwgXHUyNjYyLCBcdTI2NjMsIFx1MjY2NCwgXHUyNjY1LCBcdTI2NjYsIFx1MjY2N1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShpbnB1dCwgcmFuZ2VzKTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy50b3BUZXJtID0gcGFyc2VyLnRvcFsxXTtcbiAgICAgICAgbGV0IHsgZnJvbSB9ID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCBmcm9tKV07XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aCAmJiB0aGlzLnN0cmVhbS5lbmQgLSBmcm9tID4gcGFyc2VyLmJ1ZmZlckxlbmd0aCAqIDRcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgcGFyc2VyLm5vZGVTZXQpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluU3RhY2tQb3M7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMubWluU3RhY2tQb3M7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBob2xkIHN0YWNrcyBiZXlvbmQgYHBvc2AuXG4gICAgICAgIGxldCBuZXdTdGFja3MgPSB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICBsZXQgc3RvcHBlZCwgc3RvcHBlZFRva2VucztcbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIERpc3RhbmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgc3RvcHBlZCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gdGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdG9wcGVkWzBdLnBvcyA+IHRoaXMuc3RvcHBlZEF0ID8gc3RvcHBlZFswXVxuICAgICAgICAgICAgICAgIDogdGhpcy5ydW5SZWNvdmVyeShzdG9wcGVkLCBzdG9wcGVkVG9rZW5zLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIE1heFJlbWFpbmluZ1BlclN0ZXAgKi87XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3Muc29tZShzID0+IHMucmVkdWNlUG9zID4gcG9zKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmctLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gUHJ1bmUgc3RhY2tzIHRoYXQgYXJlIGluIHRoZSBzYW1lIHN0YXRlLCBvciB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gcnVubmluZyB3aXRob3V0IHNwbGl0dGluZyBmb3IgYSB3aGlsZSwgdG8gYXZvaWQgZ2V0dGluZyBzdHVja1xuICAgICAgICAgICAgLy8gd2l0aCBtdWx0aXBsZSBzdWNjZXNzZnVsIHN0YWNrcyBydW5uaW5nIGVuZGxlc3NseSBvbi5cbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXdTdGFja3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbmV3U3RhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLnNhbWVTdGF0ZShvdGhlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5taW5TdGFja1BvcylcbiAgICAgICAgICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzW2ldLnBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5zdG9wcGVkQXQgPCBwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IG1vdmUgc3RvcHBlZEF0IGZvcndhcmRcIik7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmZvcmNlUmVkdWNlKCkgPyBzdGFjayA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgbGV0IHN0cmljdEN4ID0gc3RhY2suY3VyQ29udGV4dCAmJiBzdGFjay5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0LCBjeEhhc2ggPSBzdHJpY3RDeCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCAmJiAoIXN0cmljdEN4IHx8IChjYWNoZWQucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgfHwgMCkgPT0gY3hIYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIFRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIFRyZWUgJiYgY2FjaGVkLnBvc2l0aW9uc1swXSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0UmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLnN0YWNrLmxlbmd0aCA+PSAxNTAwMCAvKiBDdXREZXB0aCAqLykge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLnN0YWNrLmxlbmd0aCA+IDkwMDAgLyogQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIEZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBUcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RhY2sucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuY29uc3QgaWQgPSB4ID0+IHg7XG4vLy8gQ29udGV4dCB0cmFja2VycyBhcmUgdXNlZCB0byB0cmFjayBzdGF0ZWZ1bCBjb250ZXh0IChzdWNoIGFzXG4vLy8gaW5kZW50YXRpb24gaW4gdGhlIFB5dGhvbiBncmFtbWFyLCBvciBwYXJlbnQgZWxlbWVudHMgaW4gdGhlIFhNTFxuLy8vIGdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbi8vLyBncmFtbWFyIGZpbGUgYXMgYEBjb250ZXh0IGV4cG9ydE5hbWUgZnJvbSBcIm1vZHVsZVwiYC5cbi8vL1xuLy8vIENvbnRleHQgdmFsdWVzIHNob3VsZCBiZSBpbW11dGFibGUsIGFuZCBjYW4gYmUgdXBkYXRlZCAocmVwbGFjZWQpXG4vLy8gb24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG4vLy9cbi8vLyBUaGUgZXhwb3J0IHVzZWQgaW4gYSBgQGNvbnRleHRgIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBvZiB0aGlzXG4vLy8gdHlwZS5cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvLy8gRGVmaW5lIGEgY29udGV4dCB0cmFja2VyLlxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLy8vIEhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkIGJ5XG4vLy8gYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG4vLy8gY29udGVudCB3aXRoLlxuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy52ZXJzaW9uICE9IDE0IC8qIFZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTQgLyogVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJTcGVjcyA9IHNwZWMuc3BlY2lhbGl6ZWQgfHwgW107XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1tpXS50ZXJtO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoZ2V0U3BlY2lhbGl6ZXIpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICAvLy8gYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBFbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8vIFVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvci4gTm90IGF2YWlsYWJsZSB0b1xuICAgIC8vLyB1c2VyIGNvZGUuXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIEVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbGl6ZXIoc3BlYykge1xuICAgIGlmIChzcGVjLmV4dGVybmFsKSB7XG4gICAgICAgIGxldCBtYXNrID0gc3BlYy5leHRlbmQgPyAxIC8qIEV4dGVuZCAqLyA6IDAgLyogU3BlY2lhbGl6ZSAqLztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgc3RhY2spID0+IChzcGVjLmV4dGVybmFsKHZhbHVlLCBzdGFjaykgPDwgMSkgfCBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYy5nZXQ7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBTdGFjayB9O1xuIiwgImltcG9ydCB7IExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG5jb25zdCBqc29uSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgXCJUcnVlIEZhbHNlXCI6IHRhZ3MuYm9vbCxcbiAgUHJvcGVydHlOYW1lOiB0YWdzLnByb3BlcnR5TmFtZSxcbiAgTnVsbDogdGFncy5udWxsLFxuICBcIixcIjogdGFncy5zZXBhcmF0b3IsXG4gIFwiWyBdXCI6IHRhZ3Muc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogdGFncy5icmFjZVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIiRiT1ZRUE9PT09RTycjQ2InI0NiT25RUE8nI0NlT3ZRUE8nI0NqT09RTycjQ3AnI0NwUU9RUE9PT09RTycjQ2cnI0NnT31RUE8nI0NmTyFTUVBPJyNDck9PUU8sNTlQLDU5UE8hW1FQTyw1OVBPIWFRUE8nI0N1T09RTyw1OVUsNTlVTyFpUVBPLDU5VU9WUVBPLDU5UU9xUVBPJyNDa08hblFQTyw1OV5PT1FPMUcuazFHLmtPVlFQTycjQ2xPIXZRUE8sNTlhT09RTzFHLnAxRy5wT09RTzFHLmwxRy5sT09RTyw1OVYsNTlWT09RTy1FNmktRTZpT09RTyw1OVcsNTlXT09RTy1FNmotRTZqXCIsXG4gIHN0YXRlRGF0YTogXCIjT35PY09Tfk9RU09SU09TU09UU09XUU9dUk9lUE9+T1ZYT2VVT35PW1tPflBWT2deT35PaF9PVmZYfk9WYU9+T2hiT1tpWH5PW2RPfk9oX09WZmF+T2hiT1tpYX5PXCIsXG4gIGdvdG86IFwiIWtqUFBQUFBQa1BQa3F3UFBreyFSUFBQIVhQIWVQUCFoWFNPUl5iUVdRUmZfVFZRX1FgV1JnYFFjWlJpY1FUT1FaUlFlXlJoYlJZUVJdUlwiLFxuICBub2RlTmFtZXM6IFwiXHUyNkEwIEpzb25UZXh0IFRydWUgRmFsc2UgTnVsbCBOdW1iZXIgU3RyaW5nIH0geyBPYmplY3QgUHJvcGVydHkgUHJvcGVydHlOYW1lIF0gWyBBcnJheVwiLFxuICBtYXhUZXJtOiAyNSxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wib3BlbmVkQnlcIiwgNyxcIntcIiwxMixcIltcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgOCxcIn1cIiwxMyxcIl1cIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc29uSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogMixcbiAgdG9rZW5EYXRhOiBcIihwflJhWFkhV1laIVddXiFXcHEhV3JzIV18fSRpfSFPJG4hUSFSJHchUiFbJlYhWyFdJmghfSNPJm0jUCNRJnIjWSNaJncjYiNjJ2YjaCNpJ30jbyNwKGYjcSNyKGt+IV1PY35+IWBVcHEhXXFyIV1ycyFycyNPIV0jTyNQIXcjUH4hXX4hd09lfn4helhycyFdIVAhUSFdI08jUCFdI1UjViFdI1kjWiFdI2IjYyFdI2YjZyFdI2gjaSFdI2kjaiNnfiNqUiFRIVsjcyFjIWkjcyNUI1ojc34jdlIhUSFbJFAhYyFpJFAjVCNaJFB+JFNSIVEhWyRdIWMhaSRdI1QjWiRdfiRgUiFRIVshXSFjIWkhXSNUI1ohXX4kbk9ofn4kcVEhUSFSJHchUiFbJlZ+JHxSVH4hTyFQJVYhZyFoJWsjWCNZJWt+JVlQIVEhWyVdfiViUlR+IVEhWyVdIWchaCVrI1gjWSVrfiVuUnt8JXd9IU8ldyFRIVslfX4lelAhUSFbJX1+JlNQVH4hUSFbJX1+JltTVH4hTyFQJVYhUSFbJlYhZyFoJWsjWCNZJWt+Jm1PZ35+JnJPXX5+JndPW35+JnpQI1QjVSZ9fidRUCNgI2EnVH4nV1AjZyNoJ1p+J15QI1gjWSdhfidmT1J+fidpUCNpI2onbH4nb1AjYCNhJ3J+J3VQI2AjYSd4fid9T1N+fihRUCNmI2coVH4oV1AjaSNqKFp+KF5QI1gjWShhfihmT1F+fihrT1d+fihwT1Z+XCIsXG4gIHRva2VuaXplcnM6IFswXSxcbiAgdG9wUnVsZXM6IHtcIkpzb25UZXh0XCI6WzAsMV19LFxuICB0b2tlblByZWM6IDBcbn0pO1xuXG5leHBvcnQgeyBwYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdAbGV6ZXIvanNvbic7XG5pbXBvcnQgeyBMUkxhbmd1YWdlLCBpbmRlbnROb2RlUHJvcCwgY29udGludWVkSW5kZW50LCBmb2xkTm9kZVByb3AsIGZvbGRJbnNpZGUsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuLyoqXG5DYWxsc1xuW2BKU09OLnBhcnNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZSlcbm9uIHRoZSBkb2N1bWVudCBhbmQsIGlmIHRoYXQgdGhyb3dzIGFuIGVycm9yLCByZXBvcnRzIGl0IGFzIGFcbnNpbmdsZSBkaWFnbm9zdGljLlxuKi9cbmNvbnN0IGpzb25QYXJzZUxpbnRlciA9ICgpID0+ICh2aWV3KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgSlNPTi5wYXJzZSh2aWV3LnN0YXRlLmRvYy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSlcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zaXRpb24oZSwgdmlldy5zdGF0ZS5kb2MpO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIHRvOiBwb3NcbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuZnVuY3Rpb24gZ2V0RXJyb3JQb3NpdGlvbihlcnJvciwgZG9jKSB7XG4gICAgbGV0IG07XG4gICAgaWYgKG0gPSBlcnJvci5tZXNzYWdlLm1hdGNoKC9hdCBwb3NpdGlvbiAoXFxkKykvKSlcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKCttWzFdLCBkb2MubGVuZ3RoKTtcbiAgICBpZiAobSA9IGVycm9yLm1lc3NhZ2UubWF0Y2goL2F0IGxpbmUgKFxcZCspIGNvbHVtbiAoXFxkKykvKSlcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGRvYy5saW5lKCttWzFdKS5mcm9tICsgKCttWzJdKSAtIDEsIGRvYy5sZW5ndGgpO1xuICAgIHJldHVybiAwO1xufVxuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgdGhhdCBwcm92aWRlcyBKU09OIHBhcnNpbmcuXG4qL1xuY29uc3QganNvbkxhbmd1YWdlID0gLypAX19QVVJFX18qL0xSTGFuZ3VhZ2UuZGVmaW5lKHtcbiAgICBuYW1lOiBcImpzb25cIixcbiAgICBwYXJzZXI6IC8qQF9fUFVSRV9fKi9wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9pbmRlbnROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIE9iamVjdDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqXFx9LyB9KSxcbiAgICAgICAgICAgICAgICBBcnJheTogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqXFxdLyB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgXCJPYmplY3QgQXJyYXlcIjogZm9sZEluc2lkZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjbG9zZUJyYWNrZXRzOiB7IGJyYWNrZXRzOiBbXCJbXCIsIFwie1wiLCAnXCInXSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccypbXFx9XFxdXSQvXG4gICAgfVxufSk7XG4vKipcbkpTT04gbGFuZ3VhZ2Ugc3VwcG9ydC5cbiovXG5mdW5jdGlvbiBqc29uKCkge1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGpzb25MYW5ndWFnZSk7XG59XG5cbmV4cG9ydCB7IGpzb24sIGpzb25MYW5ndWFnZSwganNvblBhcnNlTGludGVyIH07XG4iLCAiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSGlnaGxpZ2h0U3R5bGUsIHN5bnRheEhpZ2hsaWdodGluZyB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gQ29sb3JzIGZyb20gaHR0cHM6Ly93d3cubm9yZHRoZW1lLmNvbS9kb2NzL2NvbG9ycy1hbmQtcGFsZXR0ZXNcbi8vIFBvbGFyIE5pZ2h0XG5jb25zdCBiYXNlMDAgPSAnIzJlMzQ0MCcsIC8vIGJsYWNrXG5iYXNlMDEgPSAnIzNiNDI1MicsIC8vIGRhcmsgZ3JleVxuYmFzZTAyID0gJyM0MzRjNWUnLCBiYXNlMDMgPSAnIzRjNTY2YSc7IC8vIGdyZXlcbi8vIFNub3cgU3Rvcm1cbmNvbnN0IGJhc2UwNSA9ICcjZTVlOWYwJywgLy8gb2ZmIHdoaXRlXG5iYXNlMDYgPSAnI2VjZWZmNCc7IC8vIHdoaXRlXG4vLyBGcm9zdFxuY29uc3QgYmFzZTA3ID0gJyM4ZmJjYmInLCAvLyBtb3NzIGdyZWVuXG5iYXNlMDggPSAnIzg4YzBkMCcsIC8vIGljZSBibHVlXG5iYXNlMDkgPSAnIzgxYTFjMScsIC8vIHdhdGVyIGJsdWVcbmJhc2UwQSA9ICcjNWU4MWFjJzsgLy8gZGVlcCBibHVlXG4vLyBBdXJvcmFcbmNvbnN0IGJhc2UwYiA9ICcjYmY2MTZhJywgLy8gcmVkXG5iYXNlMEMgPSAnI2QwODc3MCcsIC8vIG9yYW5nZVxuYmFzZTBEID0gJyNlYmNiOGInLCAvLyB5ZWxsb3dcbmJhc2UwRSA9ICcjYTNiZThjJywgLy8gZ3JlZW5cbmJhc2UwRiA9ICcjYjQ4ZWFkJzsgLy8gcHVycGxlXG5jb25zdCBpbnZhbGlkID0gJyNkMzAxMDInLCBkYXJrQmFja2dyb3VuZCA9IGJhc2UwNiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IGRhcmtCYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kID0gJyNmZmZmZmYnLCB0b29sdGlwQmFja2dyb3VuZCA9IGJhc2UwMSwgc2VsZWN0aW9uID0gZGFya0JhY2tncm91bmQsIGN1cnNvciA9IGJhc2UwMTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIEJhc2ljIExpZ2h0LlxuKi9cbmNvbnN0IGJhc2ljTGlnaHRUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICAnJic6IHtcbiAgICAgICAgY29sb3I6IGJhc2UwMCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLWNvbnRlbnQnOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgJy5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yJzogeyBib3JkZXJMZWZ0Q29sb3I6IGN1cnNvciB9LFxuICAgICcmLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvbic6IHsgYmFja2dyb3VuZENvbG9yOiBzZWxlY3Rpb24gfSxcbiAgICAnLmNtLXBhbmVscyc6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGJhc2UwMyB9LFxuICAgICcuY20tcGFuZWxzLmNtLXBhbmVscy10b3AnOiB7IGJvcmRlckJvdHRvbTogJzJweCBzb2xpZCBibGFjaycgfSxcbiAgICAnLmNtLXBhbmVscy5jbS1wYW5lbHMtYm90dG9tJzogeyBib3JkZXJUb3A6ICcycHggc29saWQgYmxhY2snIH0sXG4gICAgJy5jbS1zZWFyY2hNYXRjaCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzcyYTFmZjU5JyxcbiAgICAgICAgb3V0bGluZTogYDFweCBzb2xpZCAke2Jhc2UwM31gXG4gICAgfSxcbiAgICAnLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhc2UwNVxuICAgIH0sXG4gICAgJy5jbS1hY3RpdmVMaW5lJzogeyBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQgfSxcbiAgICAnLmNtLXNlbGVjdGlvbk1hdGNoJzogeyBiYWNrZ3JvdW5kQ29sb3I6IGJhc2UwNSB9LFxuICAgICcmLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldCwgJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXQnOiB7XG4gICAgICAgIG91dGxpbmU6IGAxcHggc29saWQgJHtiYXNlMDN9YFxuICAgIH0sXG4gICAgJyYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0Jzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhc2UwNlxuICAgIH0sXG4gICAgJy5jbS1ndXR0ZXJzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhc2UwNixcbiAgICAgICAgY29sb3I6IGJhc2UwMCxcbiAgICAgICAgYm9yZGVyOiAnbm9uZSdcbiAgICB9LFxuICAgICcuY20tYWN0aXZlTGluZUd1dHRlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLWZvbGRQbGFjZWhvbGRlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgY29sb3I6ICcjZGRkJ1xuICAgIH0sXG4gICAgJy5jbS10b29sdGlwJzoge1xuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgJy5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgfSxcbiAgICAnLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3c6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlclRvcENvbG9yOiB0b29sdGlwQmFja2dyb3VuZCxcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlJzoge1xuICAgICAgICAnJiA+IHVsID4gbGlbYXJpYS1zZWxlY3RlZF0nOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogYmFzZTAzXG4gICAgICAgIH1cbiAgICB9XG59LCB7IGRhcms6IGZhbHNlIH0pO1xuLyoqXG5UaGUgaGlnaGxpZ2h0aW5nIHN0eWxlIGZvciBjb2RlIGluIHRoZSBCYXNpYyBMaWdodCB0aGVtZS5cbiovXG5jb25zdCBiYXNpY0xpZ2h0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjb2xvcjogYmFzZTBBIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLm5hbWUsIHRhZ3MuZGVsZXRlZCwgdGFncy5jaGFyYWN0ZXIsIHRhZ3MucHJvcGVydHlOYW1lLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlMENcbiAgICB9LFxuICAgIHsgdGFnOiBbdGFncy52YXJpYWJsZU5hbWVdLCBjb2xvcjogYmFzZTBDIH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSldLCBjb2xvcjogYmFzZTBBIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxhYmVsTmFtZV0sIGNvbG9yOiBiYXNlMDkgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MuY29sb3IsIC8qQF9fUFVSRV9fKi90YWdzLmNvbnN0YW50KHRhZ3MubmFtZSksIC8qQF9fUFVSRV9fKi90YWdzLnN0YW5kYXJkKHRhZ3MubmFtZSldLFxuICAgICAgICBjb2xvcjogYmFzZTBBXG4gICAgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLCBjb2xvcjogYmFzZTBFIH0sXG4gICAgeyB0YWc6IFt0YWdzLmJyYWNlXSwgY29sb3I6IGJhc2UwNyB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5hbm5vdGF0aW9uXSxcbiAgICAgICAgY29sb3I6IGludmFsaWRcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5udW1iZXIsIHRhZ3MuY2hhbmdlZCwgdGFncy5hbm5vdGF0aW9uLCB0YWdzLm1vZGlmaWVyLCB0YWdzLnNlbGYsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IGJhc2UwOFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLnR5cGVOYW1lLCB0YWdzLmNsYXNzTmFtZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlMERcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5vcGVyYXRvciwgdGFncy5vcGVyYXRvcktleXdvcmRdLFxuICAgICAgICBjb2xvcjogYmFzZTBFXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MudGFnTmFtZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlMEZcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5zcXVhcmVCcmFja2V0XSxcbiAgICAgICAgY29sb3I6IGJhc2UwYlxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLmFuZ2xlQnJhY2tldF0sXG4gICAgICAgIGNvbG9yOiBiYXNlMENcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5hdHRyaWJ1dGVOYW1lXSxcbiAgICAgICAgY29sb3I6IGJhc2UwRFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLnJlZ2V4cF0sXG4gICAgICAgIGNvbG9yOiBiYXNlMEFcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5xdW90ZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlMDFcbiAgICB9LFxuICAgIHsgdGFnOiBbdGFncy5zdHJpbmddLCBjb2xvcjogYmFzZTBDIH0sXG4gICAge1xuICAgICAgICB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgY29sb3I6IGJhc2UwNyxcbiAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgICB0ZXh0VW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy51cmwsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBiYXNlMENcbiAgICB9LFxuICAgIHsgdGFnOiBbdGFncy5tZXRhXSwgY29sb3I6IGJhc2UwOCB9LFxuICAgIHsgdGFnOiBbdGFncy5jb21tZW50XSwgY29sb3I6IGJhc2UwMiwgZm9udFN0eWxlOiAnaXRhbGljJyB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgZm9udFdlaWdodDogJ2JvbGQnLCBjb2xvcjogYmFzZTBBIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGZvbnRTdHlsZTogJ2l0YWxpYycsIGNvbG9yOiBiYXNlMEEgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLCB0ZXh0RGVjb3JhdGlvbjogJ2xpbmUtdGhyb3VnaCcgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBmb250V2VpZ2h0OiAnYm9sZCcsIGNvbG9yOiBiYXNlMEEgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLmhlYWRpbmcxKSwgZm9udFdlaWdodDogJ2JvbGQnLCBjb2xvcjogYmFzZTBBIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZzEsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6IGJhc2UwQSB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5oZWFkaW5nMiwgdGFncy5oZWFkaW5nMywgdGFncy5oZWFkaW5nNF0sXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgY29sb3I6IGJhc2UwQVxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLmhlYWRpbmc1LCB0YWdzLmhlYWRpbmc2XSxcbiAgICAgICAgY29sb3I6IGJhc2UwQVxuICAgIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLCBjb2xvcjogYmFzZTBDIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBiYXNlMDdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5jb250ZW50U2VwYXJhdG9yXSxcbiAgICAgICAgY29sb3I6IGJhc2UwRFxuICAgIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY29sb3I6IGJhc2UwMiwgYm9yZGVyQm90dG9tOiBgMXB4IGRvdHRlZCAke2ludmFsaWR9YCB9XG5dKTtcbi8qKlxuRXh0ZW5zaW9uIHRvIGVuYWJsZSB0aGUgQmFzaWMgTGlnaHQgdGhlbWUgKGJvdGggdGhlIGVkaXRvciB0aGVtZSBhbmRcbnRoZSBoaWdobGlnaHQgc3R5bGUpLlxuKi9cbmNvbnN0IGJhc2ljTGlnaHQgPSBbXG4gICAgYmFzaWNMaWdodFRoZW1lLFxuICAgIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcoYmFzaWNMaWdodEhpZ2hsaWdodFN0eWxlKVxuXTtcblxuZXhwb3J0IHsgYmFzaWNMaWdodCwgYmFzaWNMaWdodEhpZ2hsaWdodFN0eWxlLCBiYXNpY0xpZ2h0VGhlbWUgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG5jb25zdCBiYXNlMDAgPSAnIzAwMmIzNicsIGJhc2UwMSA9ICcjMDczNjQyJywgYmFzZTAyID0gJyM1ODZlNzUnLCBiYXNlMDMgPSAnIzY1N2I4MycsIGJhc2UwNCA9ICcjODM5NDk2JywgYmFzZTA1ID0gJyM5M2ExYTEnLCBiYXNlMDYgPSAnI2VlZThkNScsIGJhc2UwNyA9ICcjZmRmNmUzJywgYmFzZV9yZWQgPSAnI2RjMzIyZicsIGJhc2Vfb3JhbmdlID0gJyNjYjRiMTYnLCBiYXNlX3llbGxvdyA9ICcjYjU4OTAwJywgYmFzZV9ncmVlbiA9ICcjODU5OTAwJywgYmFzZV9jeWFuID0gJyMyYWExOTgnLCBiYXNlX2JsdWUgPSAnIzI2OGJkMicsIGJhc2VfdmlvbGV0ID0gJyM2YzcxYzQnLCBiYXNlX21hZ2VudGEgPSAnI2QzMzY4Mic7XG5jb25zdCBpbnZhbGlkID0gJyNkMzAxMDInLCBzdG9uZSA9IGJhc2UwNCwgZGFya0JhY2tncm91bmQgPSAnIzAwMjUyZicsIGhpZ2hsaWdodEJhY2tncm91bmQgPSAnIzE3MzU0MScsIGJhY2tncm91bmQgPSBiYXNlMDAsIHRvb2x0aXBCYWNrZ3JvdW5kID0gYmFzZTAxLCBzZWxlY3Rpb24gPSAnIzE3MzU0MScsIGN1cnNvciA9IGJhc2UwNDtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIFNvbGFyaXplZCBEYXJrLlxuKi9cbmNvbnN0IHNvbGFyaXplZERhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICAnJic6IHtcbiAgICAgICAgY29sb3I6IGJhc2UwNSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLWNvbnRlbnQnOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgJy5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yJzogeyBib3JkZXJMZWZ0Q29sb3I6IGN1cnNvciB9LFxuICAgICcmLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvbic6IHsgYmFja2dyb3VuZENvbG9yOiBzZWxlY3Rpb24gfSxcbiAgICAnLmNtLXBhbmVscyc6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGJhc2UwMyB9LFxuICAgICcuY20tcGFuZWxzLmNtLXBhbmVscy10b3AnOiB7IGJvcmRlckJvdHRvbTogJzJweCBzb2xpZCBibGFjaycgfSxcbiAgICAnLmNtLXBhbmVscy5jbS1wYW5lbHMtYm90dG9tJzogeyBib3JkZXJUb3A6ICcycHggc29saWQgYmxhY2snIH0sXG4gICAgJy5jbS1zZWFyY2hNYXRjaCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzcyYTFmZjU5JyxcbiAgICAgICAgb3V0bGluZTogJzFweCBzb2xpZCAjNDU3ZGZmJ1xuICAgIH0sXG4gICAgJy5jbS1zZWFyY2hNYXRjaC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzYxOTlmZjJmJ1xuICAgIH0sXG4gICAgJy5jbS1hY3RpdmVMaW5lJzogeyBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQgfSxcbiAgICAnLmNtLXNlbGVjdGlvbk1hdGNoJzogeyBiYWNrZ3JvdW5kQ29sb3I6ICcjYWFmZTY2MWEnIH0sXG4gICAgJyYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldCc6IHtcbiAgICAgICAgb3V0bGluZTogYDFweCBzb2xpZCAke2Jhc2UwNn1gXG4gICAgfSxcbiAgICAnLmNtLWd1dHRlcnMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZGFya0JhY2tncm91bmQsXG4gICAgICAgIGNvbG9yOiBzdG9uZSxcbiAgICAgICAgYm9yZGVyOiAnbm9uZSdcbiAgICB9LFxuICAgICcuY20tYWN0aXZlTGluZUd1dHRlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLWZvbGRQbGFjZWhvbGRlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgY29sb3I6ICcjZGRkJ1xuICAgIH0sXG4gICAgJy5jbS10b29sdGlwJzoge1xuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgJy5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgfSxcbiAgICAnLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3c6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlclRvcENvbG9yOiB0b29sdGlwQmFja2dyb3VuZCxcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICAnLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlJzoge1xuICAgICAgICAnJiA+IHVsID4gbGlbYXJpYS1zZWxlY3RlZF0nOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogYmFzZTAzXG4gICAgICAgIH1cbiAgICB9XG59LCB7IGRhcms6IHRydWUgfSk7XG4vKipcblRoZSBoaWdobGlnaHRpbmcgc3R5bGUgZm9yIGNvZGUgaW4gdGhlIFNvbGFyaXplZCBEYXJrIHRoZW1lLlxuKi9cbmNvbnN0IHNvbGFyaXplZERhcmtIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNvbG9yOiBiYXNlX2dyZWVuIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLm5hbWUsIHRhZ3MuZGVsZXRlZCwgdGFncy5jaGFyYWN0ZXIsIHRhZ3MucHJvcGVydHlOYW1lLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlX2N5YW5cbiAgICB9LFxuICAgIHsgdGFnOiBbdGFncy52YXJpYWJsZU5hbWVdLCBjb2xvcjogYmFzZTA1IH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSldLCBjb2xvcjogYmFzZV9ibHVlIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxhYmVsTmFtZV0sIGNvbG9yOiBiYXNlX21hZ2VudGEgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MuY29sb3IsIC8qQF9fUFVSRV9fKi90YWdzLmNvbnN0YW50KHRhZ3MubmFtZSksIC8qQF9fUFVSRV9fKi90YWdzLnN0YW5kYXJkKHRhZ3MubmFtZSldLFxuICAgICAgICBjb2xvcjogYmFzZV95ZWxsb3dcbiAgICB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLm5hbWUpLCB0YWdzLnNlcGFyYXRvcl0sIGNvbG9yOiBiYXNlX2N5YW4gfSxcbiAgICB7IHRhZzogW3RhZ3MuYnJhY2VdLCBjb2xvcjogYmFzZV9tYWdlbnRhIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLmFubm90YXRpb25dLFxuICAgICAgICBjb2xvcjogaW52YWxpZFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogYmFzZV9tYWdlbnRhXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lXSxcbiAgICAgICAgY29sb3I6IGJhc2Vfb3JhbmdlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3Mub3BlcmF0b3IsIHRhZ3Mub3BlcmF0b3JLZXl3b3JkXSxcbiAgICAgICAgY29sb3I6IGJhc2VfdmlvbGV0XG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MudGFnTmFtZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlX2JsdWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5zcXVhcmVCcmFja2V0XSxcbiAgICAgICAgY29sb3I6IGJhc2VfcmVkXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MuYW5nbGVCcmFja2V0XSxcbiAgICAgICAgY29sb3I6IGJhc2UwMlxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLmF0dHJpYnV0ZU5hbWVdLFxuICAgICAgICBjb2xvcjogYmFzZTA1XG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MucmVnZXhwXSxcbiAgICAgICAgY29sb3I6IGludmFsaWRcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5xdW90ZV0sXG4gICAgICAgIGNvbG9yOiBiYXNlX2dyZWVuXG4gICAgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nXSwgY29sb3I6IGJhc2VfeWVsbG93IH0sXG4gICAge1xuICAgICAgICB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgY29sb3I6IGJhc2VfY3lhbixcbiAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgICB0ZXh0VW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy51cmwsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBiYXNlX3llbGxvd1xuICAgIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGFdLCBjb2xvcjogYmFzZV9yZWQgfSxcbiAgICB7IHRhZzogW3RhZ3MuY29tbWVudF0sIGNvbG9yOiBiYXNlMDIsIGZvbnRTdHlsZTogJ2l0YWxpYycgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6IGJhc2UwNiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBmb250U3R5bGU6ICdpdGFsaWMnLCBjb2xvcjogYmFzZV9ncmVlbiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsIHRleHREZWNvcmF0aW9uOiAnbGluZS10aHJvdWdoJyB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6IGJhc2VfeWVsbG93IH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZzEsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6IGJhc2UwNyB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBbdGFncy5oZWFkaW5nMiwgdGFncy5oZWFkaW5nMywgdGFncy5oZWFkaW5nNF0sXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgY29sb3I6IGJhc2UwNlxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLmhlYWRpbmc1LCB0YWdzLmhlYWRpbmc2XSxcbiAgICAgICAgY29sb3I6IGJhc2UwNlxuICAgIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLCBjb2xvcjogYmFzZV9tYWdlbnRhIH0sXG4gICAge1xuICAgICAgICB0YWc6IFt0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgdGFncy5pbnNlcnRlZCwgdGFncy5jb250ZW50U2VwYXJhdG9yXSxcbiAgICAgICAgY29sb3I6IGJhc2VfcmVkXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogW3RhZ3MuY29udGVudFNlcGFyYXRvcl0sXG4gICAgICAgIGNvbG9yOiBiYXNlX3llbGxvd1xuICAgIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY29sb3I6IGJhc2UwMiwgYm9yZGVyQm90dG9tOiBgMXB4IGRvdHRlZCAke2Jhc2VfcmVkfWAgfVxuXSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgdGhlIFNvbGFyaXplZCBEYXJrIHRoZW1lIChib3RoIHRoZSBlZGl0b3IgdGhlbWUgYW5kXG50aGUgaGlnaGxpZ2h0IHN0eWxlKS5cbiovXG5jb25zdCBzb2xhcml6ZWREYXJrID0gW1xuICAgIHNvbGFyaXplZERhcmtUaGVtZSxcbiAgICAvKkBfX1BVUkVfXyovc3ludGF4SGlnaGxpZ2h0aW5nKHNvbGFyaXplZERhcmtIaWdobGlnaHRTdHlsZSlcbl07XG5cbmV4cG9ydCB7IHNvbGFyaXplZERhcmssIHNvbGFyaXplZERhcmtIaWdobGlnaHRTdHlsZSwgc29sYXJpemVkRGFya1RoZW1lIH07XG4iLCAiaW1wb3J0IHsgYmFzaWNTZXR1cCwgRWRpdG9yVmlldyB9IGZyb20gXCJjb2RlbWlycm9yXCJcbmltcG9ydCB7IGpzb24gfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGFuZy1qc29uXCJcbmltcG9ydCB7IGluZGVudFdpdGhUYWIgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5pbXBvcnQgeyBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3J1xuaW1wb3J0IHsgQ29tcGFydG1lbnQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBiYXNpY0xpZ2h0IH0gZnJvbSAnY202LXRoZW1lLWJhc2ljLWxpZ2h0JztcbmltcG9ydCB7IHNvbGFyaXplZERhcmsgfSBmcm9tICdjbTYtdGhlbWUtc29sYXJpemVkLWRhcmsnO1xuXG5sZXQgdGhlbWUgPSBuZXcgQ29tcGFydG1lbnRcblxuZXhwb3J0IGRlZmF1bHQgKEFscGluZSkgPT4ge1xuICAgIEFscGluZS5kYXRhKCdmaWxhbWVudEpzb25GaWVsZCcsICh7IHN0YXRlLCBkaXNhYmxlZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGNvZGVNaXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvciA9IG5ldyBFZGl0b3JWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiB0aGlzLnN0YXRlID8gdGhpcy5zdGF0ZSA6ICd7XFxuXFxufScsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuYnVpbGRFeHRlbnNpb25zQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLiRyZWZzLmpzb25CbG9ja1xuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZGFyay1tb2RlLXRvZ2dsZWQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogdGhlbWUucmVjb25maWd1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZXRhaWwgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNvbGFyaXplZERhcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBiYXNpY0xpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnVpbGRFeHRlbnNpb25zQXJyYXkoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGFya01vZGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhcmstbW9kZV0nKVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ2h0TW9kZSA9IGRhcmtNb2RlRWxlbWVudC5feF9kYXRhU3RhY2tbMF0udGhlbWUgPT09ICdsaWdodCdcblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGJhc2ljU2V0dXAsXG4gICAgICAgICAgICAgICAgICAgIGpzb24oKSxcbiAgICAgICAgICAgICAgICAgICAga2V5bWFwLm9mKFtpbmRlbnRXaXRoVGFiXSksXG4gICAgICAgICAgICAgICAgICAgIEVkaXRvclZpZXcubGluZVdyYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHYuc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgY29udGVudGVkaXRhYmxlOiAhZGlzYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lLm9mKGxpZ2h0TW9kZSA/IGJhc2ljTGlnaHQgOiBzb2xhcml6ZWREYXJrKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgSnNvbkZpZWxkQWxwaW5lUGx1Z2luIGZyb20gJy4vY29tcG9uZW50cy9qc29uLWZpZWxkJztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYWxwaW5lOmluaXQnLCAoKSA9PiB7XG4gICAgd2luZG93LkFscGluZS5wbHVnaW4oSnNvbkZpZWxkQWxwaW5lUGx1Z2luKTtcbn0pXG4iXSwKICAibWFwcGluZ3MiOiAiOztBQUdBLG1CQUFXO0FBQUEsSUFJUCxjQUFjO0FBQUE7QUFBQSxJQUlkLE9BQU8sS0FBSztBQUNSLFVBQUksTUFBTSxLQUFLLE1BQU0sS0FBSztBQUN0QixjQUFNLElBQUksV0FBVyxvQkFBb0IsNkJBQTZCLEtBQUs7QUFDL0UsYUFBTyxLQUFLLFVBQVUsS0FBSyxPQUFPLEdBQUc7QUFBQTtBQUFBLElBS3pDLEtBQUssR0FBRztBQUNKLFVBQUksSUFBSSxLQUFLLElBQUksS0FBSztBQUNsQixjQUFNLElBQUksV0FBVyx1QkFBdUIsUUFBUSxLQUFLO0FBQzdELGFBQU8sS0FBSyxVQUFVLEdBQUcsTUFBTSxHQUFHO0FBQUE7QUFBQSxJQUt0QyxRQUFRLE1BQU0sSUFBSSxNQUFNO0FBQ3BCLFVBQUksUUFBUTtBQUNaLFdBQUssVUFBVSxHQUFHLE1BQU0sT0FBTztBQUMvQixVQUFJLEtBQUs7QUFDTCxhQUFLLFVBQVUsR0FBRyxLQUFLLFFBQVEsT0FBTyxJQUFvQjtBQUM5RCxXQUFLLFVBQVUsSUFBSSxLQUFLLFFBQVEsT0FBTztBQUN2QyxhQUFPLFNBQVMsS0FBSyxPQUFPLEtBQUssU0FBVSxNQUFLLFFBQVEsS0FBSztBQUFBO0FBQUEsSUFLakUsT0FBTyxPQUFPO0FBQ1YsYUFBTyxLQUFLLFFBQVEsS0FBSyxRQUFRLEtBQUssUUFBUTtBQUFBO0FBQUEsSUFLbEQsTUFBTSxNQUFNLEtBQUssS0FBSyxRQUFRO0FBQzFCLFVBQUksUUFBUTtBQUNaLFdBQUssVUFBVSxNQUFNLElBQUksT0FBTztBQUNoQyxhQUFPLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFBQTtBQUFBLElBS3JDLEdBQUcsT0FBTztBQUNOLFVBQUksU0FBUztBQUNULGVBQU87QUFDWCxVQUFJLE1BQU0s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
